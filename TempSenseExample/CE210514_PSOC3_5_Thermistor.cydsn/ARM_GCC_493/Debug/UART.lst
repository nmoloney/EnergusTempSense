ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"UART.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	UART_initVar
  19              		.bss
  20              		.type	UART_initVar, %object
  21              		.size	UART_initVar, 1
  22              	UART_initVar:
  23 0000 00       		.space	1
  24              		.section	.text.UART_Start,"ax",%progbits
  25              		.align	2
  26              		.global	UART_Start
  27              		.thumb
  28              		.thumb_func
  29              		.type	UART_Start, %function
  30              	UART_Start:
  31              	.LFB0:
  32              		.file 1 ".\\Generated_Source\\PSoC5\\UART.c"
   1:.\Generated_Source\PSoC5/UART.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC5/UART.c **** * File Name: UART.c
   3:.\Generated_Source\PSoC5/UART.c **** * Version 2.50
   4:.\Generated_Source\PSoC5/UART.c **** *
   5:.\Generated_Source\PSoC5/UART.c **** * Description:
   6:.\Generated_Source\PSoC5/UART.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC5/UART.c **** *
   8:.\Generated_Source\PSoC5/UART.c **** * Note:
   9:.\Generated_Source\PSoC5/UART.c **** *
  10:.\Generated_Source\PSoC5/UART.c **** ********************************************************************************
  11:.\Generated_Source\PSoC5/UART.c **** * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC5/UART.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC5/UART.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC5/UART.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC5/UART.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC5/UART.c **** 
  17:.\Generated_Source\PSoC5/UART.c **** #include "UART.h"
  18:.\Generated_Source\PSoC5/UART.c **** #if (UART_INTERNAL_CLOCK_USED)
  19:.\Generated_Source\PSoC5/UART.c ****     #include "UART_IntClock.h"
  20:.\Generated_Source\PSoC5/UART.c **** #endif /* End UART_INTERNAL_CLOCK_USED */
  21:.\Generated_Source\PSoC5/UART.c **** 
  22:.\Generated_Source\PSoC5/UART.c **** 
  23:.\Generated_Source\PSoC5/UART.c **** /***************************************
  24:.\Generated_Source\PSoC5/UART.c **** * Global data allocation
  25:.\Generated_Source\PSoC5/UART.c **** ***************************************/
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 2


  26:.\Generated_Source\PSoC5/UART.c **** 
  27:.\Generated_Source\PSoC5/UART.c **** uint8 UART_initVar = 0u;
  28:.\Generated_Source\PSoC5/UART.c **** 
  29:.\Generated_Source\PSoC5/UART.c **** #if (UART_TX_INTERRUPT_ENABLED && UART_TX_ENABLED)
  30:.\Generated_Source\PSoC5/UART.c ****     volatile uint8 UART_txBuffer[UART_TX_BUFFER_SIZE];
  31:.\Generated_Source\PSoC5/UART.c ****     volatile uint8 UART_txBufferRead = 0u;
  32:.\Generated_Source\PSoC5/UART.c ****     uint8 UART_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC5/UART.c **** #endif /* (UART_TX_INTERRUPT_ENABLED && UART_TX_ENABLED) */
  34:.\Generated_Source\PSoC5/UART.c **** 
  35:.\Generated_Source\PSoC5/UART.c **** #if (UART_RX_INTERRUPT_ENABLED && (UART_RX_ENABLED || UART_HD_ENABLED))
  36:.\Generated_Source\PSoC5/UART.c ****     uint8 UART_errorStatus = 0u;
  37:.\Generated_Source\PSoC5/UART.c ****     volatile uint8 UART_rxBuffer[UART_RX_BUFFER_SIZE];
  38:.\Generated_Source\PSoC5/UART.c ****     volatile uint8 UART_rxBufferRead  = 0u;
  39:.\Generated_Source\PSoC5/UART.c ****     volatile uint8 UART_rxBufferWrite = 0u;
  40:.\Generated_Source\PSoC5/UART.c ****     volatile uint8 UART_rxBufferLoopDetect = 0u;
  41:.\Generated_Source\PSoC5/UART.c ****     volatile uint8 UART_rxBufferOverflow   = 0u;
  42:.\Generated_Source\PSoC5/UART.c ****     #if (UART_RXHW_ADDRESS_ENABLED)
  43:.\Generated_Source\PSoC5/UART.c ****         volatile uint8 UART_rxAddressMode = UART_RX_ADDRESS_MODE;
  44:.\Generated_Source\PSoC5/UART.c ****         volatile uint8 UART_rxAddressDetected = 0u;
  45:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_RXHW_ADDRESS_ENABLED) */
  46:.\Generated_Source\PSoC5/UART.c **** #endif /* (UART_RX_INTERRUPT_ENABLED && (UART_RX_ENABLED || UART_HD_ENABLED)) */
  47:.\Generated_Source\PSoC5/UART.c **** 
  48:.\Generated_Source\PSoC5/UART.c **** 
  49:.\Generated_Source\PSoC5/UART.c **** /*******************************************************************************
  50:.\Generated_Source\PSoC5/UART.c **** * Function Name: UART_Start
  51:.\Generated_Source\PSoC5/UART.c **** ********************************************************************************
  52:.\Generated_Source\PSoC5/UART.c **** *
  53:.\Generated_Source\PSoC5/UART.c **** * Summary:
  54:.\Generated_Source\PSoC5/UART.c **** *  This is the preferred method to begin component operation.
  55:.\Generated_Source\PSoC5/UART.c **** *  UART_Start() sets the initVar variable, calls the
  56:.\Generated_Source\PSoC5/UART.c **** *  UART_Init() function, and then calls the
  57:.\Generated_Source\PSoC5/UART.c **** *  UART_Enable() function.
  58:.\Generated_Source\PSoC5/UART.c **** *
  59:.\Generated_Source\PSoC5/UART.c **** * Parameters:
  60:.\Generated_Source\PSoC5/UART.c **** *  None.
  61:.\Generated_Source\PSoC5/UART.c **** *
  62:.\Generated_Source\PSoC5/UART.c **** * Return:
  63:.\Generated_Source\PSoC5/UART.c **** *  None.
  64:.\Generated_Source\PSoC5/UART.c **** *
  65:.\Generated_Source\PSoC5/UART.c **** * Global variables:
  66:.\Generated_Source\PSoC5/UART.c **** *  The UART_intiVar variable is used to indicate initial
  67:.\Generated_Source\PSoC5/UART.c **** *  configuration of this component. The variable is initialized to zero (0u)
  68:.\Generated_Source\PSoC5/UART.c **** *  and set to one (1u) the first time UART_Start() is called. This
  69:.\Generated_Source\PSoC5/UART.c **** *  allows for component initialization without re-initialization in all
  70:.\Generated_Source\PSoC5/UART.c **** *  subsequent calls to the UART_Start() routine.
  71:.\Generated_Source\PSoC5/UART.c **** *
  72:.\Generated_Source\PSoC5/UART.c **** * Reentrant:
  73:.\Generated_Source\PSoC5/UART.c **** *  No.
  74:.\Generated_Source\PSoC5/UART.c **** *
  75:.\Generated_Source\PSoC5/UART.c **** *******************************************************************************/
  76:.\Generated_Source\PSoC5/UART.c **** void UART_Start(void) 
  77:.\Generated_Source\PSoC5/UART.c **** {
  33              		.loc 1 77 0
  34              		.cfi_startproc
  35              		@ args = 0, pretend = 0, frame = 0
  36              		@ frame_needed = 1, uses_anonymous_args = 0
  37 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 3


  38              		.cfi_def_cfa_offset 8
  39              		.cfi_offset 7, -8
  40              		.cfi_offset 14, -4
  41 0002 00AF     		add	r7, sp, #0
  42              		.cfi_def_cfa_register 7
  78:.\Generated_Source\PSoC5/UART.c ****     /* If not initialized then initialize all required hardware and software */
  79:.\Generated_Source\PSoC5/UART.c ****     if(UART_initVar == 0u)
  43              		.loc 1 79 0
  44 0004 054B     		ldr	r3, .L3
  45 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  46 0008 002B     		cmp	r3, #0
  47 000a 04D1     		bne	.L2
  80:.\Generated_Source\PSoC5/UART.c ****     {
  81:.\Generated_Source\PSoC5/UART.c ****         UART_Init();
  48              		.loc 1 81 0
  49 000c FFF7FEFF 		bl	UART_Init
  82:.\Generated_Source\PSoC5/UART.c ****         UART_initVar = 1u;
  50              		.loc 1 82 0
  51 0010 024B     		ldr	r3, .L3
  52 0012 0122     		movs	r2, #1
  53 0014 1A70     		strb	r2, [r3]
  54              	.L2:
  83:.\Generated_Source\PSoC5/UART.c ****     }
  84:.\Generated_Source\PSoC5/UART.c **** 
  85:.\Generated_Source\PSoC5/UART.c ****     UART_Enable();
  55              		.loc 1 85 0
  56 0016 FFF7FEFF 		bl	UART_Enable
  86:.\Generated_Source\PSoC5/UART.c **** }
  57              		.loc 1 86 0
  58 001a 80BD     		pop	{r7, pc}
  59              	.L4:
  60              		.align	2
  61              	.L3:
  62 001c 00000000 		.word	UART_initVar
  63              		.cfi_endproc
  64              	.LFE0:
  65              		.size	UART_Start, .-UART_Start
  66              		.section	.text.UART_Init,"ax",%progbits
  67              		.align	2
  68              		.global	UART_Init
  69              		.thumb
  70              		.thumb_func
  71              		.type	UART_Init, %function
  72              	UART_Init:
  73              	.LFB1:
  87:.\Generated_Source\PSoC5/UART.c **** 
  88:.\Generated_Source\PSoC5/UART.c **** 
  89:.\Generated_Source\PSoC5/UART.c **** /*******************************************************************************
  90:.\Generated_Source\PSoC5/UART.c **** * Function Name: UART_Init
  91:.\Generated_Source\PSoC5/UART.c **** ********************************************************************************
  92:.\Generated_Source\PSoC5/UART.c **** *
  93:.\Generated_Source\PSoC5/UART.c **** * Summary:
  94:.\Generated_Source\PSoC5/UART.c **** *  Initializes or restores the component according to the customizer Configure
  95:.\Generated_Source\PSoC5/UART.c **** *  dialog settings. It is not necessary to call UART_Init() because
  96:.\Generated_Source\PSoC5/UART.c **** *  the UART_Start() API calls this function and is the preferred
  97:.\Generated_Source\PSoC5/UART.c **** *  method to begin component operation.
  98:.\Generated_Source\PSoC5/UART.c **** *
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 4


  99:.\Generated_Source\PSoC5/UART.c **** * Parameters:
 100:.\Generated_Source\PSoC5/UART.c **** *  None.
 101:.\Generated_Source\PSoC5/UART.c **** *
 102:.\Generated_Source\PSoC5/UART.c **** * Return:
 103:.\Generated_Source\PSoC5/UART.c **** *  None.
 104:.\Generated_Source\PSoC5/UART.c **** *
 105:.\Generated_Source\PSoC5/UART.c **** *******************************************************************************/
 106:.\Generated_Source\PSoC5/UART.c **** void UART_Init(void) 
 107:.\Generated_Source\PSoC5/UART.c **** {
  74              		.loc 1 107 0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 1, uses_anonymous_args = 0
  78              		@ link register save eliminated.
  79 0000 80B4     		push	{r7}
  80              		.cfi_def_cfa_offset 4
  81              		.cfi_offset 7, -4
  82 0002 00AF     		add	r7, sp, #0
  83              		.cfi_def_cfa_register 7
 108:.\Generated_Source\PSoC5/UART.c ****     #if(UART_RX_ENABLED || UART_HD_ENABLED)
 109:.\Generated_Source\PSoC5/UART.c **** 
 110:.\Generated_Source\PSoC5/UART.c ****         #if (UART_RX_INTERRUPT_ENABLED)
 111:.\Generated_Source\PSoC5/UART.c ****             /* Set RX interrupt vector and priority */
 112:.\Generated_Source\PSoC5/UART.c ****             (void) CyIntSetVector(UART_RX_VECT_NUM, &UART_RXISR);
 113:.\Generated_Source\PSoC5/UART.c ****             CyIntSetPriority(UART_RX_VECT_NUM, UART_RX_PRIOR_NUM);
 114:.\Generated_Source\PSoC5/UART.c ****             UART_errorStatus = 0u;
 115:.\Generated_Source\PSoC5/UART.c ****         #endif /* (UART_RX_INTERRUPT_ENABLED) */
 116:.\Generated_Source\PSoC5/UART.c **** 
 117:.\Generated_Source\PSoC5/UART.c ****         #if (UART_RXHW_ADDRESS_ENABLED)
 118:.\Generated_Source\PSoC5/UART.c ****             UART_SetRxAddressMode(UART_RX_ADDRESS_MODE);
 119:.\Generated_Source\PSoC5/UART.c ****             UART_SetRxAddress1(UART_RX_HW_ADDRESS1);
 120:.\Generated_Source\PSoC5/UART.c ****             UART_SetRxAddress2(UART_RX_HW_ADDRESS2);
 121:.\Generated_Source\PSoC5/UART.c ****         #endif /* End UART_RXHW_ADDRESS_ENABLED */
 122:.\Generated_Source\PSoC5/UART.c **** 
 123:.\Generated_Source\PSoC5/UART.c ****         /* Init Count7 period */
 124:.\Generated_Source\PSoC5/UART.c ****         UART_RXBITCTR_PERIOD_REG = UART_RXBITCTR_INIT;
 125:.\Generated_Source\PSoC5/UART.c ****         /* Configure the Initial RX interrupt mask */
 126:.\Generated_Source\PSoC5/UART.c ****         UART_RXSTATUS_MASK_REG  = UART_INIT_RX_INTERRUPTS_MASK;
 127:.\Generated_Source\PSoC5/UART.c ****     #endif /* End UART_RX_ENABLED || UART_HD_ENABLED*/
 128:.\Generated_Source\PSoC5/UART.c **** 
 129:.\Generated_Source\PSoC5/UART.c ****     #if(UART_TX_ENABLED)
 130:.\Generated_Source\PSoC5/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 131:.\Generated_Source\PSoC5/UART.c ****             /* Set TX interrupt vector and priority */
 132:.\Generated_Source\PSoC5/UART.c ****             (void) CyIntSetVector(UART_TX_VECT_NUM, &UART_TXISR);
 133:.\Generated_Source\PSoC5/UART.c ****             CyIntSetPriority(UART_TX_VECT_NUM, UART_TX_PRIOR_NUM);
 134:.\Generated_Source\PSoC5/UART.c ****         #endif /* (UART_TX_INTERRUPT_ENABLED) */
 135:.\Generated_Source\PSoC5/UART.c **** 
 136:.\Generated_Source\PSoC5/UART.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 137:.\Generated_Source\PSoC5/UART.c ****         #if (UART_TXCLKGEN_DP)
 138:.\Generated_Source\PSoC5/UART.c ****             UART_TXBITCLKGEN_CTR_REG = UART_BIT_CENTER;
  84              		.loc 1 138 0
  85 0004 064B     		ldr	r3, .L6
  86 0006 0622     		movs	r2, #6
  87 0008 1A70     		strb	r2, [r3]
 139:.\Generated_Source\PSoC5/UART.c ****             UART_TXBITCLKTX_COMPLETE_REG = ((UART_NUMBER_OF_DATA_BITS +
  88              		.loc 1 139 0
  89 000a 064B     		ldr	r3, .L6+4
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 5


  90 000c 4722     		movs	r2, #71
  91 000e 1A70     		strb	r2, [r3]
 140:.\Generated_Source\PSoC5/UART.c ****                         UART_NUMBER_OF_START_BIT) * UART_OVER_SAMPLE_COUNT) - 1u;
 141:.\Generated_Source\PSoC5/UART.c ****         #else
 142:.\Generated_Source\PSoC5/UART.c ****             UART_TXBITCTR_PERIOD_REG = ((UART_NUMBER_OF_DATA_BITS +
 143:.\Generated_Source\PSoC5/UART.c ****                         UART_NUMBER_OF_START_BIT) * UART_OVER_SAMPLE_8) - 1u;
 144:.\Generated_Source\PSoC5/UART.c ****         #endif /* End UART_TXCLKGEN_DP */
 145:.\Generated_Source\PSoC5/UART.c **** 
 146:.\Generated_Source\PSoC5/UART.c ****         /* Configure the Initial TX interrupt mask */
 147:.\Generated_Source\PSoC5/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 148:.\Generated_Source\PSoC5/UART.c ****             UART_TXSTATUS_MASK_REG = UART_TX_STS_FIFO_EMPTY;
 149:.\Generated_Source\PSoC5/UART.c ****         #else
 150:.\Generated_Source\PSoC5/UART.c ****             UART_TXSTATUS_MASK_REG = UART_INIT_TX_INTERRUPTS_MASK;
  92              		.loc 1 150 0
  93 0010 054B     		ldr	r3, .L6+8
  94 0012 0022     		movs	r2, #0
  95 0014 1A70     		strb	r2, [r3]
 151:.\Generated_Source\PSoC5/UART.c ****         #endif /*End UART_TX_INTERRUPT_ENABLED*/
 152:.\Generated_Source\PSoC5/UART.c **** 
 153:.\Generated_Source\PSoC5/UART.c ****     #endif /* End UART_TX_ENABLED */
 154:.\Generated_Source\PSoC5/UART.c **** 
 155:.\Generated_Source\PSoC5/UART.c ****     #if(UART_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 156:.\Generated_Source\PSoC5/UART.c ****         UART_WriteControlRegister( \
 157:.\Generated_Source\PSoC5/UART.c ****             (UART_ReadControlRegister() & (uint8)~UART_CTRL_PARITY_TYPE_MASK) | \
 158:.\Generated_Source\PSoC5/UART.c ****             (uint8)(UART_PARITY_TYPE << UART_CTRL_PARITY_TYPE0_SHIFT) );
 159:.\Generated_Source\PSoC5/UART.c ****     #endif /* End UART_PARITY_TYPE_SW */
 160:.\Generated_Source\PSoC5/UART.c **** }
  96              		.loc 1 160 0
  97 0016 BD46     		mov	sp, r7
  98              		.cfi_def_cfa_register 13
  99              		@ sp needed
 100 0018 5DF8047B 		ldr	r7, [sp], #4
 101              		.cfi_restore 7
 102              		.cfi_def_cfa_offset 0
 103 001c 7047     		bx	lr
 104              	.L7:
 105 001e 00BF     		.align	2
 106              	.L6:
 107 0020 2A650040 		.word	1073767722
 108 0024 3A650040 		.word	1073767738
 109 0028 8B650040 		.word	1073767819
 110              		.cfi_endproc
 111              	.LFE1:
 112              		.size	UART_Init, .-UART_Init
 113              		.section	.text.UART_Enable,"ax",%progbits
 114              		.align	2
 115              		.global	UART_Enable
 116              		.thumb
 117              		.thumb_func
 118              		.type	UART_Enable, %function
 119              	UART_Enable:
 120              	.LFB2:
 161:.\Generated_Source\PSoC5/UART.c **** 
 162:.\Generated_Source\PSoC5/UART.c **** 
 163:.\Generated_Source\PSoC5/UART.c **** /*******************************************************************************
 164:.\Generated_Source\PSoC5/UART.c **** * Function Name: UART_Enable
 165:.\Generated_Source\PSoC5/UART.c **** ********************************************************************************
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 6


 166:.\Generated_Source\PSoC5/UART.c **** *
 167:.\Generated_Source\PSoC5/UART.c **** * Summary:
 168:.\Generated_Source\PSoC5/UART.c **** *  Activates the hardware and begins component operation. It is not necessary
 169:.\Generated_Source\PSoC5/UART.c **** *  to call UART_Enable() because the UART_Start() API
 170:.\Generated_Source\PSoC5/UART.c **** *  calls this function, which is the preferred method to begin component
 171:.\Generated_Source\PSoC5/UART.c **** *  operation.
 172:.\Generated_Source\PSoC5/UART.c **** 
 173:.\Generated_Source\PSoC5/UART.c **** * Parameters:
 174:.\Generated_Source\PSoC5/UART.c **** *  None.
 175:.\Generated_Source\PSoC5/UART.c **** *
 176:.\Generated_Source\PSoC5/UART.c **** * Return:
 177:.\Generated_Source\PSoC5/UART.c **** *  None.
 178:.\Generated_Source\PSoC5/UART.c **** *
 179:.\Generated_Source\PSoC5/UART.c **** * Global Variables:
 180:.\Generated_Source\PSoC5/UART.c **** *  UART_rxAddressDetected - set to initial state (0).
 181:.\Generated_Source\PSoC5/UART.c **** *
 182:.\Generated_Source\PSoC5/UART.c **** *******************************************************************************/
 183:.\Generated_Source\PSoC5/UART.c **** void UART_Enable(void) 
 184:.\Generated_Source\PSoC5/UART.c **** {
 121              		.loc 1 184 0
 122              		.cfi_startproc
 123              		@ args = 0, pretend = 0, frame = 8
 124              		@ frame_needed = 1, uses_anonymous_args = 0
 125 0000 80B5     		push	{r7, lr}
 126              		.cfi_def_cfa_offset 8
 127              		.cfi_offset 7, -8
 128              		.cfi_offset 14, -4
 129 0002 82B0     		sub	sp, sp, #8
 130              		.cfi_def_cfa_offset 16
 131 0004 00AF     		add	r7, sp, #0
 132              		.cfi_def_cfa_register 7
 185:.\Generated_Source\PSoC5/UART.c ****     uint8 enableInterrupts;
 186:.\Generated_Source\PSoC5/UART.c ****     enableInterrupts = CyEnterCriticalSection();
 133              		.loc 1 186 0
 134 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 135 000a 0346     		mov	r3, r0
 136 000c FB71     		strb	r3, [r7, #7]
 187:.\Generated_Source\PSoC5/UART.c **** 
 188:.\Generated_Source\PSoC5/UART.c ****     #if (UART_RX_ENABLED || UART_HD_ENABLED)
 189:.\Generated_Source\PSoC5/UART.c ****         /* RX Counter (Count7) Enable */
 190:.\Generated_Source\PSoC5/UART.c ****         UART_RXBITCTR_CONTROL_REG |= UART_CNTR_ENABLE;
 191:.\Generated_Source\PSoC5/UART.c **** 
 192:.\Generated_Source\PSoC5/UART.c ****         /* Enable the RX Interrupt */
 193:.\Generated_Source\PSoC5/UART.c ****         UART_RXSTATUS_ACTL_REG  |= UART_INT_ENABLE;
 194:.\Generated_Source\PSoC5/UART.c **** 
 195:.\Generated_Source\PSoC5/UART.c ****         #if (UART_RX_INTERRUPT_ENABLED)
 196:.\Generated_Source\PSoC5/UART.c ****             UART_EnableRxInt();
 197:.\Generated_Source\PSoC5/UART.c **** 
 198:.\Generated_Source\PSoC5/UART.c ****             #if (UART_RXHW_ADDRESS_ENABLED)
 199:.\Generated_Source\PSoC5/UART.c ****                 UART_rxAddressDetected = 0u;
 200:.\Generated_Source\PSoC5/UART.c ****             #endif /* (UART_RXHW_ADDRESS_ENABLED) */
 201:.\Generated_Source\PSoC5/UART.c ****         #endif /* (UART_RX_INTERRUPT_ENABLED) */
 202:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_RX_ENABLED || UART_HD_ENABLED) */
 203:.\Generated_Source\PSoC5/UART.c **** 
 204:.\Generated_Source\PSoC5/UART.c ****     #if(UART_TX_ENABLED)
 205:.\Generated_Source\PSoC5/UART.c ****         /* TX Counter (DP/Count7) Enable */
 206:.\Generated_Source\PSoC5/UART.c ****         #if(!UART_TXCLKGEN_DP)
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 7


 207:.\Generated_Source\PSoC5/UART.c ****             UART_TXBITCTR_CONTROL_REG |= UART_CNTR_ENABLE;
 208:.\Generated_Source\PSoC5/UART.c ****         #endif /* End UART_TXCLKGEN_DP */
 209:.\Generated_Source\PSoC5/UART.c **** 
 210:.\Generated_Source\PSoC5/UART.c ****         /* Enable the TX Interrupt */
 211:.\Generated_Source\PSoC5/UART.c ****         UART_TXSTATUS_ACTL_REG |= UART_INT_ENABLE;
 137              		.loc 1 211 0
 138 000e 084A     		ldr	r2, .L9
 139 0010 074B     		ldr	r3, .L9
 140 0012 1B78     		ldrb	r3, [r3]
 141 0014 DBB2     		uxtb	r3, r3
 142 0016 43F01003 		orr	r3, r3, #16
 143 001a DBB2     		uxtb	r3, r3
 144 001c 1370     		strb	r3, [r2]
 212:.\Generated_Source\PSoC5/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 213:.\Generated_Source\PSoC5/UART.c ****             UART_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
 214:.\Generated_Source\PSoC5/UART.c ****             UART_EnableTxInt();
 215:.\Generated_Source\PSoC5/UART.c ****         #endif /* (UART_TX_INTERRUPT_ENABLED) */
 216:.\Generated_Source\PSoC5/UART.c ****      #endif /* (UART_TX_INTERRUPT_ENABLED) */
 217:.\Generated_Source\PSoC5/UART.c **** 
 218:.\Generated_Source\PSoC5/UART.c ****     #if (UART_INTERNAL_CLOCK_USED)
 219:.\Generated_Source\PSoC5/UART.c ****         UART_IntClock_Start();  /* Enable the clock */
 145              		.loc 1 219 0
 146 001e FFF7FEFF 		bl	UART_IntClock_Start
 220:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_INTERNAL_CLOCK_USED) */
 221:.\Generated_Source\PSoC5/UART.c **** 
 222:.\Generated_Source\PSoC5/UART.c ****     CyExitCriticalSection(enableInterrupts);
 147              		.loc 1 222 0
 148 0022 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 149 0024 1846     		mov	r0, r3
 150 0026 FFF7FEFF 		bl	CyExitCriticalSection
 223:.\Generated_Source\PSoC5/UART.c **** }
 151              		.loc 1 223 0
 152 002a 0837     		adds	r7, r7, #8
 153              		.cfi_def_cfa_offset 8
 154 002c BD46     		mov	sp, r7
 155              		.cfi_def_cfa_register 13
 156              		@ sp needed
 157 002e 80BD     		pop	{r7, pc}
 158              	.L10:
 159              		.align	2
 160              	.L9:
 161 0030 9B650040 		.word	1073767835
 162              		.cfi_endproc
 163              	.LFE2:
 164              		.size	UART_Enable, .-UART_Enable
 165              		.section	.text.UART_Stop,"ax",%progbits
 166              		.align	2
 167              		.global	UART_Stop
 168              		.thumb
 169              		.thumb_func
 170              		.type	UART_Stop, %function
 171              	UART_Stop:
 172              	.LFB3:
 224:.\Generated_Source\PSoC5/UART.c **** 
 225:.\Generated_Source\PSoC5/UART.c **** 
 226:.\Generated_Source\PSoC5/UART.c **** /*******************************************************************************
 227:.\Generated_Source\PSoC5/UART.c **** * Function Name: UART_Stop
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 8


 228:.\Generated_Source\PSoC5/UART.c **** ********************************************************************************
 229:.\Generated_Source\PSoC5/UART.c **** *
 230:.\Generated_Source\PSoC5/UART.c **** * Summary:
 231:.\Generated_Source\PSoC5/UART.c **** *  Disables the UART operation.
 232:.\Generated_Source\PSoC5/UART.c **** *
 233:.\Generated_Source\PSoC5/UART.c **** * Parameters:
 234:.\Generated_Source\PSoC5/UART.c **** *  None.
 235:.\Generated_Source\PSoC5/UART.c **** *
 236:.\Generated_Source\PSoC5/UART.c **** * Return:
 237:.\Generated_Source\PSoC5/UART.c **** *  None.
 238:.\Generated_Source\PSoC5/UART.c **** *
 239:.\Generated_Source\PSoC5/UART.c **** *******************************************************************************/
 240:.\Generated_Source\PSoC5/UART.c **** void UART_Stop(void) 
 241:.\Generated_Source\PSoC5/UART.c **** {
 173              		.loc 1 241 0
 174              		.cfi_startproc
 175              		@ args = 0, pretend = 0, frame = 8
 176              		@ frame_needed = 1, uses_anonymous_args = 0
 177 0000 80B5     		push	{r7, lr}
 178              		.cfi_def_cfa_offset 8
 179              		.cfi_offset 7, -8
 180              		.cfi_offset 14, -4
 181 0002 82B0     		sub	sp, sp, #8
 182              		.cfi_def_cfa_offset 16
 183 0004 00AF     		add	r7, sp, #0
 184              		.cfi_def_cfa_register 7
 242:.\Generated_Source\PSoC5/UART.c ****     uint8 enableInterrupts;
 243:.\Generated_Source\PSoC5/UART.c ****     enableInterrupts = CyEnterCriticalSection();
 185              		.loc 1 243 0
 186 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 187 000a 0346     		mov	r3, r0
 188 000c FB71     		strb	r3, [r7, #7]
 244:.\Generated_Source\PSoC5/UART.c **** 
 245:.\Generated_Source\PSoC5/UART.c ****     /* Write Bit Counter Disable */
 246:.\Generated_Source\PSoC5/UART.c ****     #if (UART_RX_ENABLED || UART_HD_ENABLED)
 247:.\Generated_Source\PSoC5/UART.c ****         UART_RXBITCTR_CONTROL_REG &= (uint8) ~UART_CNTR_ENABLE;
 248:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_RX_ENABLED || UART_HD_ENABLED) */
 249:.\Generated_Source\PSoC5/UART.c **** 
 250:.\Generated_Source\PSoC5/UART.c ****     #if (UART_TX_ENABLED)
 251:.\Generated_Source\PSoC5/UART.c ****         #if(!UART_TXCLKGEN_DP)
 252:.\Generated_Source\PSoC5/UART.c ****             UART_TXBITCTR_CONTROL_REG &= (uint8) ~UART_CNTR_ENABLE;
 253:.\Generated_Source\PSoC5/UART.c ****         #endif /* (!UART_TXCLKGEN_DP) */
 254:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_TX_ENABLED) */
 255:.\Generated_Source\PSoC5/UART.c **** 
 256:.\Generated_Source\PSoC5/UART.c ****     #if (UART_INTERNAL_CLOCK_USED)
 257:.\Generated_Source\PSoC5/UART.c ****         UART_IntClock_Stop();   /* Disable the clock */
 189              		.loc 1 257 0
 190 000e FFF7FEFF 		bl	UART_IntClock_Stop
 258:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_INTERNAL_CLOCK_USED) */
 259:.\Generated_Source\PSoC5/UART.c **** 
 260:.\Generated_Source\PSoC5/UART.c ****     /* Disable internal interrupt component */
 261:.\Generated_Source\PSoC5/UART.c ****     #if (UART_RX_ENABLED || UART_HD_ENABLED)
 262:.\Generated_Source\PSoC5/UART.c ****         UART_RXSTATUS_ACTL_REG  &= (uint8) ~UART_INT_ENABLE;
 263:.\Generated_Source\PSoC5/UART.c **** 
 264:.\Generated_Source\PSoC5/UART.c ****         #if (UART_RX_INTERRUPT_ENABLED)
 265:.\Generated_Source\PSoC5/UART.c ****             UART_DisableRxInt();
 266:.\Generated_Source\PSoC5/UART.c ****         #endif /* (UART_RX_INTERRUPT_ENABLED) */
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 9


 267:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_RX_ENABLED || UART_HD_ENABLED) */
 268:.\Generated_Source\PSoC5/UART.c **** 
 269:.\Generated_Source\PSoC5/UART.c ****     #if (UART_TX_ENABLED)
 270:.\Generated_Source\PSoC5/UART.c ****         UART_TXSTATUS_ACTL_REG &= (uint8) ~UART_INT_ENABLE;
 191              		.loc 1 270 0
 192 0012 074A     		ldr	r2, .L12
 193 0014 064B     		ldr	r3, .L12
 194 0016 1B78     		ldrb	r3, [r3]
 195 0018 DBB2     		uxtb	r3, r3
 196 001a 23F01003 		bic	r3, r3, #16
 197 001e DBB2     		uxtb	r3, r3
 198 0020 1370     		strb	r3, [r2]
 271:.\Generated_Source\PSoC5/UART.c **** 
 272:.\Generated_Source\PSoC5/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 273:.\Generated_Source\PSoC5/UART.c ****             UART_DisableTxInt();
 274:.\Generated_Source\PSoC5/UART.c ****         #endif /* (UART_TX_INTERRUPT_ENABLED) */
 275:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_TX_ENABLED) */
 276:.\Generated_Source\PSoC5/UART.c **** 
 277:.\Generated_Source\PSoC5/UART.c ****     CyExitCriticalSection(enableInterrupts);
 199              		.loc 1 277 0
 200 0022 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 201 0024 1846     		mov	r0, r3
 202 0026 FFF7FEFF 		bl	CyExitCriticalSection
 278:.\Generated_Source\PSoC5/UART.c **** }
 203              		.loc 1 278 0
 204 002a 0837     		adds	r7, r7, #8
 205              		.cfi_def_cfa_offset 8
 206 002c BD46     		mov	sp, r7
 207              		.cfi_def_cfa_register 13
 208              		@ sp needed
 209 002e 80BD     		pop	{r7, pc}
 210              	.L13:
 211              		.align	2
 212              	.L12:
 213 0030 9B650040 		.word	1073767835
 214              		.cfi_endproc
 215              	.LFE3:
 216              		.size	UART_Stop, .-UART_Stop
 217              		.section	.text.UART_ReadControlRegister,"ax",%progbits
 218              		.align	2
 219              		.global	UART_ReadControlRegister
 220              		.thumb
 221              		.thumb_func
 222              		.type	UART_ReadControlRegister, %function
 223              	UART_ReadControlRegister:
 224              	.LFB4:
 279:.\Generated_Source\PSoC5/UART.c **** 
 280:.\Generated_Source\PSoC5/UART.c **** 
 281:.\Generated_Source\PSoC5/UART.c **** /*******************************************************************************
 282:.\Generated_Source\PSoC5/UART.c **** * Function Name: UART_ReadControlRegister
 283:.\Generated_Source\PSoC5/UART.c **** ********************************************************************************
 284:.\Generated_Source\PSoC5/UART.c **** *
 285:.\Generated_Source\PSoC5/UART.c **** * Summary:
 286:.\Generated_Source\PSoC5/UART.c **** *  Returns the current value of the control register.
 287:.\Generated_Source\PSoC5/UART.c **** *
 288:.\Generated_Source\PSoC5/UART.c **** * Parameters:
 289:.\Generated_Source\PSoC5/UART.c **** *  None.
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 10


 290:.\Generated_Source\PSoC5/UART.c **** *
 291:.\Generated_Source\PSoC5/UART.c **** * Return:
 292:.\Generated_Source\PSoC5/UART.c **** *  Contents of the control register.
 293:.\Generated_Source\PSoC5/UART.c **** *
 294:.\Generated_Source\PSoC5/UART.c **** *******************************************************************************/
 295:.\Generated_Source\PSoC5/UART.c **** uint8 UART_ReadControlRegister(void) 
 296:.\Generated_Source\PSoC5/UART.c **** {
 225              		.loc 1 296 0
 226              		.cfi_startproc
 227              		@ args = 0, pretend = 0, frame = 0
 228              		@ frame_needed = 1, uses_anonymous_args = 0
 229              		@ link register save eliminated.
 230 0000 80B4     		push	{r7}
 231              		.cfi_def_cfa_offset 4
 232              		.cfi_offset 7, -4
 233 0002 00AF     		add	r7, sp, #0
 234              		.cfi_def_cfa_register 7
 297:.\Generated_Source\PSoC5/UART.c ****     #if (UART_CONTROL_REG_REMOVED)
 298:.\Generated_Source\PSoC5/UART.c ****         return(0u);
 235              		.loc 1 298 0
 236 0004 0023     		movs	r3, #0
 299:.\Generated_Source\PSoC5/UART.c ****     #else
 300:.\Generated_Source\PSoC5/UART.c ****         return(UART_CONTROL_REG);
 301:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_CONTROL_REG_REMOVED) */
 302:.\Generated_Source\PSoC5/UART.c **** }
 237              		.loc 1 302 0
 238 0006 1846     		mov	r0, r3
 239 0008 BD46     		mov	sp, r7
 240              		.cfi_def_cfa_register 13
 241              		@ sp needed
 242 000a 5DF8047B 		ldr	r7, [sp], #4
 243              		.cfi_restore 7
 244              		.cfi_def_cfa_offset 0
 245 000e 7047     		bx	lr
 246              		.cfi_endproc
 247              	.LFE4:
 248              		.size	UART_ReadControlRegister, .-UART_ReadControlRegister
 249              		.section	.text.UART_WriteControlRegister,"ax",%progbits
 250              		.align	2
 251              		.global	UART_WriteControlRegister
 252              		.thumb
 253              		.thumb_func
 254              		.type	UART_WriteControlRegister, %function
 255              	UART_WriteControlRegister:
 256              	.LFB5:
 303:.\Generated_Source\PSoC5/UART.c **** 
 304:.\Generated_Source\PSoC5/UART.c **** 
 305:.\Generated_Source\PSoC5/UART.c **** /*******************************************************************************
 306:.\Generated_Source\PSoC5/UART.c **** * Function Name: UART_WriteControlRegister
 307:.\Generated_Source\PSoC5/UART.c **** ********************************************************************************
 308:.\Generated_Source\PSoC5/UART.c **** *
 309:.\Generated_Source\PSoC5/UART.c **** * Summary:
 310:.\Generated_Source\PSoC5/UART.c **** *  Writes an 8-bit value into the control register
 311:.\Generated_Source\PSoC5/UART.c **** *
 312:.\Generated_Source\PSoC5/UART.c **** * Parameters:
 313:.\Generated_Source\PSoC5/UART.c **** *  control:  control register value
 314:.\Generated_Source\PSoC5/UART.c **** *
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 11


 315:.\Generated_Source\PSoC5/UART.c **** * Return:
 316:.\Generated_Source\PSoC5/UART.c **** *  None.
 317:.\Generated_Source\PSoC5/UART.c **** *
 318:.\Generated_Source\PSoC5/UART.c **** *******************************************************************************/
 319:.\Generated_Source\PSoC5/UART.c **** void  UART_WriteControlRegister(uint8 control) 
 320:.\Generated_Source\PSoC5/UART.c **** {
 257              		.loc 1 320 0
 258              		.cfi_startproc
 259              		@ args = 0, pretend = 0, frame = 8
 260              		@ frame_needed = 1, uses_anonymous_args = 0
 261              		@ link register save eliminated.
 262 0000 80B4     		push	{r7}
 263              		.cfi_def_cfa_offset 4
 264              		.cfi_offset 7, -4
 265 0002 83B0     		sub	sp, sp, #12
 266              		.cfi_def_cfa_offset 16
 267 0004 00AF     		add	r7, sp, #0
 268              		.cfi_def_cfa_register 7
 269 0006 0346     		mov	r3, r0
 270 0008 FB71     		strb	r3, [r7, #7]
 321:.\Generated_Source\PSoC5/UART.c ****     #if (UART_CONTROL_REG_REMOVED)
 322:.\Generated_Source\PSoC5/UART.c ****         if(0u != control)
 323:.\Generated_Source\PSoC5/UART.c ****         {
 324:.\Generated_Source\PSoC5/UART.c ****             /* Suppress compiler warning */
 325:.\Generated_Source\PSoC5/UART.c ****         }
 326:.\Generated_Source\PSoC5/UART.c ****     #else
 327:.\Generated_Source\PSoC5/UART.c ****        UART_CONTROL_REG = control;
 328:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_CONTROL_REG_REMOVED) */
 329:.\Generated_Source\PSoC5/UART.c **** }
 271              		.loc 1 329 0
 272 000a 0C37     		adds	r7, r7, #12
 273              		.cfi_def_cfa_offset 4
 274 000c BD46     		mov	sp, r7
 275              		.cfi_def_cfa_register 13
 276              		@ sp needed
 277 000e 5DF8047B 		ldr	r7, [sp], #4
 278              		.cfi_restore 7
 279              		.cfi_def_cfa_offset 0
 280 0012 7047     		bx	lr
 281              		.cfi_endproc
 282              	.LFE5:
 283              		.size	UART_WriteControlRegister, .-UART_WriteControlRegister
 284              		.section	.text.UART_SetTxInterruptMode,"ax",%progbits
 285              		.align	2
 286              		.global	UART_SetTxInterruptMode
 287              		.thumb
 288              		.thumb_func
 289              		.type	UART_SetTxInterruptMode, %function
 290              	UART_SetTxInterruptMode:
 291              	.LFB6:
 330:.\Generated_Source\PSoC5/UART.c **** 
 331:.\Generated_Source\PSoC5/UART.c **** 
 332:.\Generated_Source\PSoC5/UART.c **** #if(UART_RX_ENABLED || UART_HD_ENABLED)
 333:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 334:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_SetRxInterruptMode
 335:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 336:.\Generated_Source\PSoC5/UART.c ****     *
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 12


 337:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 338:.\Generated_Source\PSoC5/UART.c ****     *  Configures the RX interrupt sources enabled.
 339:.\Generated_Source\PSoC5/UART.c ****     *
 340:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 341:.\Generated_Source\PSoC5/UART.c ****     *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342:.\Generated_Source\PSoC5/UART.c ****     *  bit-field arrangement of the status register. This value must be a 
 343:.\Generated_Source\PSoC5/UART.c ****     *  combination of status register bit-masks shown below:
 344:.\Generated_Source\PSoC5/UART.c ****     *      UART_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345:.\Generated_Source\PSoC5/UART.c ****     *      UART_RX_STS_PAR_ERROR        Interrupt on parity error.
 346:.\Generated_Source\PSoC5/UART.c ****     *      UART_RX_STS_STOP_ERROR       Interrupt on stop error.
 347:.\Generated_Source\PSoC5/UART.c ****     *      UART_RX_STS_BREAK            Interrupt on break.
 348:.\Generated_Source\PSoC5/UART.c ****     *      UART_RX_STS_OVERRUN          Interrupt on overrun error.
 349:.\Generated_Source\PSoC5/UART.c ****     *      UART_RX_STS_ADDR_MATCH       Interrupt on address match.
 350:.\Generated_Source\PSoC5/UART.c ****     *      UART_RX_STS_MRKSPC           Interrupt on address detect.
 351:.\Generated_Source\PSoC5/UART.c ****     *
 352:.\Generated_Source\PSoC5/UART.c ****     * Return:
 353:.\Generated_Source\PSoC5/UART.c ****     *  None.
 354:.\Generated_Source\PSoC5/UART.c ****     *
 355:.\Generated_Source\PSoC5/UART.c ****     * Theory:
 356:.\Generated_Source\PSoC5/UART.c ****     *  Enables the output of specific status bits to the interrupt controller
 357:.\Generated_Source\PSoC5/UART.c ****     *
 358:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 359:.\Generated_Source\PSoC5/UART.c ****     void UART_SetRxInterruptMode(uint8 intSrc) 
 360:.\Generated_Source\PSoC5/UART.c ****     {
 361:.\Generated_Source\PSoC5/UART.c ****         UART_RXSTATUS_MASK_REG  = intSrc;
 362:.\Generated_Source\PSoC5/UART.c ****     }
 363:.\Generated_Source\PSoC5/UART.c **** 
 364:.\Generated_Source\PSoC5/UART.c **** 
 365:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 366:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_ReadRxData
 367:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 368:.\Generated_Source\PSoC5/UART.c ****     *
 369:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 370:.\Generated_Source\PSoC5/UART.c ****     *  Returns the next byte of received data. This function returns data without
 371:.\Generated_Source\PSoC5/UART.c ****     *  checking the status. You must check the status separately.
 372:.\Generated_Source\PSoC5/UART.c ****     *
 373:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 374:.\Generated_Source\PSoC5/UART.c ****     *  None.
 375:.\Generated_Source\PSoC5/UART.c ****     *
 376:.\Generated_Source\PSoC5/UART.c ****     * Return:
 377:.\Generated_Source\PSoC5/UART.c ****     *  Received data from RX register
 378:.\Generated_Source\PSoC5/UART.c ****     *
 379:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
 380:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBuffer - RAM buffer pointer for save received data.
 381:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferWrite - cyclic index for write to rxBuffer,
 382:.\Generated_Source\PSoC5/UART.c ****     *     checked to identify new data.
 383:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferRead - cyclic index for read from rxBuffer,
 384:.\Generated_Source\PSoC5/UART.c ****     *     incremented after each byte has been read from buffer.
 385:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferLoopDetect - cleared if loop condition was detected
 386:.\Generated_Source\PSoC5/UART.c ****     *     in RX ISR.
 387:.\Generated_Source\PSoC5/UART.c ****     *
 388:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
 389:.\Generated_Source\PSoC5/UART.c ****     *  No.
 390:.\Generated_Source\PSoC5/UART.c ****     *
 391:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 392:.\Generated_Source\PSoC5/UART.c ****     uint8 UART_ReadRxData(void) 
 393:.\Generated_Source\PSoC5/UART.c ****     {
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 13


 394:.\Generated_Source\PSoC5/UART.c ****         uint8 rxData;
 395:.\Generated_Source\PSoC5/UART.c **** 
 396:.\Generated_Source\PSoC5/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 397:.\Generated_Source\PSoC5/UART.c **** 
 398:.\Generated_Source\PSoC5/UART.c ****         uint8 locRxBufferRead;
 399:.\Generated_Source\PSoC5/UART.c ****         uint8 locRxBufferWrite;
 400:.\Generated_Source\PSoC5/UART.c **** 
 401:.\Generated_Source\PSoC5/UART.c ****         /* Protect variables that could change on interrupt */
 402:.\Generated_Source\PSoC5/UART.c ****         UART_DisableRxInt();
 403:.\Generated_Source\PSoC5/UART.c **** 
 404:.\Generated_Source\PSoC5/UART.c ****         locRxBufferRead  = UART_rxBufferRead;
 405:.\Generated_Source\PSoC5/UART.c ****         locRxBufferWrite = UART_rxBufferWrite;
 406:.\Generated_Source\PSoC5/UART.c **** 
 407:.\Generated_Source\PSoC5/UART.c ****         if( (UART_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 408:.\Generated_Source\PSoC5/UART.c ****         {
 409:.\Generated_Source\PSoC5/UART.c ****             rxData = UART_rxBuffer[locRxBufferRead];
 410:.\Generated_Source\PSoC5/UART.c ****             locRxBufferRead++;
 411:.\Generated_Source\PSoC5/UART.c **** 
 412:.\Generated_Source\PSoC5/UART.c ****             if(locRxBufferRead >= UART_RX_BUFFER_SIZE)
 413:.\Generated_Source\PSoC5/UART.c ****             {
 414:.\Generated_Source\PSoC5/UART.c ****                 locRxBufferRead = 0u;
 415:.\Generated_Source\PSoC5/UART.c ****             }
 416:.\Generated_Source\PSoC5/UART.c ****             /* Update the real pointer */
 417:.\Generated_Source\PSoC5/UART.c ****             UART_rxBufferRead = locRxBufferRead;
 418:.\Generated_Source\PSoC5/UART.c **** 
 419:.\Generated_Source\PSoC5/UART.c ****             if(UART_rxBufferLoopDetect != 0u)
 420:.\Generated_Source\PSoC5/UART.c ****             {
 421:.\Generated_Source\PSoC5/UART.c ****                 UART_rxBufferLoopDetect = 0u;
 422:.\Generated_Source\PSoC5/UART.c ****                 #if ((UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u))
 423:.\Generated_Source\PSoC5/UART.c ****                     /* When Hardware Flow Control selected - return RX mask */
 424:.\Generated_Source\PSoC5/UART.c ****                     #if( UART_HD_ENABLED )
 425:.\Generated_Source\PSoC5/UART.c ****                         if((UART_CONTROL_REG & UART_CTRL_HD_SEND) == 0u)
 426:.\Generated_Source\PSoC5/UART.c ****                         {   /* In Half duplex mode return RX mask only in RX
 427:.\Generated_Source\PSoC5/UART.c ****                             *  configuration set, otherwise
 428:.\Generated_Source\PSoC5/UART.c ****                             *  mask will be returned in LoadRxConfig() API.
 429:.\Generated_Source\PSoC5/UART.c ****                             */
 430:.\Generated_Source\PSoC5/UART.c ****                             UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
 431:.\Generated_Source\PSoC5/UART.c ****                         }
 432:.\Generated_Source\PSoC5/UART.c ****                     #else
 433:.\Generated_Source\PSoC5/UART.c ****                         UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
 434:.\Generated_Source\PSoC5/UART.c ****                     #endif /* end UART_HD_ENABLED */
 435:.\Generated_Source\PSoC5/UART.c ****                 #endif /* ((UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u)) */
 436:.\Generated_Source\PSoC5/UART.c ****             }
 437:.\Generated_Source\PSoC5/UART.c ****         }
 438:.\Generated_Source\PSoC5/UART.c ****         else
 439:.\Generated_Source\PSoC5/UART.c ****         {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 440:.\Generated_Source\PSoC5/UART.c ****             rxData = UART_RXDATA_REG;
 441:.\Generated_Source\PSoC5/UART.c ****         }
 442:.\Generated_Source\PSoC5/UART.c **** 
 443:.\Generated_Source\PSoC5/UART.c ****         UART_EnableRxInt();
 444:.\Generated_Source\PSoC5/UART.c **** 
 445:.\Generated_Source\PSoC5/UART.c ****     #else
 446:.\Generated_Source\PSoC5/UART.c **** 
 447:.\Generated_Source\PSoC5/UART.c ****         /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 448:.\Generated_Source\PSoC5/UART.c ****         rxData = UART_RXDATA_REG;
 449:.\Generated_Source\PSoC5/UART.c **** 
 450:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 14


 451:.\Generated_Source\PSoC5/UART.c **** 
 452:.\Generated_Source\PSoC5/UART.c ****         return(rxData);
 453:.\Generated_Source\PSoC5/UART.c ****     }
 454:.\Generated_Source\PSoC5/UART.c **** 
 455:.\Generated_Source\PSoC5/UART.c **** 
 456:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 457:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_ReadRxStatus
 458:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 459:.\Generated_Source\PSoC5/UART.c ****     *
 460:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 461:.\Generated_Source\PSoC5/UART.c ****     *  Returns the current state of the receiver status register and the software
 462:.\Generated_Source\PSoC5/UART.c ****     *  buffer overflow status.
 463:.\Generated_Source\PSoC5/UART.c ****     *
 464:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 465:.\Generated_Source\PSoC5/UART.c ****     *  None.
 466:.\Generated_Source\PSoC5/UART.c ****     *
 467:.\Generated_Source\PSoC5/UART.c ****     * Return:
 468:.\Generated_Source\PSoC5/UART.c ****     *  Current state of the status register.
 469:.\Generated_Source\PSoC5/UART.c ****     *
 470:.\Generated_Source\PSoC5/UART.c ****     * Side Effect:
 471:.\Generated_Source\PSoC5/UART.c ****     *  All status register bits are clear-on-read except
 472:.\Generated_Source\PSoC5/UART.c ****     *  UART_RX_STS_FIFO_NOTEMPTY.
 473:.\Generated_Source\PSoC5/UART.c ****     *  UART_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474:.\Generated_Source\PSoC5/UART.c ****     *  register read.
 475:.\Generated_Source\PSoC5/UART.c ****     *
 476:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
 477:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferOverflow - used to indicate overload condition.
 478:.\Generated_Source\PSoC5/UART.c ****     *   It set to one in RX interrupt when there isn't free space in
 479:.\Generated_Source\PSoC5/UART.c ****     *   UART_rxBufferRead to write new data. This condition returned
 480:.\Generated_Source\PSoC5/UART.c ****     *   and cleared to zero by this API as an
 481:.\Generated_Source\PSoC5/UART.c ****     *   UART_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482:.\Generated_Source\PSoC5/UART.c ****     *   bits.
 483:.\Generated_Source\PSoC5/UART.c ****     *
 484:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 485:.\Generated_Source\PSoC5/UART.c ****     uint8 UART_ReadRxStatus(void) 
 486:.\Generated_Source\PSoC5/UART.c ****     {
 487:.\Generated_Source\PSoC5/UART.c ****         uint8 status;
 488:.\Generated_Source\PSoC5/UART.c **** 
 489:.\Generated_Source\PSoC5/UART.c ****         status = UART_RXSTATUS_REG & UART_RX_HW_MASK;
 490:.\Generated_Source\PSoC5/UART.c **** 
 491:.\Generated_Source\PSoC5/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 492:.\Generated_Source\PSoC5/UART.c ****         if(UART_rxBufferOverflow != 0u)
 493:.\Generated_Source\PSoC5/UART.c ****         {
 494:.\Generated_Source\PSoC5/UART.c ****             status |= UART_RX_STS_SOFT_BUFF_OVER;
 495:.\Generated_Source\PSoC5/UART.c ****             UART_rxBufferOverflow = 0u;
 496:.\Generated_Source\PSoC5/UART.c ****         }
 497:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 498:.\Generated_Source\PSoC5/UART.c **** 
 499:.\Generated_Source\PSoC5/UART.c ****         return(status);
 500:.\Generated_Source\PSoC5/UART.c ****     }
 501:.\Generated_Source\PSoC5/UART.c **** 
 502:.\Generated_Source\PSoC5/UART.c **** 
 503:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 504:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_GetChar
 505:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 506:.\Generated_Source\PSoC5/UART.c ****     *
 507:.\Generated_Source\PSoC5/UART.c ****     * Summary:
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 15


 508:.\Generated_Source\PSoC5/UART.c ****     *  Returns the last received byte of data. UART_GetChar() is
 509:.\Generated_Source\PSoC5/UART.c ****     *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510:.\Generated_Source\PSoC5/UART.c ****     *  for valid characters and 0 indicates an error occurred or no data is present.
 511:.\Generated_Source\PSoC5/UART.c ****     *
 512:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 513:.\Generated_Source\PSoC5/UART.c ****     *  None.
 514:.\Generated_Source\PSoC5/UART.c ****     *
 515:.\Generated_Source\PSoC5/UART.c ****     * Return:
 516:.\Generated_Source\PSoC5/UART.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517:.\Generated_Source\PSoC5/UART.c ****     *  A returned zero signifies an error condition or no data available.
 518:.\Generated_Source\PSoC5/UART.c ****     *
 519:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
 520:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBuffer - RAM buffer pointer for save received data.
 521:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferWrite - cyclic index for write to rxBuffer,
 522:.\Generated_Source\PSoC5/UART.c ****     *     checked to identify new data.
 523:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferRead - cyclic index for read from rxBuffer,
 524:.\Generated_Source\PSoC5/UART.c ****     *     incremented after each byte has been read from buffer.
 525:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferLoopDetect - cleared if loop condition was detected
 526:.\Generated_Source\PSoC5/UART.c ****     *     in RX ISR.
 527:.\Generated_Source\PSoC5/UART.c ****     *
 528:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
 529:.\Generated_Source\PSoC5/UART.c ****     *  No.
 530:.\Generated_Source\PSoC5/UART.c ****     *
 531:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 532:.\Generated_Source\PSoC5/UART.c ****     uint8 UART_GetChar(void) 
 533:.\Generated_Source\PSoC5/UART.c ****     {
 534:.\Generated_Source\PSoC5/UART.c ****         uint8 rxData = 0u;
 535:.\Generated_Source\PSoC5/UART.c ****         uint8 rxStatus;
 536:.\Generated_Source\PSoC5/UART.c **** 
 537:.\Generated_Source\PSoC5/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 538:.\Generated_Source\PSoC5/UART.c ****         uint8 locRxBufferRead;
 539:.\Generated_Source\PSoC5/UART.c ****         uint8 locRxBufferWrite;
 540:.\Generated_Source\PSoC5/UART.c **** 
 541:.\Generated_Source\PSoC5/UART.c ****         /* Protect variables that could change on interrupt */
 542:.\Generated_Source\PSoC5/UART.c ****         UART_DisableRxInt();
 543:.\Generated_Source\PSoC5/UART.c **** 
 544:.\Generated_Source\PSoC5/UART.c ****         locRxBufferRead  = UART_rxBufferRead;
 545:.\Generated_Source\PSoC5/UART.c ****         locRxBufferWrite = UART_rxBufferWrite;
 546:.\Generated_Source\PSoC5/UART.c **** 
 547:.\Generated_Source\PSoC5/UART.c ****         if( (UART_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 548:.\Generated_Source\PSoC5/UART.c ****         {
 549:.\Generated_Source\PSoC5/UART.c ****             rxData = UART_rxBuffer[locRxBufferRead];
 550:.\Generated_Source\PSoC5/UART.c ****             locRxBufferRead++;
 551:.\Generated_Source\PSoC5/UART.c ****             if(locRxBufferRead >= UART_RX_BUFFER_SIZE)
 552:.\Generated_Source\PSoC5/UART.c ****             {
 553:.\Generated_Source\PSoC5/UART.c ****                 locRxBufferRead = 0u;
 554:.\Generated_Source\PSoC5/UART.c ****             }
 555:.\Generated_Source\PSoC5/UART.c ****             /* Update the real pointer */
 556:.\Generated_Source\PSoC5/UART.c ****             UART_rxBufferRead = locRxBufferRead;
 557:.\Generated_Source\PSoC5/UART.c **** 
 558:.\Generated_Source\PSoC5/UART.c ****             if(UART_rxBufferLoopDetect != 0u)
 559:.\Generated_Source\PSoC5/UART.c ****             {
 560:.\Generated_Source\PSoC5/UART.c ****                 UART_rxBufferLoopDetect = 0u;
 561:.\Generated_Source\PSoC5/UART.c ****                 #if( (UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u) )
 562:.\Generated_Source\PSoC5/UART.c ****                     /* When Hardware Flow Control selected - return RX mask */
 563:.\Generated_Source\PSoC5/UART.c ****                     #if( UART_HD_ENABLED )
 564:.\Generated_Source\PSoC5/UART.c ****                         if((UART_CONTROL_REG & UART_CTRL_HD_SEND) == 0u)
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 16


 565:.\Generated_Source\PSoC5/UART.c ****                         {   /* In Half duplex mode return RX mask only if
 566:.\Generated_Source\PSoC5/UART.c ****                             *  RX configuration set, otherwise
 567:.\Generated_Source\PSoC5/UART.c ****                             *  mask will be returned in LoadRxConfig() API.
 568:.\Generated_Source\PSoC5/UART.c ****                             */
 569:.\Generated_Source\PSoC5/UART.c ****                             UART_RXSTATUS_MASK_REG |= UART_RX_STS_FIFO_NOTEMPTY;
 570:.\Generated_Source\PSoC5/UART.c ****                         }
 571:.\Generated_Source\PSoC5/UART.c ****                     #else
 572:.\Generated_Source\PSoC5/UART.c ****                         UART_RXSTATUS_MASK_REG |= UART_RX_STS_FIFO_NOTEMPTY;
 573:.\Generated_Source\PSoC5/UART.c ****                     #endif /* end UART_HD_ENABLED */
 574:.\Generated_Source\PSoC5/UART.c ****                 #endif /* UART_RX_INTERRUPT_ENABLED and Hardware flow control*/
 575:.\Generated_Source\PSoC5/UART.c ****             }
 576:.\Generated_Source\PSoC5/UART.c **** 
 577:.\Generated_Source\PSoC5/UART.c ****         }
 578:.\Generated_Source\PSoC5/UART.c ****         else
 579:.\Generated_Source\PSoC5/UART.c ****         {   rxStatus = UART_RXSTATUS_REG;
 580:.\Generated_Source\PSoC5/UART.c ****             if((rxStatus & UART_RX_STS_FIFO_NOTEMPTY) != 0u)
 581:.\Generated_Source\PSoC5/UART.c ****             {   /* Read received data from FIFO */
 582:.\Generated_Source\PSoC5/UART.c ****                 rxData = UART_RXDATA_REG;
 583:.\Generated_Source\PSoC5/UART.c ****                 /*Check status on error*/
 584:.\Generated_Source\PSoC5/UART.c ****                 if((rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
 585:.\Generated_Source\PSoC5/UART.c ****                                 UART_RX_STS_STOP_ERROR | UART_RX_STS_OVERRUN)) != 0u)
 586:.\Generated_Source\PSoC5/UART.c ****                 {
 587:.\Generated_Source\PSoC5/UART.c ****                     rxData = 0u;
 588:.\Generated_Source\PSoC5/UART.c ****                 }
 589:.\Generated_Source\PSoC5/UART.c ****             }
 590:.\Generated_Source\PSoC5/UART.c ****         }
 591:.\Generated_Source\PSoC5/UART.c **** 
 592:.\Generated_Source\PSoC5/UART.c ****         UART_EnableRxInt();
 593:.\Generated_Source\PSoC5/UART.c **** 
 594:.\Generated_Source\PSoC5/UART.c ****     #else
 595:.\Generated_Source\PSoC5/UART.c **** 
 596:.\Generated_Source\PSoC5/UART.c ****         rxStatus =UART_RXSTATUS_REG;
 597:.\Generated_Source\PSoC5/UART.c ****         if((rxStatus & UART_RX_STS_FIFO_NOTEMPTY) != 0u)
 598:.\Generated_Source\PSoC5/UART.c ****         {
 599:.\Generated_Source\PSoC5/UART.c ****             /* Read received data from FIFO */
 600:.\Generated_Source\PSoC5/UART.c ****             rxData = UART_RXDATA_REG;
 601:.\Generated_Source\PSoC5/UART.c **** 
 602:.\Generated_Source\PSoC5/UART.c ****             /*Check status on error*/
 603:.\Generated_Source\PSoC5/UART.c ****             if((rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
 604:.\Generated_Source\PSoC5/UART.c ****                             UART_RX_STS_STOP_ERROR | UART_RX_STS_OVERRUN)) != 0u)
 605:.\Generated_Source\PSoC5/UART.c ****             {
 606:.\Generated_Source\PSoC5/UART.c ****                 rxData = 0u;
 607:.\Generated_Source\PSoC5/UART.c ****             }
 608:.\Generated_Source\PSoC5/UART.c ****         }
 609:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 610:.\Generated_Source\PSoC5/UART.c **** 
 611:.\Generated_Source\PSoC5/UART.c ****         return(rxData);
 612:.\Generated_Source\PSoC5/UART.c ****     }
 613:.\Generated_Source\PSoC5/UART.c **** 
 614:.\Generated_Source\PSoC5/UART.c **** 
 615:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 616:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_GetByte
 617:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 618:.\Generated_Source\PSoC5/UART.c ****     *
 619:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 620:.\Generated_Source\PSoC5/UART.c ****     *  Reads UART RX buffer immediately, returns received character and error
 621:.\Generated_Source\PSoC5/UART.c ****     *  condition.
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 17


 622:.\Generated_Source\PSoC5/UART.c ****     *
 623:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 624:.\Generated_Source\PSoC5/UART.c ****     *  None.
 625:.\Generated_Source\PSoC5/UART.c ****     *
 626:.\Generated_Source\PSoC5/UART.c ****     * Return:
 627:.\Generated_Source\PSoC5/UART.c ****     *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628:.\Generated_Source\PSoC5/UART.c ****     *  an error has occurred.
 629:.\Generated_Source\PSoC5/UART.c ****     *
 630:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
 631:.\Generated_Source\PSoC5/UART.c ****     *  No.
 632:.\Generated_Source\PSoC5/UART.c ****     *
 633:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 634:.\Generated_Source\PSoC5/UART.c ****     uint16 UART_GetByte(void) 
 635:.\Generated_Source\PSoC5/UART.c ****     {
 636:.\Generated_Source\PSoC5/UART.c ****         
 637:.\Generated_Source\PSoC5/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 638:.\Generated_Source\PSoC5/UART.c ****         uint16 locErrorStatus;
 639:.\Generated_Source\PSoC5/UART.c ****         /* Protect variables that could change on interrupt */
 640:.\Generated_Source\PSoC5/UART.c ****         UART_DisableRxInt();
 641:.\Generated_Source\PSoC5/UART.c ****         locErrorStatus = (uint16)UART_errorStatus;
 642:.\Generated_Source\PSoC5/UART.c ****         UART_errorStatus = 0u;
 643:.\Generated_Source\PSoC5/UART.c ****         UART_EnableRxInt();
 644:.\Generated_Source\PSoC5/UART.c ****         return ( (uint16)(locErrorStatus << 8u) | UART_ReadRxData() );
 645:.\Generated_Source\PSoC5/UART.c ****     #else
 646:.\Generated_Source\PSoC5/UART.c ****         return ( ((uint16)UART_ReadRxStatus() << 8u) | UART_ReadRxData() );
 647:.\Generated_Source\PSoC5/UART.c ****     #endif /* UART_RX_INTERRUPT_ENABLED */
 648:.\Generated_Source\PSoC5/UART.c ****         
 649:.\Generated_Source\PSoC5/UART.c ****     }
 650:.\Generated_Source\PSoC5/UART.c **** 
 651:.\Generated_Source\PSoC5/UART.c **** 
 652:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 653:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_GetRxBufferSize
 654:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 655:.\Generated_Source\PSoC5/UART.c ****     *
 656:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 657:.\Generated_Source\PSoC5/UART.c ****     *  Returns the number of received bytes available in the RX buffer.
 658:.\Generated_Source\PSoC5/UART.c ****     *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659:.\Generated_Source\PSoC5/UART.c ****     *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660:.\Generated_Source\PSoC5/UART.c ****     *  * RX software buffer is enabled: returns the number of bytes available in 
 661:.\Generated_Source\PSoC5/UART.c ****     *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662:.\Generated_Source\PSoC5/UART.c ****     *    account.
 663:.\Generated_Source\PSoC5/UART.c ****     *
 664:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 665:.\Generated_Source\PSoC5/UART.c ****     *  None.
 666:.\Generated_Source\PSoC5/UART.c ****     *
 667:.\Generated_Source\PSoC5/UART.c ****     * Return:
 668:.\Generated_Source\PSoC5/UART.c ****     *  uint8: Number of bytes in the RX buffer. 
 669:.\Generated_Source\PSoC5/UART.c ****     *    Return value type depends on RX Buffer Size parameter.
 670:.\Generated_Source\PSoC5/UART.c ****     *
 671:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
 672:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferWrite - used to calculate left bytes.
 673:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferRead - used to calculate left bytes.
 674:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferLoopDetect - checked to decide left bytes amount.
 675:.\Generated_Source\PSoC5/UART.c ****     *
 676:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
 677:.\Generated_Source\PSoC5/UART.c ****     *  No.
 678:.\Generated_Source\PSoC5/UART.c ****     *
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 18


 679:.\Generated_Source\PSoC5/UART.c ****     * Theory:
 680:.\Generated_Source\PSoC5/UART.c ****     *  Allows the user to find out how full the RX Buffer is.
 681:.\Generated_Source\PSoC5/UART.c ****     *
 682:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 683:.\Generated_Source\PSoC5/UART.c ****     uint8 UART_GetRxBufferSize(void)
 684:.\Generated_Source\PSoC5/UART.c ****                                                             
 685:.\Generated_Source\PSoC5/UART.c ****     {
 686:.\Generated_Source\PSoC5/UART.c ****         uint8 size;
 687:.\Generated_Source\PSoC5/UART.c **** 
 688:.\Generated_Source\PSoC5/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 689:.\Generated_Source\PSoC5/UART.c **** 
 690:.\Generated_Source\PSoC5/UART.c ****         /* Protect variables that could change on interrupt */
 691:.\Generated_Source\PSoC5/UART.c ****         UART_DisableRxInt();
 692:.\Generated_Source\PSoC5/UART.c **** 
 693:.\Generated_Source\PSoC5/UART.c ****         if(UART_rxBufferRead == UART_rxBufferWrite)
 694:.\Generated_Source\PSoC5/UART.c ****         {
 695:.\Generated_Source\PSoC5/UART.c ****             if(UART_rxBufferLoopDetect != 0u)
 696:.\Generated_Source\PSoC5/UART.c ****             {
 697:.\Generated_Source\PSoC5/UART.c ****                 size = UART_RX_BUFFER_SIZE;
 698:.\Generated_Source\PSoC5/UART.c ****             }
 699:.\Generated_Source\PSoC5/UART.c ****             else
 700:.\Generated_Source\PSoC5/UART.c ****             {
 701:.\Generated_Source\PSoC5/UART.c ****                 size = 0u;
 702:.\Generated_Source\PSoC5/UART.c ****             }
 703:.\Generated_Source\PSoC5/UART.c ****         }
 704:.\Generated_Source\PSoC5/UART.c ****         else if(UART_rxBufferRead < UART_rxBufferWrite)
 705:.\Generated_Source\PSoC5/UART.c ****         {
 706:.\Generated_Source\PSoC5/UART.c ****             size = (UART_rxBufferWrite - UART_rxBufferRead);
 707:.\Generated_Source\PSoC5/UART.c ****         }
 708:.\Generated_Source\PSoC5/UART.c ****         else
 709:.\Generated_Source\PSoC5/UART.c ****         {
 710:.\Generated_Source\PSoC5/UART.c ****             size = (UART_RX_BUFFER_SIZE - UART_rxBufferRead) + UART_rxBufferWrite;
 711:.\Generated_Source\PSoC5/UART.c ****         }
 712:.\Generated_Source\PSoC5/UART.c **** 
 713:.\Generated_Source\PSoC5/UART.c ****         UART_EnableRxInt();
 714:.\Generated_Source\PSoC5/UART.c **** 
 715:.\Generated_Source\PSoC5/UART.c ****     #else
 716:.\Generated_Source\PSoC5/UART.c **** 
 717:.\Generated_Source\PSoC5/UART.c ****         /* We can only know if there is data in the fifo. */
 718:.\Generated_Source\PSoC5/UART.c ****         size = ((UART_RXSTATUS_REG & UART_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 719:.\Generated_Source\PSoC5/UART.c **** 
 720:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 721:.\Generated_Source\PSoC5/UART.c **** 
 722:.\Generated_Source\PSoC5/UART.c ****         return(size);
 723:.\Generated_Source\PSoC5/UART.c ****     }
 724:.\Generated_Source\PSoC5/UART.c **** 
 725:.\Generated_Source\PSoC5/UART.c **** 
 726:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 727:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_ClearRxBuffer
 728:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 729:.\Generated_Source\PSoC5/UART.c ****     *
 730:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 731:.\Generated_Source\PSoC5/UART.c ****     *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732:.\Generated_Source\PSoC5/UART.c ****     *
 733:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 734:.\Generated_Source\PSoC5/UART.c ****     *  None.
 735:.\Generated_Source\PSoC5/UART.c ****     *
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 19


 736:.\Generated_Source\PSoC5/UART.c ****     * Return:
 737:.\Generated_Source\PSoC5/UART.c ****     *  None.
 738:.\Generated_Source\PSoC5/UART.c ****     *
 739:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
 740:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferWrite - cleared to zero.
 741:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferRead - cleared to zero.
 742:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferLoopDetect - cleared to zero.
 743:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxBufferOverflow - cleared to zero.
 744:.\Generated_Source\PSoC5/UART.c ****     *
 745:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
 746:.\Generated_Source\PSoC5/UART.c ****     *  No.
 747:.\Generated_Source\PSoC5/UART.c ****     *
 748:.\Generated_Source\PSoC5/UART.c ****     * Theory:
 749:.\Generated_Source\PSoC5/UART.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 750:.\Generated_Source\PSoC5/UART.c ****     *  read and writing will resume at address 0 overwriting any data that may
 751:.\Generated_Source\PSoC5/UART.c ****     *  have remained in the RAM.
 752:.\Generated_Source\PSoC5/UART.c ****     *
 753:.\Generated_Source\PSoC5/UART.c ****     * Side Effects:
 754:.\Generated_Source\PSoC5/UART.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 755:.\Generated_Source\PSoC5/UART.c ****     *
 756:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 757:.\Generated_Source\PSoC5/UART.c ****     void UART_ClearRxBuffer(void) 
 758:.\Generated_Source\PSoC5/UART.c ****     {
 759:.\Generated_Source\PSoC5/UART.c ****         uint8 enableInterrupts;
 760:.\Generated_Source\PSoC5/UART.c **** 
 761:.\Generated_Source\PSoC5/UART.c ****         /* Clear the HW FIFO */
 762:.\Generated_Source\PSoC5/UART.c ****         enableInterrupts = CyEnterCriticalSection();
 763:.\Generated_Source\PSoC5/UART.c ****         UART_RXDATA_AUX_CTL_REG |= (uint8)  UART_RX_FIFO_CLR;
 764:.\Generated_Source\PSoC5/UART.c ****         UART_RXDATA_AUX_CTL_REG &= (uint8) ~UART_RX_FIFO_CLR;
 765:.\Generated_Source\PSoC5/UART.c ****         CyExitCriticalSection(enableInterrupts);
 766:.\Generated_Source\PSoC5/UART.c **** 
 767:.\Generated_Source\PSoC5/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 768:.\Generated_Source\PSoC5/UART.c **** 
 769:.\Generated_Source\PSoC5/UART.c ****         /* Protect variables that could change on interrupt. */
 770:.\Generated_Source\PSoC5/UART.c ****         UART_DisableRxInt();
 771:.\Generated_Source\PSoC5/UART.c **** 
 772:.\Generated_Source\PSoC5/UART.c ****         UART_rxBufferRead = 0u;
 773:.\Generated_Source\PSoC5/UART.c ****         UART_rxBufferWrite = 0u;
 774:.\Generated_Source\PSoC5/UART.c ****         UART_rxBufferLoopDetect = 0u;
 775:.\Generated_Source\PSoC5/UART.c ****         UART_rxBufferOverflow = 0u;
 776:.\Generated_Source\PSoC5/UART.c **** 
 777:.\Generated_Source\PSoC5/UART.c ****         UART_EnableRxInt();
 778:.\Generated_Source\PSoC5/UART.c **** 
 779:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 780:.\Generated_Source\PSoC5/UART.c **** 
 781:.\Generated_Source\PSoC5/UART.c ****     }
 782:.\Generated_Source\PSoC5/UART.c **** 
 783:.\Generated_Source\PSoC5/UART.c **** 
 784:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 785:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_SetRxAddressMode
 786:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 787:.\Generated_Source\PSoC5/UART.c ****     *
 788:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 789:.\Generated_Source\PSoC5/UART.c ****     *  Sets the software controlled Addressing mode used by the RX portion of the
 790:.\Generated_Source\PSoC5/UART.c ****     *  UART.
 791:.\Generated_Source\PSoC5/UART.c ****     *
 792:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 20


 793:.\Generated_Source\PSoC5/UART.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 794:.\Generated_Source\PSoC5/UART.c ****     *  UART__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795:.\Generated_Source\PSoC5/UART.c ****     *                                               detection
 796:.\Generated_Source\PSoC5/UART.c ****     *  UART__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 797:.\Generated_Source\PSoC5/UART.c ****     *                                               address detection
 798:.\Generated_Source\PSoC5/UART.c ****     *  UART__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799:.\Generated_Source\PSoC5/UART.c ****     *                                               detection
 800:.\Generated_Source\PSoC5/UART.c ****     *  UART__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801:.\Generated_Source\PSoC5/UART.c ****     *                                               address detection
 802:.\Generated_Source\PSoC5/UART.c ****     *  UART__B_UART__AM_NONE - No address detection
 803:.\Generated_Source\PSoC5/UART.c ****     *
 804:.\Generated_Source\PSoC5/UART.c ****     * Return:
 805:.\Generated_Source\PSoC5/UART.c ****     *  None.
 806:.\Generated_Source\PSoC5/UART.c ****     *
 807:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
 808:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxAddressMode - the parameter stored in this variable for
 809:.\Generated_Source\PSoC5/UART.c ****     *   the farther usage in RX ISR.
 810:.\Generated_Source\PSoC5/UART.c ****     *  UART_rxAddressDetected - set to initial state (0).
 811:.\Generated_Source\PSoC5/UART.c ****     *
 812:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 813:.\Generated_Source\PSoC5/UART.c ****     void UART_SetRxAddressMode(uint8 addressMode)
 814:.\Generated_Source\PSoC5/UART.c ****                                                         
 815:.\Generated_Source\PSoC5/UART.c ****     {
 816:.\Generated_Source\PSoC5/UART.c ****         #if(UART_RXHW_ADDRESS_ENABLED)
 817:.\Generated_Source\PSoC5/UART.c ****             #if(UART_CONTROL_REG_REMOVED)
 818:.\Generated_Source\PSoC5/UART.c ****                 if(0u != addressMode)
 819:.\Generated_Source\PSoC5/UART.c ****                 {
 820:.\Generated_Source\PSoC5/UART.c ****                     /* Suppress compiler warning */
 821:.\Generated_Source\PSoC5/UART.c ****                 }
 822:.\Generated_Source\PSoC5/UART.c ****             #else /* UART_CONTROL_REG_REMOVED */
 823:.\Generated_Source\PSoC5/UART.c ****                 uint8 tmpCtrl;
 824:.\Generated_Source\PSoC5/UART.c ****                 tmpCtrl = UART_CONTROL_REG & (uint8)~UART_CTRL_RXADDR_MODE_MASK;
 825:.\Generated_Source\PSoC5/UART.c ****                 tmpCtrl |= (uint8)(addressMode << UART_CTRL_RXADDR_MODE0_SHIFT);
 826:.\Generated_Source\PSoC5/UART.c ****                 UART_CONTROL_REG = tmpCtrl;
 827:.\Generated_Source\PSoC5/UART.c **** 
 828:.\Generated_Source\PSoC5/UART.c ****                 #if(UART_RX_INTERRUPT_ENABLED && \
 829:.\Generated_Source\PSoC5/UART.c ****                    (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
 830:.\Generated_Source\PSoC5/UART.c ****                     UART_rxAddressMode = addressMode;
 831:.\Generated_Source\PSoC5/UART.c ****                     UART_rxAddressDetected = 0u;
 832:.\Generated_Source\PSoC5/UART.c ****                 #endif /* End UART_RXBUFFERSIZE > UART_FIFO_LENGTH*/
 833:.\Generated_Source\PSoC5/UART.c ****             #endif /* End UART_CONTROL_REG_REMOVED */
 834:.\Generated_Source\PSoC5/UART.c ****         #else /* UART_RXHW_ADDRESS_ENABLED */
 835:.\Generated_Source\PSoC5/UART.c ****             if(0u != addressMode)
 836:.\Generated_Source\PSoC5/UART.c ****             {
 837:.\Generated_Source\PSoC5/UART.c ****                 /* Suppress compiler warning */
 838:.\Generated_Source\PSoC5/UART.c ****             }
 839:.\Generated_Source\PSoC5/UART.c ****         #endif /* End UART_RXHW_ADDRESS_ENABLED */
 840:.\Generated_Source\PSoC5/UART.c ****     }
 841:.\Generated_Source\PSoC5/UART.c **** 
 842:.\Generated_Source\PSoC5/UART.c **** 
 843:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 844:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_SetRxAddress1
 845:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 846:.\Generated_Source\PSoC5/UART.c ****     *
 847:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 848:.\Generated_Source\PSoC5/UART.c ****     *  Sets the first of two hardware-detectable receiver addresses.
 849:.\Generated_Source\PSoC5/UART.c ****     *
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 21


 850:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 851:.\Generated_Source\PSoC5/UART.c ****     *  address: Address #1 for hardware address detection.
 852:.\Generated_Source\PSoC5/UART.c ****     *
 853:.\Generated_Source\PSoC5/UART.c ****     * Return:
 854:.\Generated_Source\PSoC5/UART.c ****     *  None.
 855:.\Generated_Source\PSoC5/UART.c ****     *
 856:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 857:.\Generated_Source\PSoC5/UART.c ****     void UART_SetRxAddress1(uint8 address) 
 858:.\Generated_Source\PSoC5/UART.c ****     {
 859:.\Generated_Source\PSoC5/UART.c ****         UART_RXADDRESS1_REG = address;
 860:.\Generated_Source\PSoC5/UART.c ****     }
 861:.\Generated_Source\PSoC5/UART.c **** 
 862:.\Generated_Source\PSoC5/UART.c **** 
 863:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 864:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_SetRxAddress2
 865:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 866:.\Generated_Source\PSoC5/UART.c ****     *
 867:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 868:.\Generated_Source\PSoC5/UART.c ****     *  Sets the second of two hardware-detectable receiver addresses.
 869:.\Generated_Source\PSoC5/UART.c ****     *
 870:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 871:.\Generated_Source\PSoC5/UART.c ****     *  address: Address #2 for hardware address detection.
 872:.\Generated_Source\PSoC5/UART.c ****     *
 873:.\Generated_Source\PSoC5/UART.c ****     * Return:
 874:.\Generated_Source\PSoC5/UART.c ****     *  None.
 875:.\Generated_Source\PSoC5/UART.c ****     *
 876:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 877:.\Generated_Source\PSoC5/UART.c ****     void UART_SetRxAddress2(uint8 address) 
 878:.\Generated_Source\PSoC5/UART.c ****     {
 879:.\Generated_Source\PSoC5/UART.c ****         UART_RXADDRESS2_REG = address;
 880:.\Generated_Source\PSoC5/UART.c ****     }
 881:.\Generated_Source\PSoC5/UART.c **** 
 882:.\Generated_Source\PSoC5/UART.c **** #endif  /* UART_RX_ENABLED || UART_HD_ENABLED*/
 883:.\Generated_Source\PSoC5/UART.c **** 
 884:.\Generated_Source\PSoC5/UART.c **** 
 885:.\Generated_Source\PSoC5/UART.c **** #if( (UART_TX_ENABLED) || (UART_HD_ENABLED) )
 886:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 887:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_SetTxInterruptMode
 888:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 889:.\Generated_Source\PSoC5/UART.c ****     *
 890:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 891:.\Generated_Source\PSoC5/UART.c ****     *  Configures the TX interrupt sources to be enabled, but does not enable the
 892:.\Generated_Source\PSoC5/UART.c ****     *  interrupt.
 893:.\Generated_Source\PSoC5/UART.c ****     *
 894:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 895:.\Generated_Source\PSoC5/UART.c ****     *  intSrc: Bit field containing the TX interrupt sources to enable
 896:.\Generated_Source\PSoC5/UART.c ****     *   UART_TX_STS_COMPLETE        Interrupt on TX byte complete
 897:.\Generated_Source\PSoC5/UART.c ****     *   UART_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898:.\Generated_Source\PSoC5/UART.c ****     *   UART_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899:.\Generated_Source\PSoC5/UART.c ****     *   UART_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900:.\Generated_Source\PSoC5/UART.c ****     *
 901:.\Generated_Source\PSoC5/UART.c ****     * Return:
 902:.\Generated_Source\PSoC5/UART.c ****     *  None.
 903:.\Generated_Source\PSoC5/UART.c ****     *
 904:.\Generated_Source\PSoC5/UART.c ****     * Theory:
 905:.\Generated_Source\PSoC5/UART.c ****     *  Enables the output of specific status bits to the interrupt controller
 906:.\Generated_Source\PSoC5/UART.c ****     *
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 22


 907:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 908:.\Generated_Source\PSoC5/UART.c ****     void UART_SetTxInterruptMode(uint8 intSrc) 
 909:.\Generated_Source\PSoC5/UART.c ****     {
 292              		.loc 1 909 0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 8
 295              		@ frame_needed = 1, uses_anonymous_args = 0
 296              		@ link register save eliminated.
 297 0000 80B4     		push	{r7}
 298              		.cfi_def_cfa_offset 4
 299              		.cfi_offset 7, -4
 300 0002 83B0     		sub	sp, sp, #12
 301              		.cfi_def_cfa_offset 16
 302 0004 00AF     		add	r7, sp, #0
 303              		.cfi_def_cfa_register 7
 304 0006 0346     		mov	r3, r0
 305 0008 FB71     		strb	r3, [r7, #7]
 910:.\Generated_Source\PSoC5/UART.c ****         UART_TXSTATUS_MASK_REG = intSrc;
 306              		.loc 1 910 0
 307 000a 044A     		ldr	r2, .L18
 308 000c FB79     		ldrb	r3, [r7, #7]
 309 000e 1370     		strb	r3, [r2]
 911:.\Generated_Source\PSoC5/UART.c ****     }
 310              		.loc 1 911 0
 311 0010 0C37     		adds	r7, r7, #12
 312              		.cfi_def_cfa_offset 4
 313 0012 BD46     		mov	sp, r7
 314              		.cfi_def_cfa_register 13
 315              		@ sp needed
 316 0014 5DF8047B 		ldr	r7, [sp], #4
 317              		.cfi_restore 7
 318              		.cfi_def_cfa_offset 0
 319 0018 7047     		bx	lr
 320              	.L19:
 321 001a 00BF     		.align	2
 322              	.L18:
 323 001c 8B650040 		.word	1073767819
 324              		.cfi_endproc
 325              	.LFE6:
 326              		.size	UART_SetTxInterruptMode, .-UART_SetTxInterruptMode
 327              		.section	.text.UART_WriteTxData,"ax",%progbits
 328              		.align	2
 329              		.global	UART_WriteTxData
 330              		.thumb
 331              		.thumb_func
 332              		.type	UART_WriteTxData, %function
 333              	UART_WriteTxData:
 334              	.LFB7:
 912:.\Generated_Source\PSoC5/UART.c **** 
 913:.\Generated_Source\PSoC5/UART.c **** 
 914:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 915:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_WriteTxData
 916:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 917:.\Generated_Source\PSoC5/UART.c ****     *
 918:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 919:.\Generated_Source\PSoC5/UART.c ****     *  Places a byte of data into the transmit buffer to be sent when the bus is
 920:.\Generated_Source\PSoC5/UART.c ****     *  available without checking the TX status register. You must check status
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 23


 921:.\Generated_Source\PSoC5/UART.c ****     *  separately.
 922:.\Generated_Source\PSoC5/UART.c ****     *
 923:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 924:.\Generated_Source\PSoC5/UART.c ****     *  txDataByte: data byte
 925:.\Generated_Source\PSoC5/UART.c ****     *
 926:.\Generated_Source\PSoC5/UART.c ****     * Return:
 927:.\Generated_Source\PSoC5/UART.c ****     * None.
 928:.\Generated_Source\PSoC5/UART.c ****     *
 929:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
 930:.\Generated_Source\PSoC5/UART.c ****     *  UART_txBuffer - RAM buffer pointer for save data for transmission
 931:.\Generated_Source\PSoC5/UART.c ****     *  UART_txBufferWrite - cyclic index for write to txBuffer,
 932:.\Generated_Source\PSoC5/UART.c ****     *    incremented after each byte saved to buffer.
 933:.\Generated_Source\PSoC5/UART.c ****     *  UART_txBufferRead - cyclic index for read from txBuffer,
 934:.\Generated_Source\PSoC5/UART.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 935:.\Generated_Source\PSoC5/UART.c ****     *  UART_initVar - checked to identify that the component has been
 936:.\Generated_Source\PSoC5/UART.c ****     *    initialized.
 937:.\Generated_Source\PSoC5/UART.c ****     *
 938:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
 939:.\Generated_Source\PSoC5/UART.c ****     *  No.
 940:.\Generated_Source\PSoC5/UART.c ****     *
 941:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
 942:.\Generated_Source\PSoC5/UART.c ****     void UART_WriteTxData(uint8 txDataByte) 
 943:.\Generated_Source\PSoC5/UART.c ****     {
 335              		.loc 1 943 0
 336              		.cfi_startproc
 337              		@ args = 0, pretend = 0, frame = 8
 338              		@ frame_needed = 1, uses_anonymous_args = 0
 339              		@ link register save eliminated.
 340 0000 80B4     		push	{r7}
 341              		.cfi_def_cfa_offset 4
 342              		.cfi_offset 7, -4
 343 0002 83B0     		sub	sp, sp, #12
 344              		.cfi_def_cfa_offset 16
 345 0004 00AF     		add	r7, sp, #0
 346              		.cfi_def_cfa_register 7
 347 0006 0346     		mov	r3, r0
 348 0008 FB71     		strb	r3, [r7, #7]
 944:.\Generated_Source\PSoC5/UART.c ****         /* If not Initialized then skip this function*/
 945:.\Generated_Source\PSoC5/UART.c ****         if(UART_initVar != 0u)
 349              		.loc 1 945 0
 350 000a 064B     		ldr	r3, .L22
 351 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 352 000e 002B     		cmp	r3, #0
 353 0010 02D0     		beq	.L20
 946:.\Generated_Source\PSoC5/UART.c ****         {
 947:.\Generated_Source\PSoC5/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 948:.\Generated_Source\PSoC5/UART.c **** 
 949:.\Generated_Source\PSoC5/UART.c ****             /* Protect variables that could change on interrupt. */
 950:.\Generated_Source\PSoC5/UART.c ****             UART_DisableTxInt();
 951:.\Generated_Source\PSoC5/UART.c **** 
 952:.\Generated_Source\PSoC5/UART.c ****             if( (UART_txBufferRead == UART_txBufferWrite) &&
 953:.\Generated_Source\PSoC5/UART.c ****                 ((UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) == 0u) )
 954:.\Generated_Source\PSoC5/UART.c ****             {
 955:.\Generated_Source\PSoC5/UART.c ****                 /* Add directly to the FIFO. */
 956:.\Generated_Source\PSoC5/UART.c ****                 UART_TXDATA_REG = txDataByte;
 957:.\Generated_Source\PSoC5/UART.c ****             }
 958:.\Generated_Source\PSoC5/UART.c ****             else
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 24


 959:.\Generated_Source\PSoC5/UART.c ****             {
 960:.\Generated_Source\PSoC5/UART.c ****                 if(UART_txBufferWrite >= UART_TX_BUFFER_SIZE)
 961:.\Generated_Source\PSoC5/UART.c ****                 {
 962:.\Generated_Source\PSoC5/UART.c ****                     UART_txBufferWrite = 0u;
 963:.\Generated_Source\PSoC5/UART.c ****                 }
 964:.\Generated_Source\PSoC5/UART.c **** 
 965:.\Generated_Source\PSoC5/UART.c ****                 UART_txBuffer[UART_txBufferWrite] = txDataByte;
 966:.\Generated_Source\PSoC5/UART.c **** 
 967:.\Generated_Source\PSoC5/UART.c ****                 /* Add to the software buffer. */
 968:.\Generated_Source\PSoC5/UART.c ****                 UART_txBufferWrite++;
 969:.\Generated_Source\PSoC5/UART.c ****             }
 970:.\Generated_Source\PSoC5/UART.c **** 
 971:.\Generated_Source\PSoC5/UART.c ****             UART_EnableTxInt();
 972:.\Generated_Source\PSoC5/UART.c **** 
 973:.\Generated_Source\PSoC5/UART.c ****         #else
 974:.\Generated_Source\PSoC5/UART.c **** 
 975:.\Generated_Source\PSoC5/UART.c ****             /* Add directly to the FIFO. */
 976:.\Generated_Source\PSoC5/UART.c ****             UART_TXDATA_REG = txDataByte;
 354              		.loc 1 976 0
 355 0012 054A     		ldr	r2, .L22+4
 356 0014 FB79     		ldrb	r3, [r7, #7]
 357 0016 1370     		strb	r3, [r2]
 358              	.L20:
 977:.\Generated_Source\PSoC5/UART.c **** 
 978:.\Generated_Source\PSoC5/UART.c ****         #endif /*(UART_TX_INTERRUPT_ENABLED) */
 979:.\Generated_Source\PSoC5/UART.c ****         }
 980:.\Generated_Source\PSoC5/UART.c ****     }
 359              		.loc 1 980 0
 360 0018 0C37     		adds	r7, r7, #12
 361              		.cfi_def_cfa_offset 4
 362 001a BD46     		mov	sp, r7
 363              		.cfi_def_cfa_register 13
 364              		@ sp needed
 365 001c 5DF8047B 		ldr	r7, [sp], #4
 366              		.cfi_restore 7
 367              		.cfi_def_cfa_offset 0
 368 0020 7047     		bx	lr
 369              	.L23:
 370 0022 00BF     		.align	2
 371              	.L22:
 372 0024 00000000 		.word	UART_initVar
 373 0028 4B650040 		.word	1073767755
 374              		.cfi_endproc
 375              	.LFE7:
 376              		.size	UART_WriteTxData, .-UART_WriteTxData
 377              		.section	.text.UART_ReadTxStatus,"ax",%progbits
 378              		.align	2
 379              		.global	UART_ReadTxStatus
 380              		.thumb
 381              		.thumb_func
 382              		.type	UART_ReadTxStatus, %function
 383              	UART_ReadTxStatus:
 384              	.LFB8:
 981:.\Generated_Source\PSoC5/UART.c **** 
 982:.\Generated_Source\PSoC5/UART.c **** 
 983:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
 984:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_ReadTxStatus
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 25


 985:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
 986:.\Generated_Source\PSoC5/UART.c ****     *
 987:.\Generated_Source\PSoC5/UART.c ****     * Summary:
 988:.\Generated_Source\PSoC5/UART.c ****     *  Reads the status register for the TX portion of the UART.
 989:.\Generated_Source\PSoC5/UART.c ****     *
 990:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
 991:.\Generated_Source\PSoC5/UART.c ****     *  None.
 992:.\Generated_Source\PSoC5/UART.c ****     *
 993:.\Generated_Source\PSoC5/UART.c ****     * Return:
 994:.\Generated_Source\PSoC5/UART.c ****     *  Contents of the status register
 995:.\Generated_Source\PSoC5/UART.c ****     *
 996:.\Generated_Source\PSoC5/UART.c ****     * Theory:
 997:.\Generated_Source\PSoC5/UART.c ****     *  This function reads the TX status register, which is cleared on read.
 998:.\Generated_Source\PSoC5/UART.c ****     *  It is up to the user to handle all bits in this return value accordingly,
 999:.\Generated_Source\PSoC5/UART.c ****     *  even if the bit was not enabled as an interrupt source the event happened
1000:.\Generated_Source\PSoC5/UART.c ****     *  and must be handled accordingly.
1001:.\Generated_Source\PSoC5/UART.c ****     *
1002:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
1003:.\Generated_Source\PSoC5/UART.c ****     uint8 UART_ReadTxStatus(void) 
1004:.\Generated_Source\PSoC5/UART.c ****     {
 385              		.loc 1 1004 0
 386              		.cfi_startproc
 387              		@ args = 0, pretend = 0, frame = 0
 388              		@ frame_needed = 1, uses_anonymous_args = 0
 389              		@ link register save eliminated.
 390 0000 80B4     		push	{r7}
 391              		.cfi_def_cfa_offset 4
 392              		.cfi_offset 7, -4
 393 0002 00AF     		add	r7, sp, #0
 394              		.cfi_def_cfa_register 7
1005:.\Generated_Source\PSoC5/UART.c ****         return(UART_TXSTATUS_REG);
 395              		.loc 1 1005 0
 396 0004 034B     		ldr	r3, .L26
 397 0006 1B78     		ldrb	r3, [r3]
 398 0008 DBB2     		uxtb	r3, r3
1006:.\Generated_Source\PSoC5/UART.c ****     }
 399              		.loc 1 1006 0
 400 000a 1846     		mov	r0, r3
 401 000c BD46     		mov	sp, r7
 402              		.cfi_def_cfa_register 13
 403              		@ sp needed
 404 000e 5DF8047B 		ldr	r7, [sp], #4
 405              		.cfi_restore 7
 406              		.cfi_def_cfa_offset 0
 407 0012 7047     		bx	lr
 408              	.L27:
 409              		.align	2
 410              	.L26:
 411 0014 6B650040 		.word	1073767787
 412              		.cfi_endproc
 413              	.LFE8:
 414              		.size	UART_ReadTxStatus, .-UART_ReadTxStatus
 415              		.section	.text.UART_PutChar,"ax",%progbits
 416              		.align	2
 417              		.global	UART_PutChar
 418              		.thumb
 419              		.thumb_func
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 26


 420              		.type	UART_PutChar, %function
 421              	UART_PutChar:
 422              	.LFB9:
1007:.\Generated_Source\PSoC5/UART.c **** 
1008:.\Generated_Source\PSoC5/UART.c **** 
1009:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
1010:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_PutChar
1011:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
1012:.\Generated_Source\PSoC5/UART.c ****     *
1013:.\Generated_Source\PSoC5/UART.c ****     * Summary:
1014:.\Generated_Source\PSoC5/UART.c ****     *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015:.\Generated_Source\PSoC5/UART.c ****     *  available. This is a blocking API that waits until the TX buffer has room to
1016:.\Generated_Source\PSoC5/UART.c ****     *  hold the data.
1017:.\Generated_Source\PSoC5/UART.c ****     *
1018:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
1019:.\Generated_Source\PSoC5/UART.c ****     *  txDataByte: Byte containing the data to transmit
1020:.\Generated_Source\PSoC5/UART.c ****     *
1021:.\Generated_Source\PSoC5/UART.c ****     * Return:
1022:.\Generated_Source\PSoC5/UART.c ****     *  None.
1023:.\Generated_Source\PSoC5/UART.c ****     *
1024:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
1025:.\Generated_Source\PSoC5/UART.c ****     *  UART_txBuffer - RAM buffer pointer for save data for transmission
1026:.\Generated_Source\PSoC5/UART.c ****     *  UART_txBufferWrite - cyclic index for write to txBuffer,
1027:.\Generated_Source\PSoC5/UART.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1028:.\Generated_Source\PSoC5/UART.c ****     *     saved to buffer.
1029:.\Generated_Source\PSoC5/UART.c ****     *  UART_txBufferRead - cyclic index for read from txBuffer,
1030:.\Generated_Source\PSoC5/UART.c ****     *     checked to identify free space in txBuffer.
1031:.\Generated_Source\PSoC5/UART.c ****     *  UART_initVar - checked to identify that the component has been
1032:.\Generated_Source\PSoC5/UART.c ****     *     initialized.
1033:.\Generated_Source\PSoC5/UART.c ****     *
1034:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
1035:.\Generated_Source\PSoC5/UART.c ****     *  No.
1036:.\Generated_Source\PSoC5/UART.c ****     *
1037:.\Generated_Source\PSoC5/UART.c ****     * Theory:
1038:.\Generated_Source\PSoC5/UART.c ****     *  Allows the user to transmit any byte of data in a single transfer
1039:.\Generated_Source\PSoC5/UART.c ****     *
1040:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
1041:.\Generated_Source\PSoC5/UART.c ****     void UART_PutChar(uint8 txDataByte) 
1042:.\Generated_Source\PSoC5/UART.c ****     {
 423              		.loc 1 1042 0
 424              		.cfi_startproc
 425              		@ args = 0, pretend = 0, frame = 8
 426              		@ frame_needed = 1, uses_anonymous_args = 0
 427              		@ link register save eliminated.
 428 0000 80B4     		push	{r7}
 429              		.cfi_def_cfa_offset 4
 430              		.cfi_offset 7, -4
 431 0002 83B0     		sub	sp, sp, #12
 432              		.cfi_def_cfa_offset 16
 433 0004 00AF     		add	r7, sp, #0
 434              		.cfi_def_cfa_register 7
 435 0006 0346     		mov	r3, r0
 436 0008 FB71     		strb	r3, [r7, #7]
1043:.\Generated_Source\PSoC5/UART.c ****     #if (UART_TX_INTERRUPT_ENABLED)
1044:.\Generated_Source\PSoC5/UART.c ****         /* The temporary output pointer is used since it takes two instructions
1045:.\Generated_Source\PSoC5/UART.c ****         *  to increment with a wrap, and we can't risk doing that with the real
1046:.\Generated_Source\PSoC5/UART.c ****         *  pointer and getting an interrupt in between instructions.
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 27


1047:.\Generated_Source\PSoC5/UART.c ****         */
1048:.\Generated_Source\PSoC5/UART.c ****         uint8 locTxBufferWrite;
1049:.\Generated_Source\PSoC5/UART.c ****         uint8 locTxBufferRead;
1050:.\Generated_Source\PSoC5/UART.c **** 
1051:.\Generated_Source\PSoC5/UART.c ****         do
1052:.\Generated_Source\PSoC5/UART.c ****         { /* Block if software buffer is full, so we don't overwrite. */
1053:.\Generated_Source\PSoC5/UART.c **** 
1054:.\Generated_Source\PSoC5/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1055:.\Generated_Source\PSoC5/UART.c ****             /* Disable TX interrupt to protect variables from modification */
1056:.\Generated_Source\PSoC5/UART.c ****             UART_DisableTxInt();
1057:.\Generated_Source\PSoC5/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1058:.\Generated_Source\PSoC5/UART.c **** 
1059:.\Generated_Source\PSoC5/UART.c ****             locTxBufferWrite = UART_txBufferWrite;
1060:.\Generated_Source\PSoC5/UART.c ****             locTxBufferRead  = UART_txBufferRead;
1061:.\Generated_Source\PSoC5/UART.c **** 
1062:.\Generated_Source\PSoC5/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1063:.\Generated_Source\PSoC5/UART.c ****             /* Enable interrupt to continue transmission */
1064:.\Generated_Source\PSoC5/UART.c ****             UART_EnableTxInt();
1065:.\Generated_Source\PSoC5/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1066:.\Generated_Source\PSoC5/UART.c ****         }
1067:.\Generated_Source\PSoC5/UART.c ****         while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) 
1068:.\Generated_Source\PSoC5/UART.c ****                                 ((locTxBufferWrite - locTxBufferRead) ==
1069:.\Generated_Source\PSoC5/UART.c ****                                 (uint8)(UART_TX_BUFFER_SIZE - 1u)) );
1070:.\Generated_Source\PSoC5/UART.c **** 
1071:.\Generated_Source\PSoC5/UART.c ****         if( (locTxBufferRead == locTxBufferWrite) &&
1072:.\Generated_Source\PSoC5/UART.c ****             ((UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) == 0u) )
1073:.\Generated_Source\PSoC5/UART.c ****         {
1074:.\Generated_Source\PSoC5/UART.c ****             /* Add directly to the FIFO */
1075:.\Generated_Source\PSoC5/UART.c ****             UART_TXDATA_REG = txDataByte;
1076:.\Generated_Source\PSoC5/UART.c ****         }
1077:.\Generated_Source\PSoC5/UART.c ****         else
1078:.\Generated_Source\PSoC5/UART.c ****         {
1079:.\Generated_Source\PSoC5/UART.c ****             if(locTxBufferWrite >= UART_TX_BUFFER_SIZE)
1080:.\Generated_Source\PSoC5/UART.c ****             {
1081:.\Generated_Source\PSoC5/UART.c ****                 locTxBufferWrite = 0u;
1082:.\Generated_Source\PSoC5/UART.c ****             }
1083:.\Generated_Source\PSoC5/UART.c ****             /* Add to the software buffer. */
1084:.\Generated_Source\PSoC5/UART.c ****             UART_txBuffer[locTxBufferWrite] = txDataByte;
1085:.\Generated_Source\PSoC5/UART.c ****             locTxBufferWrite++;
1086:.\Generated_Source\PSoC5/UART.c **** 
1087:.\Generated_Source\PSoC5/UART.c ****             /* Finally, update the real output pointer */
1088:.\Generated_Source\PSoC5/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1089:.\Generated_Source\PSoC5/UART.c ****             UART_DisableTxInt();
1090:.\Generated_Source\PSoC5/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1091:.\Generated_Source\PSoC5/UART.c **** 
1092:.\Generated_Source\PSoC5/UART.c ****             UART_txBufferWrite = locTxBufferWrite;
1093:.\Generated_Source\PSoC5/UART.c **** 
1094:.\Generated_Source\PSoC5/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1095:.\Generated_Source\PSoC5/UART.c ****             UART_EnableTxInt();
1096:.\Generated_Source\PSoC5/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1097:.\Generated_Source\PSoC5/UART.c **** 
1098:.\Generated_Source\PSoC5/UART.c ****             if(0u != (UART_TXSTATUS_REG & UART_TX_STS_FIFO_EMPTY))
1099:.\Generated_Source\PSoC5/UART.c ****             {
1100:.\Generated_Source\PSoC5/UART.c ****                 /* Trigger TX interrupt to send software buffer */
1101:.\Generated_Source\PSoC5/UART.c ****                 UART_SetPendingTxInt();
1102:.\Generated_Source\PSoC5/UART.c ****             }
1103:.\Generated_Source\PSoC5/UART.c ****         }
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 28


1104:.\Generated_Source\PSoC5/UART.c **** 
1105:.\Generated_Source\PSoC5/UART.c ****     #else
1106:.\Generated_Source\PSoC5/UART.c **** 
1107:.\Generated_Source\PSoC5/UART.c ****         while((UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) != 0u)
 437              		.loc 1 1107 0
 438 000a 00BF     		nop
 439              	.L29:
 440              		.loc 1 1107 0 is_stmt 0 discriminator 1
 441 000c 074B     		ldr	r3, .L30
 442 000e 1B78     		ldrb	r3, [r3]
 443 0010 DBB2     		uxtb	r3, r3
 444 0012 03F00403 		and	r3, r3, #4
 445 0016 002B     		cmp	r3, #0
 446 0018 F8D1     		bne	.L29
1108:.\Generated_Source\PSoC5/UART.c ****         {
1109:.\Generated_Source\PSoC5/UART.c ****             /* Wait for room in the FIFO */
1110:.\Generated_Source\PSoC5/UART.c ****         }
1111:.\Generated_Source\PSoC5/UART.c **** 
1112:.\Generated_Source\PSoC5/UART.c ****         /* Add directly to the FIFO */
1113:.\Generated_Source\PSoC5/UART.c ****         UART_TXDATA_REG = txDataByte;
 447              		.loc 1 1113 0 is_stmt 1
 448 001a 054A     		ldr	r2, .L30+4
 449 001c FB79     		ldrb	r3, [r7, #7]
 450 001e 1370     		strb	r3, [r2]
1114:.\Generated_Source\PSoC5/UART.c **** 
1115:.\Generated_Source\PSoC5/UART.c ****     #endif /* UART_TX_INTERRUPT_ENABLED */
1116:.\Generated_Source\PSoC5/UART.c ****     }
 451              		.loc 1 1116 0
 452 0020 0C37     		adds	r7, r7, #12
 453              		.cfi_def_cfa_offset 4
 454 0022 BD46     		mov	sp, r7
 455              		.cfi_def_cfa_register 13
 456              		@ sp needed
 457 0024 5DF8047B 		ldr	r7, [sp], #4
 458              		.cfi_restore 7
 459              		.cfi_def_cfa_offset 0
 460 0028 7047     		bx	lr
 461              	.L31:
 462 002a 00BF     		.align	2
 463              	.L30:
 464 002c 6B650040 		.word	1073767787
 465 0030 4B650040 		.word	1073767755
 466              		.cfi_endproc
 467              	.LFE9:
 468              		.size	UART_PutChar, .-UART_PutChar
 469              		.section	.text.UART_PutString,"ax",%progbits
 470              		.align	2
 471              		.global	UART_PutString
 472              		.thumb
 473              		.thumb_func
 474              		.type	UART_PutString, %function
 475              	UART_PutString:
 476              	.LFB10:
1117:.\Generated_Source\PSoC5/UART.c **** 
1118:.\Generated_Source\PSoC5/UART.c **** 
1119:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
1120:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_PutString
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 29


1121:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
1122:.\Generated_Source\PSoC5/UART.c ****     *
1123:.\Generated_Source\PSoC5/UART.c ****     * Summary:
1124:.\Generated_Source\PSoC5/UART.c ****     *  Sends a NULL terminated string to the TX buffer for transmission.
1125:.\Generated_Source\PSoC5/UART.c ****     *
1126:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
1127:.\Generated_Source\PSoC5/UART.c ****     *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128:.\Generated_Source\PSoC5/UART.c ****     *
1129:.\Generated_Source\PSoC5/UART.c ****     * Return:
1130:.\Generated_Source\PSoC5/UART.c ****     *  None.
1131:.\Generated_Source\PSoC5/UART.c ****     *
1132:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
1133:.\Generated_Source\PSoC5/UART.c ****     *  UART_initVar - checked to identify that the component has been
1134:.\Generated_Source\PSoC5/UART.c ****     *     initialized.
1135:.\Generated_Source\PSoC5/UART.c ****     *
1136:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
1137:.\Generated_Source\PSoC5/UART.c ****     *  No.
1138:.\Generated_Source\PSoC5/UART.c ****     *
1139:.\Generated_Source\PSoC5/UART.c ****     * Theory:
1140:.\Generated_Source\PSoC5/UART.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1141:.\Generated_Source\PSoC5/UART.c ****     *  function blocks until the last character of the string is loaded into the
1142:.\Generated_Source\PSoC5/UART.c ****     *  TX buffer.
1143:.\Generated_Source\PSoC5/UART.c ****     *
1144:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
1145:.\Generated_Source\PSoC5/UART.c ****     void UART_PutString(const char8 string[]) 
1146:.\Generated_Source\PSoC5/UART.c ****     {
 477              		.loc 1 1146 0
 478              		.cfi_startproc
 479              		@ args = 0, pretend = 0, frame = 16
 480              		@ frame_needed = 1, uses_anonymous_args = 0
 481 0000 80B5     		push	{r7, lr}
 482              		.cfi_def_cfa_offset 8
 483              		.cfi_offset 7, -8
 484              		.cfi_offset 14, -4
 485 0002 84B0     		sub	sp, sp, #16
 486              		.cfi_def_cfa_offset 24
 487 0004 00AF     		add	r7, sp, #0
 488              		.cfi_def_cfa_register 7
 489 0006 7860     		str	r0, [r7, #4]
1147:.\Generated_Source\PSoC5/UART.c ****         uint16 bufIndex = 0u;
 490              		.loc 1 1147 0
 491 0008 0023     		movs	r3, #0
 492 000a FB81     		strh	r3, [r7, #14]	@ movhi
1148:.\Generated_Source\PSoC5/UART.c **** 
1149:.\Generated_Source\PSoC5/UART.c ****         /* If not Initialized then skip this function */
1150:.\Generated_Source\PSoC5/UART.c ****         if(UART_initVar != 0u)
 493              		.loc 1 1150 0
 494 000c 0B4B     		ldr	r3, .L36
 495 000e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 496 0010 002B     		cmp	r3, #0
 497 0012 10D0     		beq	.L32
1151:.\Generated_Source\PSoC5/UART.c ****         {
1152:.\Generated_Source\PSoC5/UART.c ****             /* This is a blocking function, it will not exit until all data is sent */
1153:.\Generated_Source\PSoC5/UART.c ****             while(string[bufIndex] != (char8) 0)
 498              		.loc 1 1153 0
 499 0014 09E0     		b	.L34
 500              	.L35:
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 30


1154:.\Generated_Source\PSoC5/UART.c ****             {
1155:.\Generated_Source\PSoC5/UART.c ****                 UART_PutChar((uint8)string[bufIndex]);
 501              		.loc 1 1155 0
 502 0016 FB89     		ldrh	r3, [r7, #14]
 503 0018 7A68     		ldr	r2, [r7, #4]
 504 001a 1344     		add	r3, r3, r2
 505 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 506 001e 1846     		mov	r0, r3
 507 0020 FFF7FEFF 		bl	UART_PutChar
1156:.\Generated_Source\PSoC5/UART.c ****                 bufIndex++;
 508              		.loc 1 1156 0
 509 0024 FB89     		ldrh	r3, [r7, #14]
 510 0026 0133     		adds	r3, r3, #1
 511 0028 FB81     		strh	r3, [r7, #14]	@ movhi
 512              	.L34:
1153:.\Generated_Source\PSoC5/UART.c ****             {
 513              		.loc 1 1153 0
 514 002a FB89     		ldrh	r3, [r7, #14]
 515 002c 7A68     		ldr	r2, [r7, #4]
 516 002e 1344     		add	r3, r3, r2
 517 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 518 0032 002B     		cmp	r3, #0
 519 0034 EFD1     		bne	.L35
 520              	.L32:
1157:.\Generated_Source\PSoC5/UART.c ****             }
1158:.\Generated_Source\PSoC5/UART.c ****         }
1159:.\Generated_Source\PSoC5/UART.c ****     }
 521              		.loc 1 1159 0
 522 0036 1037     		adds	r7, r7, #16
 523              		.cfi_def_cfa_offset 8
 524 0038 BD46     		mov	sp, r7
 525              		.cfi_def_cfa_register 13
 526              		@ sp needed
 527 003a 80BD     		pop	{r7, pc}
 528              	.L37:
 529              		.align	2
 530              	.L36:
 531 003c 00000000 		.word	UART_initVar
 532              		.cfi_endproc
 533              	.LFE10:
 534              		.size	UART_PutString, .-UART_PutString
 535              		.section	.text.UART_PutArray,"ax",%progbits
 536              		.align	2
 537              		.global	UART_PutArray
 538              		.thumb
 539              		.thumb_func
 540              		.type	UART_PutArray, %function
 541              	UART_PutArray:
 542              	.LFB11:
1160:.\Generated_Source\PSoC5/UART.c **** 
1161:.\Generated_Source\PSoC5/UART.c **** 
1162:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
1163:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_PutArray
1164:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
1165:.\Generated_Source\PSoC5/UART.c ****     *
1166:.\Generated_Source\PSoC5/UART.c ****     * Summary:
1167:.\Generated_Source\PSoC5/UART.c ****     *  Places N bytes of data from a memory array into the TX buffer for
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 31


1168:.\Generated_Source\PSoC5/UART.c ****     *  transmission.
1169:.\Generated_Source\PSoC5/UART.c ****     *
1170:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
1171:.\Generated_Source\PSoC5/UART.c ****     *  string[]: Address of the memory array residing in RAM or ROM.
1172:.\Generated_Source\PSoC5/UART.c ****     *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173:.\Generated_Source\PSoC5/UART.c ****     *             Size parameter.
1174:.\Generated_Source\PSoC5/UART.c ****     *
1175:.\Generated_Source\PSoC5/UART.c ****     * Return:
1176:.\Generated_Source\PSoC5/UART.c ****     *  None.
1177:.\Generated_Source\PSoC5/UART.c ****     *
1178:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
1179:.\Generated_Source\PSoC5/UART.c ****     *  UART_initVar - checked to identify that the component has been
1180:.\Generated_Source\PSoC5/UART.c ****     *     initialized.
1181:.\Generated_Source\PSoC5/UART.c ****     *
1182:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
1183:.\Generated_Source\PSoC5/UART.c ****     *  No.
1184:.\Generated_Source\PSoC5/UART.c ****     *
1185:.\Generated_Source\PSoC5/UART.c ****     * Theory:
1186:.\Generated_Source\PSoC5/UART.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1187:.\Generated_Source\PSoC5/UART.c ****     *  function blocks until the last character of the string is loaded into the
1188:.\Generated_Source\PSoC5/UART.c ****     *  TX buffer.
1189:.\Generated_Source\PSoC5/UART.c ****     *
1190:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
1191:.\Generated_Source\PSoC5/UART.c ****     void UART_PutArray(const uint8 string[], uint8 byteCount)
1192:.\Generated_Source\PSoC5/UART.c ****                                                                     
1193:.\Generated_Source\PSoC5/UART.c ****     {
 543              		.loc 1 1193 0
 544              		.cfi_startproc
 545              		@ args = 0, pretend = 0, frame = 16
 546              		@ frame_needed = 1, uses_anonymous_args = 0
 547 0000 80B5     		push	{r7, lr}
 548              		.cfi_def_cfa_offset 8
 549              		.cfi_offset 7, -8
 550              		.cfi_offset 14, -4
 551 0002 84B0     		sub	sp, sp, #16
 552              		.cfi_def_cfa_offset 24
 553 0004 00AF     		add	r7, sp, #0
 554              		.cfi_def_cfa_register 7
 555 0006 7860     		str	r0, [r7, #4]
 556 0008 0B46     		mov	r3, r1
 557 000a FB70     		strb	r3, [r7, #3]
1194:.\Generated_Source\PSoC5/UART.c ****         uint8 bufIndex = 0u;
 558              		.loc 1 1194 0
 559 000c 0023     		movs	r3, #0
 560 000e FB73     		strb	r3, [r7, #15]
1195:.\Generated_Source\PSoC5/UART.c **** 
1196:.\Generated_Source\PSoC5/UART.c ****         /* If not Initialized then skip this function */
1197:.\Generated_Source\PSoC5/UART.c ****         if(UART_initVar != 0u)
 561              		.loc 1 1197 0
 562 0010 0A4B     		ldr	r3, .L42
 563 0012 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 564 0014 002B     		cmp	r3, #0
 565 0016 0ED0     		beq	.L38
1198:.\Generated_Source\PSoC5/UART.c ****         {
1199:.\Generated_Source\PSoC5/UART.c ****             while(bufIndex < byteCount)
 566              		.loc 1 1199 0
 567 0018 09E0     		b	.L40
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 32


 568              	.L41:
1200:.\Generated_Source\PSoC5/UART.c ****             {
1201:.\Generated_Source\PSoC5/UART.c ****                 UART_PutChar(string[bufIndex]);
 569              		.loc 1 1201 0
 570 001a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 571 001c 7A68     		ldr	r2, [r7, #4]
 572 001e 1344     		add	r3, r3, r2
 573 0020 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 574 0022 1846     		mov	r0, r3
 575 0024 FFF7FEFF 		bl	UART_PutChar
1202:.\Generated_Source\PSoC5/UART.c ****                 bufIndex++;
 576              		.loc 1 1202 0
 577 0028 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 578 002a 0133     		adds	r3, r3, #1
 579 002c FB73     		strb	r3, [r7, #15]
 580              	.L40:
1199:.\Generated_Source\PSoC5/UART.c ****             {
 581              		.loc 1 1199 0
 582 002e FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 583 0030 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 584 0032 9A42     		cmp	r2, r3
 585 0034 F1D3     		bcc	.L41
 586              	.L38:
1203:.\Generated_Source\PSoC5/UART.c ****             }
1204:.\Generated_Source\PSoC5/UART.c ****         }
1205:.\Generated_Source\PSoC5/UART.c ****     }
 587              		.loc 1 1205 0
 588 0036 1037     		adds	r7, r7, #16
 589              		.cfi_def_cfa_offset 8
 590 0038 BD46     		mov	sp, r7
 591              		.cfi_def_cfa_register 13
 592              		@ sp needed
 593 003a 80BD     		pop	{r7, pc}
 594              	.L43:
 595              		.align	2
 596              	.L42:
 597 003c 00000000 		.word	UART_initVar
 598              		.cfi_endproc
 599              	.LFE11:
 600              		.size	UART_PutArray, .-UART_PutArray
 601              		.section	.text.UART_PutCRLF,"ax",%progbits
 602              		.align	2
 603              		.global	UART_PutCRLF
 604              		.thumb
 605              		.thumb_func
 606              		.type	UART_PutCRLF, %function
 607              	UART_PutCRLF:
 608              	.LFB12:
1206:.\Generated_Source\PSoC5/UART.c **** 
1207:.\Generated_Source\PSoC5/UART.c **** 
1208:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
1209:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_PutCRLF
1210:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
1211:.\Generated_Source\PSoC5/UART.c ****     *
1212:.\Generated_Source\PSoC5/UART.c ****     * Summary:
1213:.\Generated_Source\PSoC5/UART.c ****     *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214:.\Generated_Source\PSoC5/UART.c ****     *  (0x0A) to the transmit buffer.
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 33


1215:.\Generated_Source\PSoC5/UART.c ****     *
1216:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
1217:.\Generated_Source\PSoC5/UART.c ****     *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218:.\Generated_Source\PSoC5/UART.c ****     *
1219:.\Generated_Source\PSoC5/UART.c ****     * Return:
1220:.\Generated_Source\PSoC5/UART.c ****     *  None.
1221:.\Generated_Source\PSoC5/UART.c ****     *
1222:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
1223:.\Generated_Source\PSoC5/UART.c ****     *  UART_initVar - checked to identify that the component has been
1224:.\Generated_Source\PSoC5/UART.c ****     *     initialized.
1225:.\Generated_Source\PSoC5/UART.c ****     *
1226:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
1227:.\Generated_Source\PSoC5/UART.c ****     *  No.
1228:.\Generated_Source\PSoC5/UART.c ****     *
1229:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
1230:.\Generated_Source\PSoC5/UART.c ****     void UART_PutCRLF(uint8 txDataByte) 
1231:.\Generated_Source\PSoC5/UART.c ****     {
 609              		.loc 1 1231 0
 610              		.cfi_startproc
 611              		@ args = 0, pretend = 0, frame = 8
 612              		@ frame_needed = 1, uses_anonymous_args = 0
 613 0000 80B5     		push	{r7, lr}
 614              		.cfi_def_cfa_offset 8
 615              		.cfi_offset 7, -8
 616              		.cfi_offset 14, -4
 617 0002 82B0     		sub	sp, sp, #8
 618              		.cfi_def_cfa_offset 16
 619 0004 00AF     		add	r7, sp, #0
 620              		.cfi_def_cfa_register 7
 621 0006 0346     		mov	r3, r0
 622 0008 FB71     		strb	r3, [r7, #7]
1232:.\Generated_Source\PSoC5/UART.c ****         /* If not Initialized then skip this function */
1233:.\Generated_Source\PSoC5/UART.c ****         if(UART_initVar != 0u)
 623              		.loc 1 1233 0
 624 000a 084B     		ldr	r3, .L46
 625 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 626 000e 002B     		cmp	r3, #0
 627 0010 09D0     		beq	.L44
1234:.\Generated_Source\PSoC5/UART.c ****         {
1235:.\Generated_Source\PSoC5/UART.c ****             UART_PutChar(txDataByte);
 628              		.loc 1 1235 0
 629 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 630 0014 1846     		mov	r0, r3
 631 0016 FFF7FEFF 		bl	UART_PutChar
1236:.\Generated_Source\PSoC5/UART.c ****             UART_PutChar(0x0Du);
 632              		.loc 1 1236 0
 633 001a 0D20     		movs	r0, #13
 634 001c FFF7FEFF 		bl	UART_PutChar
1237:.\Generated_Source\PSoC5/UART.c ****             UART_PutChar(0x0Au);
 635              		.loc 1 1237 0
 636 0020 0A20     		movs	r0, #10
 637 0022 FFF7FEFF 		bl	UART_PutChar
 638              	.L44:
1238:.\Generated_Source\PSoC5/UART.c ****         }
1239:.\Generated_Source\PSoC5/UART.c ****     }
 639              		.loc 1 1239 0
 640 0026 0837     		adds	r7, r7, #8
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 34


 641              		.cfi_def_cfa_offset 8
 642 0028 BD46     		mov	sp, r7
 643              		.cfi_def_cfa_register 13
 644              		@ sp needed
 645 002a 80BD     		pop	{r7, pc}
 646              	.L47:
 647              		.align	2
 648              	.L46:
 649 002c 00000000 		.word	UART_initVar
 650              		.cfi_endproc
 651              	.LFE12:
 652              		.size	UART_PutCRLF, .-UART_PutCRLF
 653              		.section	.text.UART_GetTxBufferSize,"ax",%progbits
 654              		.align	2
 655              		.global	UART_GetTxBufferSize
 656              		.thumb
 657              		.thumb_func
 658              		.type	UART_GetTxBufferSize, %function
 659              	UART_GetTxBufferSize:
 660              	.LFB13:
1240:.\Generated_Source\PSoC5/UART.c **** 
1241:.\Generated_Source\PSoC5/UART.c **** 
1242:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
1243:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_GetTxBufferSize
1244:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
1245:.\Generated_Source\PSoC5/UART.c ****     *
1246:.\Generated_Source\PSoC5/UART.c ****     * Summary:
1247:.\Generated_Source\PSoC5/UART.c ****     *  Returns the number of bytes in the TX buffer which are waiting to be 
1248:.\Generated_Source\PSoC5/UART.c ****     *  transmitted.
1249:.\Generated_Source\PSoC5/UART.c ****     *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250:.\Generated_Source\PSoC5/UART.c ****     *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251:.\Generated_Source\PSoC5/UART.c ****     *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252:.\Generated_Source\PSoC5/UART.c ****     *    software buffer which are waiting to be transmitted. Bytes available in the
1253:.\Generated_Source\PSoC5/UART.c ****     *    TX FIFO do not count.
1254:.\Generated_Source\PSoC5/UART.c ****     *
1255:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
1256:.\Generated_Source\PSoC5/UART.c ****     *  None.
1257:.\Generated_Source\PSoC5/UART.c ****     *
1258:.\Generated_Source\PSoC5/UART.c ****     * Return:
1259:.\Generated_Source\PSoC5/UART.c ****     *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260:.\Generated_Source\PSoC5/UART.c ****     *  Buffer Size parameter.
1261:.\Generated_Source\PSoC5/UART.c ****     *
1262:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
1263:.\Generated_Source\PSoC5/UART.c ****     *  UART_txBufferWrite - used to calculate left space.
1264:.\Generated_Source\PSoC5/UART.c ****     *  UART_txBufferRead - used to calculate left space.
1265:.\Generated_Source\PSoC5/UART.c ****     *
1266:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
1267:.\Generated_Source\PSoC5/UART.c ****     *  No.
1268:.\Generated_Source\PSoC5/UART.c ****     *
1269:.\Generated_Source\PSoC5/UART.c ****     * Theory:
1270:.\Generated_Source\PSoC5/UART.c ****     *  Allows the user to find out how full the TX Buffer is.
1271:.\Generated_Source\PSoC5/UART.c ****     *
1272:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC5/UART.c ****     uint8 UART_GetTxBufferSize(void)
1274:.\Generated_Source\PSoC5/UART.c ****                                                             
1275:.\Generated_Source\PSoC5/UART.c ****     {
 661              		.loc 1 1275 0
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 35


 662              		.cfi_startproc
 663              		@ args = 0, pretend = 0, frame = 8
 664              		@ frame_needed = 1, uses_anonymous_args = 0
 665              		@ link register save eliminated.
 666 0000 80B4     		push	{r7}
 667              		.cfi_def_cfa_offset 4
 668              		.cfi_offset 7, -4
 669 0002 83B0     		sub	sp, sp, #12
 670              		.cfi_def_cfa_offset 16
 671 0004 00AF     		add	r7, sp, #0
 672              		.cfi_def_cfa_register 7
1276:.\Generated_Source\PSoC5/UART.c ****         uint8 size;
1277:.\Generated_Source\PSoC5/UART.c **** 
1278:.\Generated_Source\PSoC5/UART.c ****     #if (UART_TX_INTERRUPT_ENABLED)
1279:.\Generated_Source\PSoC5/UART.c **** 
1280:.\Generated_Source\PSoC5/UART.c ****         /* Protect variables that could change on interrupt. */
1281:.\Generated_Source\PSoC5/UART.c ****         UART_DisableTxInt();
1282:.\Generated_Source\PSoC5/UART.c **** 
1283:.\Generated_Source\PSoC5/UART.c ****         if(UART_txBufferRead == UART_txBufferWrite)
1284:.\Generated_Source\PSoC5/UART.c ****         {
1285:.\Generated_Source\PSoC5/UART.c ****             size = 0u;
1286:.\Generated_Source\PSoC5/UART.c ****         }
1287:.\Generated_Source\PSoC5/UART.c ****         else if(UART_txBufferRead < UART_txBufferWrite)
1288:.\Generated_Source\PSoC5/UART.c ****         {
1289:.\Generated_Source\PSoC5/UART.c ****             size = (UART_txBufferWrite - UART_txBufferRead);
1290:.\Generated_Source\PSoC5/UART.c ****         }
1291:.\Generated_Source\PSoC5/UART.c ****         else
1292:.\Generated_Source\PSoC5/UART.c ****         {
1293:.\Generated_Source\PSoC5/UART.c ****             size = (UART_TX_BUFFER_SIZE - UART_txBufferRead) +
1294:.\Generated_Source\PSoC5/UART.c ****                     UART_txBufferWrite;
1295:.\Generated_Source\PSoC5/UART.c ****         }
1296:.\Generated_Source\PSoC5/UART.c **** 
1297:.\Generated_Source\PSoC5/UART.c ****         UART_EnableTxInt();
1298:.\Generated_Source\PSoC5/UART.c **** 
1299:.\Generated_Source\PSoC5/UART.c ****     #else
1300:.\Generated_Source\PSoC5/UART.c **** 
1301:.\Generated_Source\PSoC5/UART.c ****         size = UART_TXSTATUS_REG;
 673              		.loc 1 1301 0
 674 0006 0E4B     		ldr	r3, .L53
 675 0008 1B78     		ldrb	r3, [r3]
 676 000a FB71     		strb	r3, [r7, #7]
1302:.\Generated_Source\PSoC5/UART.c **** 
1303:.\Generated_Source\PSoC5/UART.c ****         /* Is the fifo is full. */
1304:.\Generated_Source\PSoC5/UART.c ****         if((size & UART_TX_STS_FIFO_FULL) != 0u)
 677              		.loc 1 1304 0
 678 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 679 000e 03F00403 		and	r3, r3, #4
 680 0012 002B     		cmp	r3, #0
 681 0014 02D0     		beq	.L49
1305:.\Generated_Source\PSoC5/UART.c ****         {
1306:.\Generated_Source\PSoC5/UART.c ****             size = UART_FIFO_LENGTH;
 682              		.loc 1 1306 0
 683 0016 0423     		movs	r3, #4
 684 0018 FB71     		strb	r3, [r7, #7]
 685 001a 09E0     		b	.L50
 686              	.L49:
1307:.\Generated_Source\PSoC5/UART.c ****         }
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 36


1308:.\Generated_Source\PSoC5/UART.c ****         else if((size & UART_TX_STS_FIFO_EMPTY) != 0u)
 687              		.loc 1 1308 0
 688 001c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 689 001e 03F00203 		and	r3, r3, #2
 690 0022 002B     		cmp	r3, #0
 691 0024 02D0     		beq	.L51
1309:.\Generated_Source\PSoC5/UART.c ****         {
1310:.\Generated_Source\PSoC5/UART.c ****             size = 0u;
 692              		.loc 1 1310 0
 693 0026 0023     		movs	r3, #0
 694 0028 FB71     		strb	r3, [r7, #7]
 695 002a 01E0     		b	.L50
 696              	.L51:
1311:.\Generated_Source\PSoC5/UART.c ****         }
1312:.\Generated_Source\PSoC5/UART.c ****         else
1313:.\Generated_Source\PSoC5/UART.c ****         {
1314:.\Generated_Source\PSoC5/UART.c ****             /* We only know there is data in the fifo. */
1315:.\Generated_Source\PSoC5/UART.c ****             size = 1u;
 697              		.loc 1 1315 0
 698 002c 0123     		movs	r3, #1
 699 002e FB71     		strb	r3, [r7, #7]
 700              	.L50:
1316:.\Generated_Source\PSoC5/UART.c ****         }
1317:.\Generated_Source\PSoC5/UART.c **** 
1318:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_TX_INTERRUPT_ENABLED) */
1319:.\Generated_Source\PSoC5/UART.c **** 
1320:.\Generated_Source\PSoC5/UART.c ****     return(size);
 701              		.loc 1 1320 0
 702 0030 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
1321:.\Generated_Source\PSoC5/UART.c ****     }
 703              		.loc 1 1321 0
 704 0032 1846     		mov	r0, r3
 705 0034 0C37     		adds	r7, r7, #12
 706              		.cfi_def_cfa_offset 4
 707 0036 BD46     		mov	sp, r7
 708              		.cfi_def_cfa_register 13
 709              		@ sp needed
 710 0038 5DF8047B 		ldr	r7, [sp], #4
 711              		.cfi_restore 7
 712              		.cfi_def_cfa_offset 0
 713 003c 7047     		bx	lr
 714              	.L54:
 715 003e 00BF     		.align	2
 716              	.L53:
 717 0040 6B650040 		.word	1073767787
 718              		.cfi_endproc
 719              	.LFE13:
 720              		.size	UART_GetTxBufferSize, .-UART_GetTxBufferSize
 721              		.section	.text.UART_ClearTxBuffer,"ax",%progbits
 722              		.align	2
 723              		.global	UART_ClearTxBuffer
 724              		.thumb
 725              		.thumb_func
 726              		.type	UART_ClearTxBuffer, %function
 727              	UART_ClearTxBuffer:
 728              	.LFB14:
1322:.\Generated_Source\PSoC5/UART.c **** 
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 37


1323:.\Generated_Source\PSoC5/UART.c **** 
1324:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
1325:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_ClearTxBuffer
1326:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
1327:.\Generated_Source\PSoC5/UART.c ****     *
1328:.\Generated_Source\PSoC5/UART.c ****     * Summary:
1329:.\Generated_Source\PSoC5/UART.c ****     *  Clears all data from the TX buffer and hardware TX FIFO.
1330:.\Generated_Source\PSoC5/UART.c ****     *
1331:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
1332:.\Generated_Source\PSoC5/UART.c ****     *  None.
1333:.\Generated_Source\PSoC5/UART.c ****     *
1334:.\Generated_Source\PSoC5/UART.c ****     * Return:
1335:.\Generated_Source\PSoC5/UART.c ****     *  None.
1336:.\Generated_Source\PSoC5/UART.c ****     *
1337:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
1338:.\Generated_Source\PSoC5/UART.c ****     *  UART_txBufferWrite - cleared to zero.
1339:.\Generated_Source\PSoC5/UART.c ****     *  UART_txBufferRead - cleared to zero.
1340:.\Generated_Source\PSoC5/UART.c ****     *
1341:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
1342:.\Generated_Source\PSoC5/UART.c ****     *  No.
1343:.\Generated_Source\PSoC5/UART.c ****     *
1344:.\Generated_Source\PSoC5/UART.c ****     * Theory:
1345:.\Generated_Source\PSoC5/UART.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1346:.\Generated_Source\PSoC5/UART.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1347:.\Generated_Source\PSoC5/UART.c ****     *  remained in the RAM.
1348:.\Generated_Source\PSoC5/UART.c ****     *
1349:.\Generated_Source\PSoC5/UART.c ****     * Side Effects:
1350:.\Generated_Source\PSoC5/UART.c ****     *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351:.\Generated_Source\PSoC5/UART.c ****     *  transmitting finishes transmitting.
1352:.\Generated_Source\PSoC5/UART.c ****     *
1353:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
1354:.\Generated_Source\PSoC5/UART.c ****     void UART_ClearTxBuffer(void) 
1355:.\Generated_Source\PSoC5/UART.c ****     {
 729              		.loc 1 1355 0
 730              		.cfi_startproc
 731              		@ args = 0, pretend = 0, frame = 8
 732              		@ frame_needed = 1, uses_anonymous_args = 0
 733 0000 80B5     		push	{r7, lr}
 734              		.cfi_def_cfa_offset 8
 735              		.cfi_offset 7, -8
 736              		.cfi_offset 14, -4
 737 0002 82B0     		sub	sp, sp, #8
 738              		.cfi_def_cfa_offset 16
 739 0004 00AF     		add	r7, sp, #0
 740              		.cfi_def_cfa_register 7
1356:.\Generated_Source\PSoC5/UART.c ****         uint8 enableInterrupts;
1357:.\Generated_Source\PSoC5/UART.c **** 
1358:.\Generated_Source\PSoC5/UART.c ****         enableInterrupts = CyEnterCriticalSection();
 741              		.loc 1 1358 0
 742 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 743 000a 0346     		mov	r3, r0
 744 000c FB71     		strb	r3, [r7, #7]
1359:.\Generated_Source\PSoC5/UART.c ****         /* Clear the HW FIFO */
1360:.\Generated_Source\PSoC5/UART.c ****         UART_TXDATA_AUX_CTL_REG |= (uint8)  UART_TX_FIFO_CLR;
 745              		.loc 1 1360 0
 746 000e 0B4A     		ldr	r2, .L56
 747 0010 0A4B     		ldr	r3, .L56
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 38


 748 0012 1B78     		ldrb	r3, [r3]
 749 0014 DBB2     		uxtb	r3, r3
 750 0016 43F00103 		orr	r3, r3, #1
 751 001a DBB2     		uxtb	r3, r3
 752 001c 1370     		strb	r3, [r2]
1361:.\Generated_Source\PSoC5/UART.c ****         UART_TXDATA_AUX_CTL_REG &= (uint8) ~UART_TX_FIFO_CLR;
 753              		.loc 1 1361 0
 754 001e 074A     		ldr	r2, .L56
 755 0020 064B     		ldr	r3, .L56
 756 0022 1B78     		ldrb	r3, [r3]
 757 0024 DBB2     		uxtb	r3, r3
 758 0026 23F00103 		bic	r3, r3, #1
 759 002a DBB2     		uxtb	r3, r3
 760 002c 1370     		strb	r3, [r2]
1362:.\Generated_Source\PSoC5/UART.c ****         CyExitCriticalSection(enableInterrupts);
 761              		.loc 1 1362 0
 762 002e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 763 0030 1846     		mov	r0, r3
 764 0032 FFF7FEFF 		bl	CyExitCriticalSection
1363:.\Generated_Source\PSoC5/UART.c **** 
1364:.\Generated_Source\PSoC5/UART.c ****     #if (UART_TX_INTERRUPT_ENABLED)
1365:.\Generated_Source\PSoC5/UART.c **** 
1366:.\Generated_Source\PSoC5/UART.c ****         /* Protect variables that could change on interrupt. */
1367:.\Generated_Source\PSoC5/UART.c ****         UART_DisableTxInt();
1368:.\Generated_Source\PSoC5/UART.c **** 
1369:.\Generated_Source\PSoC5/UART.c ****         UART_txBufferRead = 0u;
1370:.\Generated_Source\PSoC5/UART.c ****         UART_txBufferWrite = 0u;
1371:.\Generated_Source\PSoC5/UART.c **** 
1372:.\Generated_Source\PSoC5/UART.c ****         /* Enable Tx interrupt. */
1373:.\Generated_Source\PSoC5/UART.c ****         UART_EnableTxInt();
1374:.\Generated_Source\PSoC5/UART.c **** 
1375:.\Generated_Source\PSoC5/UART.c ****     #endif /* (UART_TX_INTERRUPT_ENABLED) */
1376:.\Generated_Source\PSoC5/UART.c ****     }
 765              		.loc 1 1376 0
 766 0036 0837     		adds	r7, r7, #8
 767              		.cfi_def_cfa_offset 8
 768 0038 BD46     		mov	sp, r7
 769              		.cfi_def_cfa_register 13
 770              		@ sp needed
 771 003a 80BD     		pop	{r7, pc}
 772              	.L57:
 773              		.align	2
 774              	.L56:
 775 003c 9B650040 		.word	1073767835
 776              		.cfi_endproc
 777              	.LFE14:
 778              		.size	UART_ClearTxBuffer, .-UART_ClearTxBuffer
 779              		.section	.text.UART_SendBreak,"ax",%progbits
 780              		.align	2
 781              		.global	UART_SendBreak
 782              		.thumb
 783              		.thumb_func
 784              		.type	UART_SendBreak, %function
 785              	UART_SendBreak:
 786              	.LFB15:
1377:.\Generated_Source\PSoC5/UART.c **** 
1378:.\Generated_Source\PSoC5/UART.c **** 
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 39


1379:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
1380:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_SendBreak
1381:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
1382:.\Generated_Source\PSoC5/UART.c ****     *
1383:.\Generated_Source\PSoC5/UART.c ****     * Summary:
1384:.\Generated_Source\PSoC5/UART.c ****     *  Transmits a break signal on the bus.
1385:.\Generated_Source\PSoC5/UART.c ****     *
1386:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
1387:.\Generated_Source\PSoC5/UART.c ****     *  uint8 retMode:  Send Break return mode. See the following table for options.
1388:.\Generated_Source\PSoC5/UART.c ****     *   UART_SEND_BREAK - Initialize registers for break, send the Break
1389:.\Generated_Source\PSoC5/UART.c ****     *       signal and return immediately.
1390:.\Generated_Source\PSoC5/UART.c ****     *   UART_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391:.\Generated_Source\PSoC5/UART.c ****     *       complete, reinitialize registers to normal transmission mode then return
1392:.\Generated_Source\PSoC5/UART.c ****     *   UART_REINIT - Reinitialize registers to normal transmission mode
1393:.\Generated_Source\PSoC5/UART.c ****     *       then return.
1394:.\Generated_Source\PSoC5/UART.c ****     *   UART_SEND_WAIT_REINIT - Performs both options: 
1395:.\Generated_Source\PSoC5/UART.c ****     *      UART_SEND_BREAK and UART_WAIT_FOR_COMPLETE_REINIT.
1396:.\Generated_Source\PSoC5/UART.c ****     *      This option is recommended for most cases.
1397:.\Generated_Source\PSoC5/UART.c ****     *
1398:.\Generated_Source\PSoC5/UART.c ****     * Return:
1399:.\Generated_Source\PSoC5/UART.c ****     *  None.
1400:.\Generated_Source\PSoC5/UART.c ****     *
1401:.\Generated_Source\PSoC5/UART.c ****     * Global Variables:
1402:.\Generated_Source\PSoC5/UART.c ****     *  UART_initVar - checked to identify that the component has been
1403:.\Generated_Source\PSoC5/UART.c ****     *     initialized.
1404:.\Generated_Source\PSoC5/UART.c ****     *  txPeriod - static variable, used for keeping TX period configuration.
1405:.\Generated_Source\PSoC5/UART.c ****     *
1406:.\Generated_Source\PSoC5/UART.c ****     * Reentrant:
1407:.\Generated_Source\PSoC5/UART.c ****     *  No.
1408:.\Generated_Source\PSoC5/UART.c ****     *
1409:.\Generated_Source\PSoC5/UART.c ****     * Theory:
1410:.\Generated_Source\PSoC5/UART.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1411:.\Generated_Source\PSoC5/UART.c ****     *  important to return the registers configuration to normal for continue 8-bit
1412:.\Generated_Source\PSoC5/UART.c ****     *  operation.
1413:.\Generated_Source\PSoC5/UART.c ****     *  There are 3 variants for this API usage:
1414:.\Generated_Source\PSoC5/UART.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1415:.\Generated_Source\PSoC5/UART.c ****     *     configuration returning. Function will block CPU until transmission
1416:.\Generated_Source\PSoC5/UART.c ****     *     complete.
1417:.\Generated_Source\PSoC5/UART.c ****     *  2) User may want to use blocking time if UART configured to the low speed
1418:.\Generated_Source\PSoC5/UART.c ****     *     operation
1419:.\Generated_Source\PSoC5/UART.c ****     *     Example for this case:
1420:.\Generated_Source\PSoC5/UART.c ****     *     SendBreak(0);     - initialize Break signal transmission
1421:.\Generated_Source\PSoC5/UART.c ****     *         Add your code here to use CPU time
1422:.\Generated_Source\PSoC5/UART.c ****     *     SendBreak(1);     - complete Break operation
1423:.\Generated_Source\PSoC5/UART.c ****     *  3) Same to 2) but user may want to initialize and use the interrupt to
1424:.\Generated_Source\PSoC5/UART.c ****     *     complete break operation.
1425:.\Generated_Source\PSoC5/UART.c ****     *     Example for this case:
1426:.\Generated_Source\PSoC5/UART.c ****     *     Initialize TX interrupt with "TX - On TX Complete" parameter
1427:.\Generated_Source\PSoC5/UART.c ****     *     SendBreak(0);     - initialize Break signal transmission
1428:.\Generated_Source\PSoC5/UART.c ****     *         Add your code here to use CPU time
1429:.\Generated_Source\PSoC5/UART.c ****     *     When interrupt appear with UART_TX_STS_COMPLETE status:
1430:.\Generated_Source\PSoC5/UART.c ****     *     SendBreak(2);     - complete Break operation
1431:.\Generated_Source\PSoC5/UART.c ****     *
1432:.\Generated_Source\PSoC5/UART.c ****     * Side Effects:
1433:.\Generated_Source\PSoC5/UART.c ****     *  The UART_SendBreak() function initializes registers to send a
1434:.\Generated_Source\PSoC5/UART.c ****     *  break signal.
1435:.\Generated_Source\PSoC5/UART.c ****     *  Break signal length depends on the break signal bits configuration.
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 40


1436:.\Generated_Source\PSoC5/UART.c ****     *  The register configuration should be reinitialized before normal 8-bit
1437:.\Generated_Source\PSoC5/UART.c ****     *  communication can continue.
1438:.\Generated_Source\PSoC5/UART.c ****     *
1439:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
1440:.\Generated_Source\PSoC5/UART.c ****     void UART_SendBreak(uint8 retMode) 
1441:.\Generated_Source\PSoC5/UART.c ****     {
 787              		.loc 1 1441 0
 788              		.cfi_startproc
 789              		@ args = 0, pretend = 0, frame = 16
 790              		@ frame_needed = 1, uses_anonymous_args = 0
 791              		@ link register save eliminated.
 792 0000 80B4     		push	{r7}
 793              		.cfi_def_cfa_offset 4
 794              		.cfi_offset 7, -4
 795 0002 85B0     		sub	sp, sp, #20
 796              		.cfi_def_cfa_offset 24
 797 0004 00AF     		add	r7, sp, #0
 798              		.cfi_def_cfa_register 7
 799 0006 0346     		mov	r3, r0
 800 0008 FB71     		strb	r3, [r7, #7]
1442:.\Generated_Source\PSoC5/UART.c **** 
1443:.\Generated_Source\PSoC5/UART.c ****         /* If not Initialized then skip this function*/
1444:.\Generated_Source\PSoC5/UART.c ****         if(UART_initVar != 0u)
 801              		.loc 1 1444 0
 802 000a 1F4B     		ldr	r3, .L66
 803 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 804 000e 002B     		cmp	r3, #0
 805 0010 35D0     		beq	.L58
 806              	.LBB2:
1445:.\Generated_Source\PSoC5/UART.c ****         {
1446:.\Generated_Source\PSoC5/UART.c ****             /* Set the Counter to 13-bits and transmit a 00 byte */
1447:.\Generated_Source\PSoC5/UART.c ****             /* When that is done then reset the counter value back */
1448:.\Generated_Source\PSoC5/UART.c ****             uint8 tmpStat;
1449:.\Generated_Source\PSoC5/UART.c **** 
1450:.\Generated_Source\PSoC5/UART.c ****         #if(UART_HD_ENABLED) /* Half Duplex mode*/
1451:.\Generated_Source\PSoC5/UART.c **** 
1452:.\Generated_Source\PSoC5/UART.c ****             if( (retMode == UART_SEND_BREAK) ||
1453:.\Generated_Source\PSoC5/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT ) )
1454:.\Generated_Source\PSoC5/UART.c ****             {
1455:.\Generated_Source\PSoC5/UART.c ****                 /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
1456:.\Generated_Source\PSoC5/UART.c ****                 UART_WriteControlRegister(UART_ReadControlRegister() |
1457:.\Generated_Source\PSoC5/UART.c ****                                                       UART_CTRL_HD_SEND_BREAK);
1458:.\Generated_Source\PSoC5/UART.c ****                 /* Send zeros */
1459:.\Generated_Source\PSoC5/UART.c ****                 UART_TXDATA_REG = 0u;
1460:.\Generated_Source\PSoC5/UART.c **** 
1461:.\Generated_Source\PSoC5/UART.c ****                 do /* Wait until transmit starts */
1462:.\Generated_Source\PSoC5/UART.c ****                 {
1463:.\Generated_Source\PSoC5/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
1464:.\Generated_Source\PSoC5/UART.c ****                 }
1465:.\Generated_Source\PSoC5/UART.c ****                 while((tmpStat & UART_TX_STS_FIFO_EMPTY) != 0u);
1466:.\Generated_Source\PSoC5/UART.c ****             }
1467:.\Generated_Source\PSoC5/UART.c **** 
1468:.\Generated_Source\PSoC5/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
1469:.\Generated_Source\PSoC5/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1470:.\Generated_Source\PSoC5/UART.c ****             {
1471:.\Generated_Source\PSoC5/UART.c ****                 do /* Wait until transmit complete */
1472:.\Generated_Source\PSoC5/UART.c ****                 {
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 41


1473:.\Generated_Source\PSoC5/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
1474:.\Generated_Source\PSoC5/UART.c ****                 }
1475:.\Generated_Source\PSoC5/UART.c ****                 while(((uint8)~tmpStat & UART_TX_STS_COMPLETE) != 0u);
1476:.\Generated_Source\PSoC5/UART.c ****             }
1477:.\Generated_Source\PSoC5/UART.c **** 
1478:.\Generated_Source\PSoC5/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
1479:.\Generated_Source\PSoC5/UART.c ****                 (retMode == UART_REINIT) ||
1480:.\Generated_Source\PSoC5/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1481:.\Generated_Source\PSoC5/UART.c ****             {
1482:.\Generated_Source\PSoC5/UART.c ****                 UART_WriteControlRegister(UART_ReadControlRegister() &
1483:.\Generated_Source\PSoC5/UART.c ****                                               (uint8)~UART_CTRL_HD_SEND_BREAK);
1484:.\Generated_Source\PSoC5/UART.c ****             }
1485:.\Generated_Source\PSoC5/UART.c **** 
1486:.\Generated_Source\PSoC5/UART.c ****         #else /* UART_HD_ENABLED Full Duplex mode */
1487:.\Generated_Source\PSoC5/UART.c **** 
1488:.\Generated_Source\PSoC5/UART.c ****             static uint8 txPeriod;
1489:.\Generated_Source\PSoC5/UART.c **** 
1490:.\Generated_Source\PSoC5/UART.c ****             if( (retMode == UART_SEND_BREAK) ||
 807              		.loc 1 1490 0
 808 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 809 0014 002B     		cmp	r3, #0
 810 0016 02D0     		beq	.L60
 811              		.loc 1 1490 0 is_stmt 0 discriminator 1
 812 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 813 001a 032B     		cmp	r3, #3
 814 001c 12D1     		bne	.L61
 815              	.L60:
1491:.\Generated_Source\PSoC5/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1492:.\Generated_Source\PSoC5/UART.c ****             {
1493:.\Generated_Source\PSoC5/UART.c ****                 /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode
1494:.\Generated_Source\PSoC5/UART.c ****                 #if( (UART_PARITY_TYPE != UART__B_UART__NONE_REVB) || \
1495:.\Generated_Source\PSoC5/UART.c ****                                     (UART_PARITY_TYPE_SW != 0u) )
1496:.\Generated_Source\PSoC5/UART.c ****                     UART_WriteControlRegister(UART_ReadControlRegister() |
1497:.\Generated_Source\PSoC5/UART.c ****                                                           UART_CTRL_HD_SEND_BREAK);
1498:.\Generated_Source\PSoC5/UART.c ****                 #endif /* End UART_PARITY_TYPE != UART__B_UART__NONE_REVB  */
1499:.\Generated_Source\PSoC5/UART.c **** 
1500:.\Generated_Source\PSoC5/UART.c ****                 #if(UART_TXCLKGEN_DP)
1501:.\Generated_Source\PSoC5/UART.c ****                     txPeriod = UART_TXBITCLKTX_COMPLETE_REG;
 816              		.loc 1 1501 0 is_stmt 1
 817 001e 1B4B     		ldr	r3, .L66+4
 818 0020 1B78     		ldrb	r3, [r3]
 819 0022 DAB2     		uxtb	r2, r3
 820 0024 1A4B     		ldr	r3, .L66+8
 821 0026 1A70     		strb	r2, [r3]
1502:.\Generated_Source\PSoC5/UART.c ****                     UART_TXBITCLKTX_COMPLETE_REG = UART_TXBITCTR_BREAKBITS;
 822              		.loc 1 1502 0
 823 0028 184B     		ldr	r3, .L66+4
 824 002a 6722     		movs	r2, #103
 825 002c 1A70     		strb	r2, [r3]
1503:.\Generated_Source\PSoC5/UART.c ****                 #else
1504:.\Generated_Source\PSoC5/UART.c ****                     txPeriod = UART_TXBITCTR_PERIOD_REG;
1505:.\Generated_Source\PSoC5/UART.c ****                     UART_TXBITCTR_PERIOD_REG = UART_TXBITCTR_BREAKBITS8X;
1506:.\Generated_Source\PSoC5/UART.c ****                 #endif /* End UART_TXCLKGEN_DP */
1507:.\Generated_Source\PSoC5/UART.c **** 
1508:.\Generated_Source\PSoC5/UART.c ****                 /* Send zeros */
1509:.\Generated_Source\PSoC5/UART.c ****                 UART_TXDATA_REG = 0u;
 826              		.loc 1 1509 0
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 42


 827 002e 194B     		ldr	r3, .L66+12
 828 0030 0022     		movs	r2, #0
 829 0032 1A70     		strb	r2, [r3]
 830              	.L62:
1510:.\Generated_Source\PSoC5/UART.c **** 
1511:.\Generated_Source\PSoC5/UART.c ****                 do /* Wait until transmit starts */
1512:.\Generated_Source\PSoC5/UART.c ****                 {
1513:.\Generated_Source\PSoC5/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
 831              		.loc 1 1513 0 discriminator 1
 832 0034 184B     		ldr	r3, .L66+16
 833 0036 1B78     		ldrb	r3, [r3]
 834 0038 FB73     		strb	r3, [r7, #15]
1514:.\Generated_Source\PSoC5/UART.c ****                 }
1515:.\Generated_Source\PSoC5/UART.c ****                 while((tmpStat & UART_TX_STS_FIFO_EMPTY) != 0u);
 835              		.loc 1 1515 0 discriminator 1
 836 003a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 837 003c 03F00203 		and	r3, r3, #2
 838 0040 002B     		cmp	r3, #0
 839 0042 F7D1     		bne	.L62
 840              	.L61:
1516:.\Generated_Source\PSoC5/UART.c ****             }
1517:.\Generated_Source\PSoC5/UART.c **** 
1518:.\Generated_Source\PSoC5/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
 841              		.loc 1 1518 0
 842 0044 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 843 0046 012B     		cmp	r3, #1
 844 0048 02D0     		beq	.L63
 845              		.loc 1 1518 0 is_stmt 0 discriminator 1
 846 004a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 847 004c 032B     		cmp	r3, #3
 848 004e 09D1     		bne	.L64
 849              	.L63:
1519:.\Generated_Source\PSoC5/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1520:.\Generated_Source\PSoC5/UART.c ****             {
1521:.\Generated_Source\PSoC5/UART.c ****                 do /* Wait until transmit complete */
1522:.\Generated_Source\PSoC5/UART.c ****                 {
1523:.\Generated_Source\PSoC5/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
 850              		.loc 1 1523 0 is_stmt 1 discriminator 1
 851 0050 114B     		ldr	r3, .L66+16
 852 0052 1B78     		ldrb	r3, [r3]
 853 0054 FB73     		strb	r3, [r7, #15]
1524:.\Generated_Source\PSoC5/UART.c ****                 }
1525:.\Generated_Source\PSoC5/UART.c ****                 while(((uint8)~tmpStat & UART_TX_STS_COMPLETE) != 0u);
 854              		.loc 1 1525 0 discriminator 1
 855 0056 FB7B     		ldrb	r3, [r7, #15]
 856 0058 DB43     		mvns	r3, r3
 857 005a DBB2     		uxtb	r3, r3
 858 005c 03F00103 		and	r3, r3, #1
 859 0060 002B     		cmp	r3, #0
 860 0062 F5D1     		bne	.L63
 861              	.L64:
1526:.\Generated_Source\PSoC5/UART.c ****             }
1527:.\Generated_Source\PSoC5/UART.c **** 
1528:.\Generated_Source\PSoC5/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
 862              		.loc 1 1528 0
 863 0064 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 864 0066 012B     		cmp	r3, #1
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 43


 865 0068 05D0     		beq	.L65
 866              		.loc 1 1528 0 is_stmt 0 discriminator 1
 867 006a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 868 006c 022B     		cmp	r3, #2
 869 006e 02D0     		beq	.L65
1529:.\Generated_Source\PSoC5/UART.c ****                 (retMode == UART_REINIT) ||
 870              		.loc 1 1529 0 is_stmt 1
 871 0070 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 872 0072 032B     		cmp	r3, #3
 873 0074 03D1     		bne	.L58
 874              	.L65:
1530:.\Generated_Source\PSoC5/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1531:.\Generated_Source\PSoC5/UART.c ****             {
1532:.\Generated_Source\PSoC5/UART.c **** 
1533:.\Generated_Source\PSoC5/UART.c ****             #if(UART_TXCLKGEN_DP)
1534:.\Generated_Source\PSoC5/UART.c ****                 UART_TXBITCLKTX_COMPLETE_REG = txPeriod;
 875              		.loc 1 1534 0
 876 0076 054B     		ldr	r3, .L66+4
 877 0078 054A     		ldr	r2, .L66+8
 878 007a 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 879 007c 1A70     		strb	r2, [r3]
 880              	.L58:
 881              	.LBE2:
1535:.\Generated_Source\PSoC5/UART.c ****             #else
1536:.\Generated_Source\PSoC5/UART.c ****                 UART_TXBITCTR_PERIOD_REG = txPeriod;
1537:.\Generated_Source\PSoC5/UART.c ****             #endif /* End UART_TXCLKGEN_DP */
1538:.\Generated_Source\PSoC5/UART.c **** 
1539:.\Generated_Source\PSoC5/UART.c ****             #if( (UART_PARITY_TYPE != UART__B_UART__NONE_REVB) || \
1540:.\Generated_Source\PSoC5/UART.c ****                  (UART_PARITY_TYPE_SW != 0u) )
1541:.\Generated_Source\PSoC5/UART.c ****                 UART_WriteControlRegister(UART_ReadControlRegister() &
1542:.\Generated_Source\PSoC5/UART.c ****                                                       (uint8) ~UART_CTRL_HD_SEND_BREAK);
1543:.\Generated_Source\PSoC5/UART.c ****             #endif /* End UART_PARITY_TYPE != NONE */
1544:.\Generated_Source\PSoC5/UART.c ****             }
1545:.\Generated_Source\PSoC5/UART.c ****         #endif    /* End UART_HD_ENABLED */
1546:.\Generated_Source\PSoC5/UART.c ****         }
1547:.\Generated_Source\PSoC5/UART.c ****     }
 882              		.loc 1 1547 0
 883 007e 1437     		adds	r7, r7, #20
 884              		.cfi_def_cfa_offset 4
 885 0080 BD46     		mov	sp, r7
 886              		.cfi_def_cfa_register 13
 887              		@ sp needed
 888 0082 5DF8047B 		ldr	r7, [sp], #4
 889              		.cfi_restore 7
 890              		.cfi_def_cfa_offset 0
 891 0086 7047     		bx	lr
 892              	.L67:
 893              		.align	2
 894              	.L66:
 895 0088 00000000 		.word	UART_initVar
 896 008c 3A650040 		.word	1073767738
 897 0090 01000000 		.word	txPeriod.4933
 898 0094 4B650040 		.word	1073767755
 899 0098 6B650040 		.word	1073767787
 900              		.cfi_endproc
 901              	.LFE15:
 902              		.size	UART_SendBreak, .-UART_SendBreak
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 44


 903              		.section	.text.UART_SetTxAddressMode,"ax",%progbits
 904              		.align	2
 905              		.global	UART_SetTxAddressMode
 906              		.thumb
 907              		.thumb_func
 908              		.type	UART_SetTxAddressMode, %function
 909              	UART_SetTxAddressMode:
 910              	.LFB16:
1548:.\Generated_Source\PSoC5/UART.c **** 
1549:.\Generated_Source\PSoC5/UART.c **** 
1550:.\Generated_Source\PSoC5/UART.c ****     /*******************************************************************************
1551:.\Generated_Source\PSoC5/UART.c ****     * Function Name: UART_SetTxAddressMode
1552:.\Generated_Source\PSoC5/UART.c ****     ********************************************************************************
1553:.\Generated_Source\PSoC5/UART.c ****     *
1554:.\Generated_Source\PSoC5/UART.c ****     * Summary:
1555:.\Generated_Source\PSoC5/UART.c ****     *  Configures the transmitter to signal the next bytes is address or data.
1556:.\Generated_Source\PSoC5/UART.c ****     *
1557:.\Generated_Source\PSoC5/UART.c ****     * Parameters:
1558:.\Generated_Source\PSoC5/UART.c ****     *  addressMode: 
1559:.\Generated_Source\PSoC5/UART.c ****     *       UART_SET_SPACE - Configure the transmitter to send the next
1560:.\Generated_Source\PSoC5/UART.c ****     *                                    byte as a data.
1561:.\Generated_Source\PSoC5/UART.c ****     *       UART_SET_MARK  - Configure the transmitter to send the next
1562:.\Generated_Source\PSoC5/UART.c ****     *                                    byte as an address.
1563:.\Generated_Source\PSoC5/UART.c ****     *
1564:.\Generated_Source\PSoC5/UART.c ****     * Return:
1565:.\Generated_Source\PSoC5/UART.c ****     *  None.
1566:.\Generated_Source\PSoC5/UART.c ****     *
1567:.\Generated_Source\PSoC5/UART.c ****     * Side Effects:
1568:.\Generated_Source\PSoC5/UART.c ****     *  This function sets and clears UART_CTRL_MARK bit in the Control
1569:.\Generated_Source\PSoC5/UART.c ****     *  register.
1570:.\Generated_Source\PSoC5/UART.c ****     *
1571:.\Generated_Source\PSoC5/UART.c ****     *******************************************************************************/
1572:.\Generated_Source\PSoC5/UART.c ****     void UART_SetTxAddressMode(uint8 addressMode) 
1573:.\Generated_Source\PSoC5/UART.c ****     {
 911              		.loc 1 1573 0
 912              		.cfi_startproc
 913              		@ args = 0, pretend = 0, frame = 8
 914              		@ frame_needed = 1, uses_anonymous_args = 0
 915              		@ link register save eliminated.
 916 0000 80B4     		push	{r7}
 917              		.cfi_def_cfa_offset 4
 918              		.cfi_offset 7, -4
 919 0002 83B0     		sub	sp, sp, #12
 920              		.cfi_def_cfa_offset 16
 921 0004 00AF     		add	r7, sp, #0
 922              		.cfi_def_cfa_register 7
 923 0006 0346     		mov	r3, r0
 924 0008 FB71     		strb	r3, [r7, #7]
1574:.\Generated_Source\PSoC5/UART.c ****         /* Mark/Space sending enable */
1575:.\Generated_Source\PSoC5/UART.c ****         if(addressMode != 0u)
1576:.\Generated_Source\PSoC5/UART.c ****         {
1577:.\Generated_Source\PSoC5/UART.c ****         #if( UART_CONTROL_REG_REMOVED == 0u )
1578:.\Generated_Source\PSoC5/UART.c ****             UART_WriteControlRegister(UART_ReadControlRegister() |
1579:.\Generated_Source\PSoC5/UART.c ****                                                   UART_CTRL_MARK);
1580:.\Generated_Source\PSoC5/UART.c ****         #endif /* End UART_CONTROL_REG_REMOVED == 0u */
1581:.\Generated_Source\PSoC5/UART.c ****         }
1582:.\Generated_Source\PSoC5/UART.c ****         else
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 45


1583:.\Generated_Source\PSoC5/UART.c ****         {
1584:.\Generated_Source\PSoC5/UART.c ****         #if( UART_CONTROL_REG_REMOVED == 0u )
1585:.\Generated_Source\PSoC5/UART.c ****             UART_WriteControlRegister(UART_ReadControlRegister() &
1586:.\Generated_Source\PSoC5/UART.c ****                                                   (uint8) ~UART_CTRL_MARK);
1587:.\Generated_Source\PSoC5/UART.c ****         #endif /* End UART_CONTROL_REG_REMOVED == 0u */
1588:.\Generated_Source\PSoC5/UART.c ****         }
1589:.\Generated_Source\PSoC5/UART.c ****     }
 925              		.loc 1 1589 0
 926 000a 0C37     		adds	r7, r7, #12
 927              		.cfi_def_cfa_offset 4
 928 000c BD46     		mov	sp, r7
 929              		.cfi_def_cfa_register 13
 930              		@ sp needed
 931 000e 5DF8047B 		ldr	r7, [sp], #4
 932              		.cfi_restore 7
 933              		.cfi_def_cfa_offset 0
 934 0012 7047     		bx	lr
 935              		.cfi_endproc
 936              	.LFE16:
 937              		.size	UART_SetTxAddressMode, .-UART_SetTxAddressMode
 938              		.bss
 939              	txPeriod.4933:
 940 0001 00       		.space	1
 941              		.text
 942              	.Letext0:
 943              		.file 2 ".\\Generated_Source\\PSoC5\\cytypes.h"
 944              		.section	.debug_info,"",%progbits
 945              	.Ldebug_info0:
 946 0000 71030000 		.4byte	0x371
 947 0004 0400     		.2byte	0x4
 948 0006 00000000 		.4byte	.Ldebug_abbrev0
 949 000a 04       		.byte	0x4
 950 000b 01       		.uleb128 0x1
 951 000c 65010000 		.4byte	.LASF45
 952 0010 01       		.byte	0x1
 953 0011 FD000000 		.4byte	.LASF46
 954 0015 17000000 		.4byte	.LASF47
 955 0019 00000000 		.4byte	.Ldebug_ranges0+0
 956 001d 00000000 		.4byte	0
 957 0021 00000000 		.4byte	.Ldebug_line0
 958 0025 02       		.uleb128 0x2
 959 0026 01       		.byte	0x1
 960 0027 06       		.byte	0x6
 961 0028 25030000 		.4byte	.LASF0
 962 002c 02       		.uleb128 0x2
 963 002d 01       		.byte	0x1
 964 002e 08       		.byte	0x8
 965 002f 51010000 		.4byte	.LASF1
 966 0033 02       		.uleb128 0x2
 967 0034 02       		.byte	0x2
 968 0035 05       		.byte	0x5
 969 0036 F1020000 		.4byte	.LASF2
 970 003a 02       		.uleb128 0x2
 971 003b 02       		.byte	0x2
 972 003c 07       		.byte	0x7
 973 003d 8D000000 		.4byte	.LASF3
 974 0041 02       		.uleb128 0x2
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 46


 975 0042 04       		.byte	0x4
 976 0043 05       		.byte	0x5
 977 0044 1C030000 		.4byte	.LASF4
 978 0048 02       		.uleb128 0x2
 979 0049 04       		.byte	0x4
 980 004a 07       		.byte	0x7
 981 004b EB000000 		.4byte	.LASF5
 982 004f 02       		.uleb128 0x2
 983 0050 08       		.byte	0x8
 984 0051 05       		.byte	0x5
 985 0052 00000000 		.4byte	.LASF6
 986 0056 02       		.uleb128 0x2
 987 0057 08       		.byte	0x8
 988 0058 07       		.byte	0x7
 989 0059 50020000 		.4byte	.LASF7
 990 005d 03       		.uleb128 0x3
 991 005e 04       		.byte	0x4
 992 005f 05       		.byte	0x5
 993 0060 696E7400 		.ascii	"int\000"
 994 0064 02       		.uleb128 0x2
 995 0065 04       		.byte	0x4
 996 0066 07       		.byte	0x7
 997 0067 17020000 		.4byte	.LASF8
 998 006b 04       		.uleb128 0x4
 999 006c 0E030000 		.4byte	.LASF9
 1000 0070 02       		.byte	0x2
 1001 0071 C2       		.byte	0xc2
 1002 0072 2C000000 		.4byte	0x2c
 1003 0076 04       		.uleb128 0x4
 1004 0077 01020000 		.4byte	.LASF10
 1005 007b 02       		.byte	0x2
 1006 007c C3       		.byte	0xc3
 1007 007d 3A000000 		.4byte	0x3a
 1008 0081 02       		.uleb128 0x2
 1009 0082 04       		.byte	0x4
 1010 0083 04       		.byte	0x4
 1011 0084 BE000000 		.4byte	.LASF11
 1012 0088 02       		.uleb128 0x2
 1013 0089 08       		.byte	0x8
 1014 008a 04       		.byte	0x4
 1015 008b F3010000 		.4byte	.LASF12
 1016 008f 04       		.uleb128 0x4
 1017 0090 5F010000 		.4byte	.LASF13
 1018 0094 02       		.byte	0x2
 1019 0095 D3       		.byte	0xd3
 1020 0096 9A000000 		.4byte	0x9a
 1021 009a 02       		.uleb128 0x2
 1022 009b 01       		.byte	0x1
 1023 009c 08       		.byte	0x8
 1024 009d E4020000 		.4byte	.LASF14
 1025 00a1 05       		.uleb128 0x5
 1026 00a2 E6000000 		.4byte	.LASF15
 1027 00a6 02       		.byte	0x2
 1028 00a7 6C01     		.2byte	0x16c
 1029 00a9 AD000000 		.4byte	0xad
 1030 00ad 06       		.uleb128 0x6
 1031 00ae 6B000000 		.4byte	0x6b
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 47


 1032 00b2 02       		.uleb128 0x2
 1033 00b3 04       		.byte	0x4
 1034 00b4 07       		.byte	0x7
 1035 00b5 D0020000 		.4byte	.LASF16
 1036 00b9 07       		.uleb128 0x7
 1037 00ba 1D010000 		.4byte	.LASF17
 1038 00be 01       		.byte	0x1
 1039 00bf 4C       		.byte	0x4c
 1040 00c0 00000000 		.4byte	.LFB0
 1041 00c4 20000000 		.4byte	.LFE0-.LFB0
 1042 00c8 01       		.uleb128 0x1
 1043 00c9 9C       		.byte	0x9c
 1044 00ca 08       		.uleb128 0x8
 1045 00cb DC000000 		.4byte	.LASF18
 1046 00cf 01       		.byte	0x1
 1047 00d0 6A       		.byte	0x6a
 1048 00d1 00000000 		.4byte	.LFB1
 1049 00d5 2C000000 		.4byte	.LFE1-.LFB1
 1050 00d9 01       		.uleb128 0x1
 1051 00da 9C       		.byte	0x9c
 1052 00db 09       		.uleb128 0x9
 1053 00dc C4000000 		.4byte	.LASF19
 1054 00e0 01       		.byte	0x1
 1055 00e1 B7       		.byte	0xb7
 1056 00e2 00000000 		.4byte	.LFB2
 1057 00e6 34000000 		.4byte	.LFE2-.LFB2
 1058 00ea 01       		.uleb128 0x1
 1059 00eb 9C       		.byte	0x9c
 1060 00ec FF000000 		.4byte	0xff
 1061 00f0 0A       		.uleb128 0xa
 1062 00f1 40010000 		.4byte	.LASF21
 1063 00f5 01       		.byte	0x1
 1064 00f6 B9       		.byte	0xb9
 1065 00f7 6B000000 		.4byte	0x6b
 1066 00fb 02       		.uleb128 0x2
 1067 00fc 91       		.byte	0x91
 1068 00fd 77       		.sleb128 -9
 1069 00fe 00       		.byte	0
 1070 00ff 09       		.uleb128 0x9
 1071 0100 A0000000 		.4byte	.LASF20
 1072 0104 01       		.byte	0x1
 1073 0105 F0       		.byte	0xf0
 1074 0106 00000000 		.4byte	.LFB3
 1075 010a 34000000 		.4byte	.LFE3-.LFB3
 1076 010e 01       		.uleb128 0x1
 1077 010f 9C       		.byte	0x9c
 1078 0110 23010000 		.4byte	0x123
 1079 0114 0A       		.uleb128 0xa
 1080 0115 40010000 		.4byte	.LASF21
 1081 0119 01       		.byte	0x1
 1082 011a F2       		.byte	0xf2
 1083 011b 6B000000 		.4byte	0x6b
 1084 011f 02       		.uleb128 0x2
 1085 0120 91       		.byte	0x91
 1086 0121 77       		.sleb128 -9
 1087 0122 00       		.byte	0
 1088 0123 0B       		.uleb128 0xb
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 48


 1089 0124 67020000 		.4byte	.LASF28
 1090 0128 01       		.byte	0x1
 1091 0129 2701     		.2byte	0x127
 1092 012b 6B000000 		.4byte	0x6b
 1093 012f 00000000 		.4byte	.LFB4
 1094 0133 10000000 		.4byte	.LFE4-.LFB4
 1095 0137 01       		.uleb128 0x1
 1096 0138 9C       		.byte	0x9c
 1097 0139 0C       		.uleb128 0xc
 1098 013a 24020000 		.4byte	.LASF22
 1099 013e 01       		.byte	0x1
 1100 013f 3F01     		.2byte	0x13f
 1101 0141 00000000 		.4byte	.LFB5
 1102 0145 14000000 		.4byte	.LFE5-.LFB5
 1103 0149 01       		.uleb128 0x1
 1104 014a 9C       		.byte	0x9c
 1105 014b 5F010000 		.4byte	0x15f
 1106 014f 0D       		.uleb128 0xd
 1107 0150 14030000 		.4byte	.LASF24
 1108 0154 01       		.byte	0x1
 1109 0155 3F01     		.2byte	0x13f
 1110 0157 6B000000 		.4byte	0x6b
 1111 015b 02       		.uleb128 0x2
 1112 015c 91       		.byte	0x91
 1113 015d 77       		.sleb128 -9
 1114 015e 00       		.byte	0
 1115 015f 0C       		.uleb128 0xc
 1116 0160 96020000 		.4byte	.LASF23
 1117 0164 01       		.byte	0x1
 1118 0165 8C03     		.2byte	0x38c
 1119 0167 00000000 		.4byte	.LFB6
 1120 016b 20000000 		.4byte	.LFE6-.LFB6
 1121 016f 01       		.uleb128 0x1
 1122 0170 9C       		.byte	0x9c
 1123 0171 85010000 		.4byte	0x185
 1124 0175 0D       		.uleb128 0xd
 1125 0176 FA010000 		.4byte	.LASF25
 1126 017a 01       		.byte	0x1
 1127 017b 8C03     		.2byte	0x38c
 1128 017d 6B000000 		.4byte	0x6b
 1129 0181 02       		.uleb128 0x2
 1130 0182 91       		.byte	0x91
 1131 0183 77       		.sleb128 -9
 1132 0184 00       		.byte	0
 1133 0185 0C       		.uleb128 0xc
 1134 0186 5E000000 		.4byte	.LASF26
 1135 018a 01       		.byte	0x1
 1136 018b AE03     		.2byte	0x3ae
 1137 018d 00000000 		.4byte	.LFB7
 1138 0191 2C000000 		.4byte	.LFE7-.LFB7
 1139 0195 01       		.uleb128 0x1
 1140 0196 9C       		.byte	0x9c
 1141 0197 AB010000 		.4byte	0x1ab
 1142 019b 0D       		.uleb128 0xd
 1143 019c D9020000 		.4byte	.LASF27
 1144 01a0 01       		.byte	0x1
 1145 01a1 AE03     		.2byte	0x3ae
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 49


 1146 01a3 6B000000 		.4byte	0x6b
 1147 01a7 02       		.uleb128 0x2
 1148 01a8 91       		.byte	0x91
 1149 01a9 77       		.sleb128 -9
 1150 01aa 00       		.byte	0
 1151 01ab 0B       		.uleb128 0xb
 1152 01ac 3E020000 		.4byte	.LASF29
 1153 01b0 01       		.byte	0x1
 1154 01b1 EB03     		.2byte	0x3eb
 1155 01b3 6B000000 		.4byte	0x6b
 1156 01b7 00000000 		.4byte	.LFB8
 1157 01bb 18000000 		.4byte	.LFE8-.LFB8
 1158 01bf 01       		.uleb128 0x1
 1159 01c0 9C       		.byte	0x9c
 1160 01c1 0C       		.uleb128 0xc
 1161 01c2 AE020000 		.4byte	.LASF30
 1162 01c6 01       		.byte	0x1
 1163 01c7 1104     		.2byte	0x411
 1164 01c9 00000000 		.4byte	.LFB9
 1165 01cd 34000000 		.4byte	.LFE9-.LFB9
 1166 01d1 01       		.uleb128 0x1
 1167 01d2 9C       		.byte	0x9c
 1168 01d3 E7010000 		.4byte	0x1e7
 1169 01d7 0D       		.uleb128 0xd
 1170 01d8 D9020000 		.4byte	.LASF27
 1171 01dc 01       		.byte	0x1
 1172 01dd 1104     		.2byte	0x411
 1173 01df 6B000000 		.4byte	0x6b
 1174 01e3 02       		.uleb128 0x2
 1175 01e4 91       		.byte	0x91
 1176 01e5 77       		.sleb128 -9
 1177 01e6 00       		.byte	0
 1178 01e7 0E       		.uleb128 0xe
 1179 01e8 31030000 		.4byte	.LASF31
 1180 01ec 01       		.byte	0x1
 1181 01ed 7904     		.2byte	0x479
 1182 01ef 00000000 		.4byte	.LFB10
 1183 01f3 40000000 		.4byte	.LFE10-.LFB10
 1184 01f7 01       		.uleb128 0x1
 1185 01f8 9C       		.byte	0x9c
 1186 01f9 1C020000 		.4byte	0x21c
 1187 01fd 0D       		.uleb128 0xd
 1188 01fe B7000000 		.4byte	.LASF32
 1189 0202 01       		.byte	0x1
 1190 0203 7904     		.2byte	0x479
 1191 0205 1C020000 		.4byte	0x21c
 1192 0209 02       		.uleb128 0x2
 1193 020a 91       		.byte	0x91
 1194 020b 6C       		.sleb128 -20
 1195 020c 0F       		.uleb128 0xf
 1196 020d 8D020000 		.4byte	.LASF33
 1197 0211 01       		.byte	0x1
 1198 0212 7B04     		.2byte	0x47b
 1199 0214 76000000 		.4byte	0x76
 1200 0218 02       		.uleb128 0x2
 1201 0219 91       		.byte	0x91
 1202 021a 76       		.sleb128 -10
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 50


 1203 021b 00       		.byte	0
 1204 021c 10       		.uleb128 0x10
 1205 021d 04       		.byte	0x4
 1206 021e 22020000 		.4byte	0x222
 1207 0222 11       		.uleb128 0x11
 1208 0223 8F000000 		.4byte	0x8f
 1209 0227 0E       		.uleb128 0xe
 1210 0228 28010000 		.4byte	.LASF34
 1211 022c 01       		.byte	0x1
 1212 022d A704     		.2byte	0x4a7
 1213 022f 00000000 		.4byte	.LFB11
 1214 0233 40000000 		.4byte	.LFE11-.LFB11
 1215 0237 01       		.uleb128 0x1
 1216 0238 9C       		.byte	0x9c
 1217 0239 6B020000 		.4byte	0x26b
 1218 023d 0D       		.uleb128 0xd
 1219 023e B7000000 		.4byte	.LASF32
 1220 0242 01       		.byte	0x1
 1221 0243 A704     		.2byte	0x4a7
 1222 0245 6B020000 		.4byte	0x26b
 1223 0249 02       		.uleb128 0x2
 1224 024a 91       		.byte	0x91
 1225 024b 6C       		.sleb128 -20
 1226 024c 0D       		.uleb128 0xd
 1227 024d 36010000 		.4byte	.LASF35
 1228 0251 01       		.byte	0x1
 1229 0252 A704     		.2byte	0x4a7
 1230 0254 6B000000 		.4byte	0x6b
 1231 0258 02       		.uleb128 0x2
 1232 0259 91       		.byte	0x91
 1233 025a 6B       		.sleb128 -21
 1234 025b 0F       		.uleb128 0xf
 1235 025c 8D020000 		.4byte	.LASF33
 1236 0260 01       		.byte	0x1
 1237 0261 AA04     		.2byte	0x4aa
 1238 0263 6B000000 		.4byte	0x6b
 1239 0267 02       		.uleb128 0x2
 1240 0268 91       		.byte	0x91
 1241 0269 77       		.sleb128 -9
 1242 026a 00       		.byte	0
 1243 026b 10       		.uleb128 0x10
 1244 026c 04       		.byte	0x4
 1245 026d 71020000 		.4byte	0x271
 1246 0271 11       		.uleb128 0x11
 1247 0272 6B000000 		.4byte	0x6b
 1248 0276 0E       		.uleb128 0xe
 1249 0277 80020000 		.4byte	.LASF36
 1250 027b 01       		.byte	0x1
 1251 027c CE04     		.2byte	0x4ce
 1252 027e 00000000 		.4byte	.LFB12
 1253 0282 30000000 		.4byte	.LFE12-.LFB12
 1254 0286 01       		.uleb128 0x1
 1255 0287 9C       		.byte	0x9c
 1256 0288 9C020000 		.4byte	0x29c
 1257 028c 0D       		.uleb128 0xd
 1258 028d D9020000 		.4byte	.LASF27
 1259 0291 01       		.byte	0x1
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 51


 1260 0292 CE04     		.2byte	0x4ce
 1261 0294 6B000000 		.4byte	0x6b
 1262 0298 02       		.uleb128 0x2
 1263 0299 91       		.byte	0x91
 1264 029a 77       		.sleb128 -9
 1265 029b 00       		.byte	0
 1266 029c 12       		.uleb128 0x12
 1267 029d BB020000 		.4byte	.LASF48
 1268 02a1 01       		.byte	0x1
 1269 02a2 F904     		.2byte	0x4f9
 1270 02a4 6B000000 		.4byte	0x6b
 1271 02a8 00000000 		.4byte	.LFB13
 1272 02ac 44000000 		.4byte	.LFE13-.LFB13
 1273 02b0 01       		.uleb128 0x1
 1274 02b1 9C       		.byte	0x9c
 1275 02b2 C6020000 		.4byte	0x2c6
 1276 02b6 0F       		.uleb128 0xf
 1277 02b7 40030000 		.4byte	.LASF37
 1278 02bb 01       		.byte	0x1
 1279 02bc FC04     		.2byte	0x4fc
 1280 02be 6B000000 		.4byte	0x6b
 1281 02c2 02       		.uleb128 0x2
 1282 02c3 91       		.byte	0x91
 1283 02c4 77       		.sleb128 -9
 1284 02c5 00       		.byte	0
 1285 02c6 0E       		.uleb128 0xe
 1286 02c7 FB020000 		.4byte	.LASF38
 1287 02cb 01       		.byte	0x1
 1288 02cc 4A05     		.2byte	0x54a
 1289 02ce 00000000 		.4byte	.LFB14
 1290 02d2 40000000 		.4byte	.LFE14-.LFB14
 1291 02d6 01       		.uleb128 0x1
 1292 02d7 9C       		.byte	0x9c
 1293 02d8 EC020000 		.4byte	0x2ec
 1294 02dc 0F       		.uleb128 0xf
 1295 02dd 40010000 		.4byte	.LASF21
 1296 02e1 01       		.byte	0x1
 1297 02e2 4C05     		.2byte	0x54c
 1298 02e4 6B000000 		.4byte	0x6b
 1299 02e8 02       		.uleb128 0x2
 1300 02e9 91       		.byte	0x91
 1301 02ea 77       		.sleb128 -9
 1302 02eb 00       		.byte	0
 1303 02ec 0C       		.uleb128 0xc
 1304 02ed 08020000 		.4byte	.LASF39
 1305 02f1 01       		.byte	0x1
 1306 02f2 A005     		.2byte	0x5a0
 1307 02f4 00000000 		.4byte	.LFB15
 1308 02f8 9C000000 		.4byte	.LFE15-.LFB15
 1309 02fc 01       		.uleb128 0x1
 1310 02fd 9C       		.byte	0x9c
 1311 02fe 3D030000 		.4byte	0x33d
 1312 0302 0D       		.uleb128 0xd
 1313 0303 E9020000 		.4byte	.LASF40
 1314 0307 01       		.byte	0x1
 1315 0308 A005     		.2byte	0x5a0
 1316 030a 6B000000 		.4byte	0x6b
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 52


 1317 030e 02       		.uleb128 0x2
 1318 030f 91       		.byte	0x91
 1319 0310 6F       		.sleb128 -17
 1320 0311 13       		.uleb128 0x13
 1321 0312 12000000 		.4byte	.LBB2
 1322 0316 6C000000 		.4byte	.LBE2-.LBB2
 1323 031a 0F       		.uleb128 0xf
 1324 031b 6F000000 		.4byte	.LASF41
 1325 031f 01       		.byte	0x1
 1326 0320 A805     		.2byte	0x5a8
 1327 0322 6B000000 		.4byte	0x6b
 1328 0326 02       		.uleb128 0x2
 1329 0327 91       		.byte	0x91
 1330 0328 77       		.sleb128 -9
 1331 0329 0F       		.uleb128 0xf
 1332 032a 0E000000 		.4byte	.LASF42
 1333 032e 01       		.byte	0x1
 1334 032f D005     		.2byte	0x5d0
 1335 0331 6B000000 		.4byte	0x6b
 1336 0335 05       		.uleb128 0x5
 1337 0336 03       		.byte	0x3
 1338 0337 01000000 		.4byte	txPeriod.4933
 1339 033b 00       		.byte	0
 1340 033c 00       		.byte	0
 1341 033d 0C       		.uleb128 0xc
 1342 033e 77000000 		.4byte	.LASF43
 1343 0342 01       		.byte	0x1
 1344 0343 2406     		.2byte	0x624
 1345 0345 00000000 		.4byte	.LFB16
 1346 0349 14000000 		.4byte	.LFE16-.LFB16
 1347 034d 01       		.uleb128 0x1
 1348 034e 9C       		.byte	0x9c
 1349 034f 63030000 		.4byte	0x363
 1350 0353 0D       		.uleb128 0xd
 1351 0354 D0000000 		.4byte	.LASF44
 1352 0358 01       		.byte	0x1
 1353 0359 2406     		.2byte	0x624
 1354 035b 6B000000 		.4byte	0x6b
 1355 035f 02       		.uleb128 0x2
 1356 0360 91       		.byte	0x91
 1357 0361 77       		.sleb128 -9
 1358 0362 00       		.byte	0
 1359 0363 14       		.uleb128 0x14
 1360 0364 AA000000 		.4byte	.LASF49
 1361 0368 01       		.byte	0x1
 1362 0369 1B       		.byte	0x1b
 1363 036a 6B000000 		.4byte	0x6b
 1364 036e 05       		.uleb128 0x5
 1365 036f 03       		.byte	0x3
 1366 0370 00000000 		.4byte	UART_initVar
 1367 0374 00       		.byte	0
 1368              		.section	.debug_abbrev,"",%progbits
 1369              	.Ldebug_abbrev0:
 1370 0000 01       		.uleb128 0x1
 1371 0001 11       		.uleb128 0x11
 1372 0002 01       		.byte	0x1
 1373 0003 25       		.uleb128 0x25
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 53


 1374 0004 0E       		.uleb128 0xe
 1375 0005 13       		.uleb128 0x13
 1376 0006 0B       		.uleb128 0xb
 1377 0007 03       		.uleb128 0x3
 1378 0008 0E       		.uleb128 0xe
 1379 0009 1B       		.uleb128 0x1b
 1380 000a 0E       		.uleb128 0xe
 1381 000b 55       		.uleb128 0x55
 1382 000c 17       		.uleb128 0x17
 1383 000d 11       		.uleb128 0x11
 1384 000e 01       		.uleb128 0x1
 1385 000f 10       		.uleb128 0x10
 1386 0010 17       		.uleb128 0x17
 1387 0011 00       		.byte	0
 1388 0012 00       		.byte	0
 1389 0013 02       		.uleb128 0x2
 1390 0014 24       		.uleb128 0x24
 1391 0015 00       		.byte	0
 1392 0016 0B       		.uleb128 0xb
 1393 0017 0B       		.uleb128 0xb
 1394 0018 3E       		.uleb128 0x3e
 1395 0019 0B       		.uleb128 0xb
 1396 001a 03       		.uleb128 0x3
 1397 001b 0E       		.uleb128 0xe
 1398 001c 00       		.byte	0
 1399 001d 00       		.byte	0
 1400 001e 03       		.uleb128 0x3
 1401 001f 24       		.uleb128 0x24
 1402 0020 00       		.byte	0
 1403 0021 0B       		.uleb128 0xb
 1404 0022 0B       		.uleb128 0xb
 1405 0023 3E       		.uleb128 0x3e
 1406 0024 0B       		.uleb128 0xb
 1407 0025 03       		.uleb128 0x3
 1408 0026 08       		.uleb128 0x8
 1409 0027 00       		.byte	0
 1410 0028 00       		.byte	0
 1411 0029 04       		.uleb128 0x4
 1412 002a 16       		.uleb128 0x16
 1413 002b 00       		.byte	0
 1414 002c 03       		.uleb128 0x3
 1415 002d 0E       		.uleb128 0xe
 1416 002e 3A       		.uleb128 0x3a
 1417 002f 0B       		.uleb128 0xb
 1418 0030 3B       		.uleb128 0x3b
 1419 0031 0B       		.uleb128 0xb
 1420 0032 49       		.uleb128 0x49
 1421 0033 13       		.uleb128 0x13
 1422 0034 00       		.byte	0
 1423 0035 00       		.byte	0
 1424 0036 05       		.uleb128 0x5
 1425 0037 16       		.uleb128 0x16
 1426 0038 00       		.byte	0
 1427 0039 03       		.uleb128 0x3
 1428 003a 0E       		.uleb128 0xe
 1429 003b 3A       		.uleb128 0x3a
 1430 003c 0B       		.uleb128 0xb
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 54


 1431 003d 3B       		.uleb128 0x3b
 1432 003e 05       		.uleb128 0x5
 1433 003f 49       		.uleb128 0x49
 1434 0040 13       		.uleb128 0x13
 1435 0041 00       		.byte	0
 1436 0042 00       		.byte	0
 1437 0043 06       		.uleb128 0x6
 1438 0044 35       		.uleb128 0x35
 1439 0045 00       		.byte	0
 1440 0046 49       		.uleb128 0x49
 1441 0047 13       		.uleb128 0x13
 1442 0048 00       		.byte	0
 1443 0049 00       		.byte	0
 1444 004a 07       		.uleb128 0x7
 1445 004b 2E       		.uleb128 0x2e
 1446 004c 00       		.byte	0
 1447 004d 3F       		.uleb128 0x3f
 1448 004e 19       		.uleb128 0x19
 1449 004f 03       		.uleb128 0x3
 1450 0050 0E       		.uleb128 0xe
 1451 0051 3A       		.uleb128 0x3a
 1452 0052 0B       		.uleb128 0xb
 1453 0053 3B       		.uleb128 0x3b
 1454 0054 0B       		.uleb128 0xb
 1455 0055 27       		.uleb128 0x27
 1456 0056 19       		.uleb128 0x19
 1457 0057 11       		.uleb128 0x11
 1458 0058 01       		.uleb128 0x1
 1459 0059 12       		.uleb128 0x12
 1460 005a 06       		.uleb128 0x6
 1461 005b 40       		.uleb128 0x40
 1462 005c 18       		.uleb128 0x18
 1463 005d 9642     		.uleb128 0x2116
 1464 005f 19       		.uleb128 0x19
 1465 0060 00       		.byte	0
 1466 0061 00       		.byte	0
 1467 0062 08       		.uleb128 0x8
 1468 0063 2E       		.uleb128 0x2e
 1469 0064 00       		.byte	0
 1470 0065 3F       		.uleb128 0x3f
 1471 0066 19       		.uleb128 0x19
 1472 0067 03       		.uleb128 0x3
 1473 0068 0E       		.uleb128 0xe
 1474 0069 3A       		.uleb128 0x3a
 1475 006a 0B       		.uleb128 0xb
 1476 006b 3B       		.uleb128 0x3b
 1477 006c 0B       		.uleb128 0xb
 1478 006d 27       		.uleb128 0x27
 1479 006e 19       		.uleb128 0x19
 1480 006f 11       		.uleb128 0x11
 1481 0070 01       		.uleb128 0x1
 1482 0071 12       		.uleb128 0x12
 1483 0072 06       		.uleb128 0x6
 1484 0073 40       		.uleb128 0x40
 1485 0074 18       		.uleb128 0x18
 1486 0075 9742     		.uleb128 0x2117
 1487 0077 19       		.uleb128 0x19
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 55


 1488 0078 00       		.byte	0
 1489 0079 00       		.byte	0
 1490 007a 09       		.uleb128 0x9
 1491 007b 2E       		.uleb128 0x2e
 1492 007c 01       		.byte	0x1
 1493 007d 3F       		.uleb128 0x3f
 1494 007e 19       		.uleb128 0x19
 1495 007f 03       		.uleb128 0x3
 1496 0080 0E       		.uleb128 0xe
 1497 0081 3A       		.uleb128 0x3a
 1498 0082 0B       		.uleb128 0xb
 1499 0083 3B       		.uleb128 0x3b
 1500 0084 0B       		.uleb128 0xb
 1501 0085 27       		.uleb128 0x27
 1502 0086 19       		.uleb128 0x19
 1503 0087 11       		.uleb128 0x11
 1504 0088 01       		.uleb128 0x1
 1505 0089 12       		.uleb128 0x12
 1506 008a 06       		.uleb128 0x6
 1507 008b 40       		.uleb128 0x40
 1508 008c 18       		.uleb128 0x18
 1509 008d 9642     		.uleb128 0x2116
 1510 008f 19       		.uleb128 0x19
 1511 0090 01       		.uleb128 0x1
 1512 0091 13       		.uleb128 0x13
 1513 0092 00       		.byte	0
 1514 0093 00       		.byte	0
 1515 0094 0A       		.uleb128 0xa
 1516 0095 34       		.uleb128 0x34
 1517 0096 00       		.byte	0
 1518 0097 03       		.uleb128 0x3
 1519 0098 0E       		.uleb128 0xe
 1520 0099 3A       		.uleb128 0x3a
 1521 009a 0B       		.uleb128 0xb
 1522 009b 3B       		.uleb128 0x3b
 1523 009c 0B       		.uleb128 0xb
 1524 009d 49       		.uleb128 0x49
 1525 009e 13       		.uleb128 0x13
 1526 009f 02       		.uleb128 0x2
 1527 00a0 18       		.uleb128 0x18
 1528 00a1 00       		.byte	0
 1529 00a2 00       		.byte	0
 1530 00a3 0B       		.uleb128 0xb
 1531 00a4 2E       		.uleb128 0x2e
 1532 00a5 00       		.byte	0
 1533 00a6 3F       		.uleb128 0x3f
 1534 00a7 19       		.uleb128 0x19
 1535 00a8 03       		.uleb128 0x3
 1536 00a9 0E       		.uleb128 0xe
 1537 00aa 3A       		.uleb128 0x3a
 1538 00ab 0B       		.uleb128 0xb
 1539 00ac 3B       		.uleb128 0x3b
 1540 00ad 05       		.uleb128 0x5
 1541 00ae 27       		.uleb128 0x27
 1542 00af 19       		.uleb128 0x19
 1543 00b0 49       		.uleb128 0x49
 1544 00b1 13       		.uleb128 0x13
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 56


 1545 00b2 11       		.uleb128 0x11
 1546 00b3 01       		.uleb128 0x1
 1547 00b4 12       		.uleb128 0x12
 1548 00b5 06       		.uleb128 0x6
 1549 00b6 40       		.uleb128 0x40
 1550 00b7 18       		.uleb128 0x18
 1551 00b8 9742     		.uleb128 0x2117
 1552 00ba 19       		.uleb128 0x19
 1553 00bb 00       		.byte	0
 1554 00bc 00       		.byte	0
 1555 00bd 0C       		.uleb128 0xc
 1556 00be 2E       		.uleb128 0x2e
 1557 00bf 01       		.byte	0x1
 1558 00c0 3F       		.uleb128 0x3f
 1559 00c1 19       		.uleb128 0x19
 1560 00c2 03       		.uleb128 0x3
 1561 00c3 0E       		.uleb128 0xe
 1562 00c4 3A       		.uleb128 0x3a
 1563 00c5 0B       		.uleb128 0xb
 1564 00c6 3B       		.uleb128 0x3b
 1565 00c7 05       		.uleb128 0x5
 1566 00c8 27       		.uleb128 0x27
 1567 00c9 19       		.uleb128 0x19
 1568 00ca 11       		.uleb128 0x11
 1569 00cb 01       		.uleb128 0x1
 1570 00cc 12       		.uleb128 0x12
 1571 00cd 06       		.uleb128 0x6
 1572 00ce 40       		.uleb128 0x40
 1573 00cf 18       		.uleb128 0x18
 1574 00d0 9742     		.uleb128 0x2117
 1575 00d2 19       		.uleb128 0x19
 1576 00d3 01       		.uleb128 0x1
 1577 00d4 13       		.uleb128 0x13
 1578 00d5 00       		.byte	0
 1579 00d6 00       		.byte	0
 1580 00d7 0D       		.uleb128 0xd
 1581 00d8 05       		.uleb128 0x5
 1582 00d9 00       		.byte	0
 1583 00da 03       		.uleb128 0x3
 1584 00db 0E       		.uleb128 0xe
 1585 00dc 3A       		.uleb128 0x3a
 1586 00dd 0B       		.uleb128 0xb
 1587 00de 3B       		.uleb128 0x3b
 1588 00df 05       		.uleb128 0x5
 1589 00e0 49       		.uleb128 0x49
 1590 00e1 13       		.uleb128 0x13
 1591 00e2 02       		.uleb128 0x2
 1592 00e3 18       		.uleb128 0x18
 1593 00e4 00       		.byte	0
 1594 00e5 00       		.byte	0
 1595 00e6 0E       		.uleb128 0xe
 1596 00e7 2E       		.uleb128 0x2e
 1597 00e8 01       		.byte	0x1
 1598 00e9 3F       		.uleb128 0x3f
 1599 00ea 19       		.uleb128 0x19
 1600 00eb 03       		.uleb128 0x3
 1601 00ec 0E       		.uleb128 0xe
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 57


 1602 00ed 3A       		.uleb128 0x3a
 1603 00ee 0B       		.uleb128 0xb
 1604 00ef 3B       		.uleb128 0x3b
 1605 00f0 05       		.uleb128 0x5
 1606 00f1 27       		.uleb128 0x27
 1607 00f2 19       		.uleb128 0x19
 1608 00f3 11       		.uleb128 0x11
 1609 00f4 01       		.uleb128 0x1
 1610 00f5 12       		.uleb128 0x12
 1611 00f6 06       		.uleb128 0x6
 1612 00f7 40       		.uleb128 0x40
 1613 00f8 18       		.uleb128 0x18
 1614 00f9 9642     		.uleb128 0x2116
 1615 00fb 19       		.uleb128 0x19
 1616 00fc 01       		.uleb128 0x1
 1617 00fd 13       		.uleb128 0x13
 1618 00fe 00       		.byte	0
 1619 00ff 00       		.byte	0
 1620 0100 0F       		.uleb128 0xf
 1621 0101 34       		.uleb128 0x34
 1622 0102 00       		.byte	0
 1623 0103 03       		.uleb128 0x3
 1624 0104 0E       		.uleb128 0xe
 1625 0105 3A       		.uleb128 0x3a
 1626 0106 0B       		.uleb128 0xb
 1627 0107 3B       		.uleb128 0x3b
 1628 0108 05       		.uleb128 0x5
 1629 0109 49       		.uleb128 0x49
 1630 010a 13       		.uleb128 0x13
 1631 010b 02       		.uleb128 0x2
 1632 010c 18       		.uleb128 0x18
 1633 010d 00       		.byte	0
 1634 010e 00       		.byte	0
 1635 010f 10       		.uleb128 0x10
 1636 0110 0F       		.uleb128 0xf
 1637 0111 00       		.byte	0
 1638 0112 0B       		.uleb128 0xb
 1639 0113 0B       		.uleb128 0xb
 1640 0114 49       		.uleb128 0x49
 1641 0115 13       		.uleb128 0x13
 1642 0116 00       		.byte	0
 1643 0117 00       		.byte	0
 1644 0118 11       		.uleb128 0x11
 1645 0119 26       		.uleb128 0x26
 1646 011a 00       		.byte	0
 1647 011b 49       		.uleb128 0x49
 1648 011c 13       		.uleb128 0x13
 1649 011d 00       		.byte	0
 1650 011e 00       		.byte	0
 1651 011f 12       		.uleb128 0x12
 1652 0120 2E       		.uleb128 0x2e
 1653 0121 01       		.byte	0x1
 1654 0122 3F       		.uleb128 0x3f
 1655 0123 19       		.uleb128 0x19
 1656 0124 03       		.uleb128 0x3
 1657 0125 0E       		.uleb128 0xe
 1658 0126 3A       		.uleb128 0x3a
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 58


 1659 0127 0B       		.uleb128 0xb
 1660 0128 3B       		.uleb128 0x3b
 1661 0129 05       		.uleb128 0x5
 1662 012a 27       		.uleb128 0x27
 1663 012b 19       		.uleb128 0x19
 1664 012c 49       		.uleb128 0x49
 1665 012d 13       		.uleb128 0x13
 1666 012e 11       		.uleb128 0x11
 1667 012f 01       		.uleb128 0x1
 1668 0130 12       		.uleb128 0x12
 1669 0131 06       		.uleb128 0x6
 1670 0132 40       		.uleb128 0x40
 1671 0133 18       		.uleb128 0x18
 1672 0134 9742     		.uleb128 0x2117
 1673 0136 19       		.uleb128 0x19
 1674 0137 01       		.uleb128 0x1
 1675 0138 13       		.uleb128 0x13
 1676 0139 00       		.byte	0
 1677 013a 00       		.byte	0
 1678 013b 13       		.uleb128 0x13
 1679 013c 0B       		.uleb128 0xb
 1680 013d 01       		.byte	0x1
 1681 013e 11       		.uleb128 0x11
 1682 013f 01       		.uleb128 0x1
 1683 0140 12       		.uleb128 0x12
 1684 0141 06       		.uleb128 0x6
 1685 0142 00       		.byte	0
 1686 0143 00       		.byte	0
 1687 0144 14       		.uleb128 0x14
 1688 0145 34       		.uleb128 0x34
 1689 0146 00       		.byte	0
 1690 0147 03       		.uleb128 0x3
 1691 0148 0E       		.uleb128 0xe
 1692 0149 3A       		.uleb128 0x3a
 1693 014a 0B       		.uleb128 0xb
 1694 014b 3B       		.uleb128 0x3b
 1695 014c 0B       		.uleb128 0xb
 1696 014d 49       		.uleb128 0x49
 1697 014e 13       		.uleb128 0x13
 1698 014f 3F       		.uleb128 0x3f
 1699 0150 19       		.uleb128 0x19
 1700 0151 02       		.uleb128 0x2
 1701 0152 18       		.uleb128 0x18
 1702 0153 00       		.byte	0
 1703 0154 00       		.byte	0
 1704 0155 00       		.byte	0
 1705              		.section	.debug_aranges,"",%progbits
 1706 0000 9C000000 		.4byte	0x9c
 1707 0004 0200     		.2byte	0x2
 1708 0006 00000000 		.4byte	.Ldebug_info0
 1709 000a 04       		.byte	0x4
 1710 000b 00       		.byte	0
 1711 000c 0000     		.2byte	0
 1712 000e 0000     		.2byte	0
 1713 0010 00000000 		.4byte	.LFB0
 1714 0014 20000000 		.4byte	.LFE0-.LFB0
 1715 0018 00000000 		.4byte	.LFB1
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 59


 1716 001c 2C000000 		.4byte	.LFE1-.LFB1
 1717 0020 00000000 		.4byte	.LFB2
 1718 0024 34000000 		.4byte	.LFE2-.LFB2
 1719 0028 00000000 		.4byte	.LFB3
 1720 002c 34000000 		.4byte	.LFE3-.LFB3
 1721 0030 00000000 		.4byte	.LFB4
 1722 0034 10000000 		.4byte	.LFE4-.LFB4
 1723 0038 00000000 		.4byte	.LFB5
 1724 003c 14000000 		.4byte	.LFE5-.LFB5
 1725 0040 00000000 		.4byte	.LFB6
 1726 0044 20000000 		.4byte	.LFE6-.LFB6
 1727 0048 00000000 		.4byte	.LFB7
 1728 004c 2C000000 		.4byte	.LFE7-.LFB7
 1729 0050 00000000 		.4byte	.LFB8
 1730 0054 18000000 		.4byte	.LFE8-.LFB8
 1731 0058 00000000 		.4byte	.LFB9
 1732 005c 34000000 		.4byte	.LFE9-.LFB9
 1733 0060 00000000 		.4byte	.LFB10
 1734 0064 40000000 		.4byte	.LFE10-.LFB10
 1735 0068 00000000 		.4byte	.LFB11
 1736 006c 40000000 		.4byte	.LFE11-.LFB11
 1737 0070 00000000 		.4byte	.LFB12
 1738 0074 30000000 		.4byte	.LFE12-.LFB12
 1739 0078 00000000 		.4byte	.LFB13
 1740 007c 44000000 		.4byte	.LFE13-.LFB13
 1741 0080 00000000 		.4byte	.LFB14
 1742 0084 40000000 		.4byte	.LFE14-.LFB14
 1743 0088 00000000 		.4byte	.LFB15
 1744 008c 9C000000 		.4byte	.LFE15-.LFB15
 1745 0090 00000000 		.4byte	.LFB16
 1746 0094 14000000 		.4byte	.LFE16-.LFB16
 1747 0098 00000000 		.4byte	0
 1748 009c 00000000 		.4byte	0
 1749              		.section	.debug_ranges,"",%progbits
 1750              	.Ldebug_ranges0:
 1751 0000 00000000 		.4byte	.LFB0
 1752 0004 20000000 		.4byte	.LFE0
 1753 0008 00000000 		.4byte	.LFB1
 1754 000c 2C000000 		.4byte	.LFE1
 1755 0010 00000000 		.4byte	.LFB2
 1756 0014 34000000 		.4byte	.LFE2
 1757 0018 00000000 		.4byte	.LFB3
 1758 001c 34000000 		.4byte	.LFE3
 1759 0020 00000000 		.4byte	.LFB4
 1760 0024 10000000 		.4byte	.LFE4
 1761 0028 00000000 		.4byte	.LFB5
 1762 002c 14000000 		.4byte	.LFE5
 1763 0030 00000000 		.4byte	.LFB6
 1764 0034 20000000 		.4byte	.LFE6
 1765 0038 00000000 		.4byte	.LFB7
 1766 003c 2C000000 		.4byte	.LFE7
 1767 0040 00000000 		.4byte	.LFB8
 1768 0044 18000000 		.4byte	.LFE8
 1769 0048 00000000 		.4byte	.LFB9
 1770 004c 34000000 		.4byte	.LFE9
 1771 0050 00000000 		.4byte	.LFB10
 1772 0054 40000000 		.4byte	.LFE10
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 60


 1773 0058 00000000 		.4byte	.LFB11
 1774 005c 40000000 		.4byte	.LFE11
 1775 0060 00000000 		.4byte	.LFB12
 1776 0064 30000000 		.4byte	.LFE12
 1777 0068 00000000 		.4byte	.LFB13
 1778 006c 44000000 		.4byte	.LFE13
 1779 0070 00000000 		.4byte	.LFB14
 1780 0074 40000000 		.4byte	.LFE14
 1781 0078 00000000 		.4byte	.LFB15
 1782 007c 9C000000 		.4byte	.LFE15
 1783 0080 00000000 		.4byte	.LFB16
 1784 0084 14000000 		.4byte	.LFE16
 1785 0088 00000000 		.4byte	0
 1786 008c 00000000 		.4byte	0
 1787              		.section	.debug_line,"",%progbits
 1788              	.Ldebug_line0:
 1789 0000 F3010000 		.section	.debug_str,"MS",%progbits,1
 1789      02004300 
 1789      00000201 
 1789      FB0E0D00 
 1789      01010101 
 1790              	.LASF6:
 1791 0000 6C6F6E67 		.ascii	"long long int\000"
 1791      206C6F6E 
 1791      6720696E 
 1791      7400
 1792              	.LASF42:
 1793 000e 74785065 		.ascii	"txPeriod\000"
 1793      72696F64 
 1793      00
 1794              	.LASF47:
 1795 0017 433A5C55 		.ascii	"C:\\Users\\nm\\Desktop\\TempSenseExample\\CE210514_"
 1795      73657273 
 1795      5C6E6D5C 
 1795      4465736B 
 1795      746F705C 
 1796 0045 50534F43 		.ascii	"PSOC3_5_Thermistor.cydsn\000"
 1796      335F355F 
 1796      54686572 
 1796      6D697374 
 1796      6F722E63 
 1797              	.LASF26:
 1798 005e 55415254 		.ascii	"UART_WriteTxData\000"
 1798      5F577269 
 1798      74655478 
 1798      44617461 
 1798      00
 1799              	.LASF41:
 1800 006f 746D7053 		.ascii	"tmpStat\000"
 1800      74617400 
 1801              	.LASF43:
 1802 0077 55415254 		.ascii	"UART_SetTxAddressMode\000"
 1802      5F536574 
 1802      54784164 
 1802      64726573 
 1802      734D6F64 
 1803              	.LASF3:
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 61


 1804 008d 73686F72 		.ascii	"short unsigned int\000"
 1804      7420756E 
 1804      7369676E 
 1804      65642069 
 1804      6E7400
 1805              	.LASF20:
 1806 00a0 55415254 		.ascii	"UART_Stop\000"
 1806      5F53746F 
 1806      7000
 1807              	.LASF49:
 1808 00aa 55415254 		.ascii	"UART_initVar\000"
 1808      5F696E69 
 1808      74566172 
 1808      00
 1809              	.LASF32:
 1810 00b7 73747269 		.ascii	"string\000"
 1810      6E6700
 1811              	.LASF11:
 1812 00be 666C6F61 		.ascii	"float\000"
 1812      7400
 1813              	.LASF19:
 1814 00c4 55415254 		.ascii	"UART_Enable\000"
 1814      5F456E61 
 1814      626C6500 
 1815              	.LASF44:
 1816 00d0 61646472 		.ascii	"addressMode\000"
 1816      6573734D 
 1816      6F646500 
 1817              	.LASF18:
 1818 00dc 55415254 		.ascii	"UART_Init\000"
 1818      5F496E69 
 1818      7400
 1819              	.LASF15:
 1820 00e6 72656738 		.ascii	"reg8\000"
 1820      00
 1821              	.LASF5:
 1822 00eb 6C6F6E67 		.ascii	"long unsigned int\000"
 1822      20756E73 
 1822      69676E65 
 1822      6420696E 
 1822      7400
 1823              	.LASF46:
 1824 00fd 2E5C4765 		.ascii	".\\Generated_Source\\PSoC5\\UART.c\000"
 1824      6E657261 
 1824      7465645F 
 1824      536F7572 
 1824      63655C50 
 1825              	.LASF17:
 1826 011d 55415254 		.ascii	"UART_Start\000"
 1826      5F537461 
 1826      727400
 1827              	.LASF34:
 1828 0128 55415254 		.ascii	"UART_PutArray\000"
 1828      5F507574 
 1828      41727261 
 1828      7900
 1829              	.LASF35:
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 62


 1830 0136 62797465 		.ascii	"byteCount\000"
 1830      436F756E 
 1830      7400
 1831              	.LASF21:
 1832 0140 656E6162 		.ascii	"enableInterrupts\000"
 1832      6C65496E 
 1832      74657272 
 1832      75707473 
 1832      00
 1833              	.LASF1:
 1834 0151 756E7369 		.ascii	"unsigned char\000"
 1834      676E6564 
 1834      20636861 
 1834      7200
 1835              	.LASF13:
 1836 015f 63686172 		.ascii	"char8\000"
 1836      3800
 1837              	.LASF45:
 1838 0165 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 1838      4320342E 
 1838      392E3320 
 1838      32303135 
 1838      30333033 
 1839 0198 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m3 -mthumb -g -O"
 1839      20726576 
 1839      6973696F 
 1839      6E203232 
 1839      31323230 
 1840 01cb 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 1840      66756E63 
 1840      74696F6E 
 1840      2D736563 
 1840      74696F6E 
 1841              	.LASF12:
 1842 01f3 646F7562 		.ascii	"double\000"
 1842      6C6500
 1843              	.LASF25:
 1844 01fa 696E7453 		.ascii	"intSrc\000"
 1844      726300
 1845              	.LASF10:
 1846 0201 75696E74 		.ascii	"uint16\000"
 1846      313600
 1847              	.LASF39:
 1848 0208 55415254 		.ascii	"UART_SendBreak\000"
 1848      5F53656E 
 1848      64427265 
 1848      616B00
 1849              	.LASF8:
 1850 0217 756E7369 		.ascii	"unsigned int\000"
 1850      676E6564 
 1850      20696E74 
 1850      00
 1851              	.LASF22:
 1852 0224 55415254 		.ascii	"UART_WriteControlRegister\000"
 1852      5F577269 
 1852      7465436F 
 1852      6E74726F 
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 63


 1852      6C526567 
 1853              	.LASF29:
 1854 023e 55415254 		.ascii	"UART_ReadTxStatus\000"
 1854      5F526561 
 1854      64547853 
 1854      74617475 
 1854      7300
 1855              	.LASF7:
 1856 0250 6C6F6E67 		.ascii	"long long unsigned int\000"
 1856      206C6F6E 
 1856      6720756E 
 1856      7369676E 
 1856      65642069 
 1857              	.LASF28:
 1858 0267 55415254 		.ascii	"UART_ReadControlRegister\000"
 1858      5F526561 
 1858      64436F6E 
 1858      74726F6C 
 1858      52656769 
 1859              	.LASF36:
 1860 0280 55415254 		.ascii	"UART_PutCRLF\000"
 1860      5F507574 
 1860      43524C46 
 1860      00
 1861              	.LASF33:
 1862 028d 62756649 		.ascii	"bufIndex\000"
 1862      6E646578 
 1862      00
 1863              	.LASF23:
 1864 0296 55415254 		.ascii	"UART_SetTxInterruptMode\000"
 1864      5F536574 
 1864      5478496E 
 1864      74657272 
 1864      7570744D 
 1865              	.LASF30:
 1866 02ae 55415254 		.ascii	"UART_PutChar\000"
 1866      5F507574 
 1866      43686172 
 1866      00
 1867              	.LASF48:
 1868 02bb 55415254 		.ascii	"UART_GetTxBufferSize\000"
 1868      5F476574 
 1868      54784275 
 1868      66666572 
 1868      53697A65 
 1869              	.LASF16:
 1870 02d0 73697A65 		.ascii	"sizetype\000"
 1870      74797065 
 1870      00
 1871              	.LASF27:
 1872 02d9 74784461 		.ascii	"txDataByte\000"
 1872      74614279 
 1872      746500
 1873              	.LASF14:
 1874 02e4 63686172 		.ascii	"char\000"
 1874      00
 1875              	.LASF40:
ARM GAS  C:\Users\nm\AppData\Local\Temp\ccoWRftX.s 			page 64


 1876 02e9 7265744D 		.ascii	"retMode\000"
 1876      6F646500 
 1877              	.LASF2:
 1878 02f1 73686F72 		.ascii	"short int\000"
 1878      7420696E 
 1878      7400
 1879              	.LASF38:
 1880 02fb 55415254 		.ascii	"UART_ClearTxBuffer\000"
 1880      5F436C65 
 1880      61725478 
 1880      42756666 
 1880      657200
 1881              	.LASF9:
 1882 030e 75696E74 		.ascii	"uint8\000"
 1882      3800
 1883              	.LASF24:
 1884 0314 636F6E74 		.ascii	"control\000"
 1884      726F6C00 
 1885              	.LASF4:
 1886 031c 6C6F6E67 		.ascii	"long int\000"
 1886      20696E74 
 1886      00
 1887              	.LASF0:
 1888 0325 7369676E 		.ascii	"signed char\000"
 1888      65642063 
 1888      68617200 
 1889              	.LASF31:
 1890 0331 55415254 		.ascii	"UART_PutString\000"
 1890      5F507574 
 1890      53747269 
 1890      6E6700
 1891              	.LASF37:
 1892 0340 73697A65 		.ascii	"size\000"
 1892      00
 1893              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
