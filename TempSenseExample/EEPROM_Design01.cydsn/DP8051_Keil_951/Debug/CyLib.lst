C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE CYLIB
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\CyLib.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\
                    -DP8051_Keil_951\Debug/CyLib.lst) CD OT(3,SPEED) OJ(.\DP8051_Keil_951\Debug\CyLib.obj)

line level    source

*** WARNING C500 IN LINE 1 OF .\Generated_Source\PSoC3\CyLib.c: INCORRECT LICENSE ID CODE (LIC) IN 'TOOLS.INI'
   1          /*******************************************************************************
   2          * File Name: CyLib.c
   3          * Version 5.30
   4          *
   5          *  Description:
   6          *   Provides a system API for the clocking, interrupts and watchdog timer.
   7          *
   8          *  Note:
   9          *   Documentation of the API's in this file is located in the
  10          *   System Reference Guide provided with PSoC Creator.
  11          *
  12          ********************************************************************************
  13          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  14          * You may use this file only in accordance with the license, terms, conditions,
  15          * disclaimers, and limitations in the end user license agreement accompanying
  16          * the software package with which this file was provided.
  17          *******************************************************************************/
  18          
  19          #include "CyLib.h"
  20          
  21          
  22          /*******************************************************************************
  23          * The CyResetStatus variable is used to obtain value of RESET_SR0 register after
  24          * a device reset. It is set from initialize_psoc() at the early initialization
  25          * stage. In case of IAR EW IDE, initialize_psoc() is executed before the data
  26          * sections are initialized. To avoid zeroing, CyResetStatus should be placed
  27          * to the .noinit section.
  28          *******************************************************************************/
  29          CY_NOINIT uint8 CYXDATA CyResetStatus;
  30          
  31          
  32          /* Variable Vdda */
  33          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  uint8 CyScPumpEnabled = (uint8)(CYDEV_VDDA_MV < 2700);
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
  38          
  39          
  40          /* Do not use these definitions directly in your application */
  41          uint32 cydelay_freq_hz  = BCLK__BUS_CLK__HZ;
  42          uint32 cydelay_freq_khz = (BCLK__BUS_CLK__HZ + 999u) / 1000u;
  43          uint8  cydelay_freq_mhz = (uint8)((BCLK__BUS_CLK__HZ + 999999u) / 1000000u);
  44          uint32 cydelay_32k_ms   = 32768u * ((BCLK__BUS_CLK__HZ + 999u) / 1000u);
  45          
  46          
  47          /* Function Prototypes */
  48          static uint8 CyUSB_PowerOnCheck(void)  ;
  49          static void CyIMO_SetTrimValue(uint8 freq) ;
  50          static void CyBusClk_Internal_SetDivider(uint16 divider);
  51          
  52          #if(CY_PSOC5)
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 2   

                  static cySysTickCallback CySysTickCallbacks[CY_SYS_SYST_NUM_OF_CALLBACKS];
                  static void CySysTickServiceCallbacks(void);
                  uint32 CySysTickInitVar = 0u;
              #endif  /* (CY_PSOC5) */
  57          
  58          
  59          #if(CY_PSOC3)
  60              CY_ISR_PROTO(IntDefaultHandler);
  61          #endif /* (CY_PSOC3) */
  62          
  63          
  64          /*******************************************************************************
  65          * Function Name: CyPLL_OUT_Start
  66          ********************************************************************************
  67          *
  68          * Summary:
  69          *   Enables the PLL.  Optionally waits for it to become stable.
  70          *   Waits at least 250 us or until it is detected that the PLL is stable.
  71          *
  72          * Parameters:
  73          *   wait:
  74          *    0: Return immediately after configuration
  75          *    1: Wait for PLL lock or timeout.
  76          *
  77          * Return:
  78          *   Status
  79          *    CYRET_SUCCESS - Completed successfully
  80          *    CYRET_TIMEOUT - Timeout occurred without detecting a stable clock.
  81          *     If the input source of the clock is jittery, then the lock indication
  82          *     may not occur.  However, after the timeout has expired the generated PLL
  83          *     clock can still be used.
  84          *
  85          * Side Effects:
  86          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
  87          *  Any other use of the Fast Time Wheel will be stopped during the period of
  88          *  this function and then restored. This function also uses the 100 KHz ILO.
  89          *  If not enabled, this function will enable the 100 KHz ILO for the period of
  90          *  this function.
  91          *
  92          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
  93          *  Once Per Second interrupt may be made by interrupt routines during the period
  94          *  of this function execution. The current operation of the ILO, Central Time
  95          *  Wheel and Once Per Second interrupt are maintained during the operation of
  96          *  this function provided the reading of the Power Manager Interrupt Status
  97          *  Register is only done using the CyPmReadStatus() function.
  98          *
  99          *******************************************************************************/
 100          cystatus CyPLL_OUT_Start(uint8 wait) 
 101          {
 102   1          cystatus status = CYRET_SUCCESS;
 103   1      
 104   1          uint8 iloEnableState;
 105   1          uint8 pmTwCfg0State;
 106   1          uint8 pmTwCfg2State;
 107   1      
 108   1      
 109   1          /* Enables PLL circuit  */
 110   1          CY_CLK_PLL_CFG0_REG |= CY_CLK_PLL_ENABLE;
 111   1      
 112   1          if(wait != 0u)
 113   1          {
 114   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 3   

 115   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 116   2              pmTwCfg0State = CY_LIB_PM_TW_CFG0_REG;
 117   2              pmTwCfg2State = CY_LIB_PM_TW_CFG2_REG;
 118   2      
 119   2              CyPmFtwSetInterval(CY_CLK_PLL_FTW_INTERVAL);
 120   2      
 121   2              status = CYRET_TIMEOUT;
 122   2      
 123   2              while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 124   2              {
 125   3                  /* Wait for interrupt status */
 126   3                  if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 127   3                  {
 128   4                      if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 129   4                      {
 130   5                          status = CYRET_SUCCESS;
 131   5                          break;
 132   5                      }
 133   4                  }
 134   3              }
 135   2      
 136   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
 137   2              if(0u == iloEnableState)
 138   2              {
 139   3                  CyILO_Stop100K();
 140   3              }
 141   2      
 142   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0State;
 143   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2State;
 144   2          }
 145   1      
 146   1          return(status);
 147   1      }
 148          
 149          
 150          /*******************************************************************************
 151          * Function Name: CyPLL_OUT_Stop
 152          ********************************************************************************
 153          *
 154          * Summary:
 155          *  Disables the PLL.
 156          *
 157          * Parameters:
 158          *  None
 159          *
 160          * Return:
 161          *  None
 162          *
 163          *******************************************************************************/
 164          void CyPLL_OUT_Stop(void) 
 165          {
 166   1          CY_CLK_PLL_CFG0_REG &= ((uint8)(~CY_CLK_PLL_ENABLE));
 167   1      }
 168          
 169          
 170          /*******************************************************************************
 171          * Function Name: CyPLL_OUT_SetPQ
 172          ********************************************************************************
 173          *
 174          * Summary:
 175          *  Sets the P and Q dividers and the charge pump current.
 176          *  The Frequency Out will be P/Q * Frequency In.
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 4   

 177          *  The PLL must be disabled before calling this function.
 178          *
 179          * Parameters:
 180          *  uint8 pDiv:
 181          *   Valid range [8 - 255].
 182          *
 183          *  uint8 qDiv:
 184          *   Valid range [1 - 16]. Input Frequency / Q must be in range of 1 to 3 MHz.
 185          
 186          *  uint8 current:
 187          *   Valid range [1 - 7]. Charge pump current in uA. Refer to the device TRM and
 188          *   datasheet for more information.
 189          *
 190          * Return:
 191          *  None
 192          *
 193          * Side Effects:
 194          *  If this function execution results in the CPU clock frequency increasing,
 195          *  then the number of clock cycles the cache will wait before it samples data
 196          *  coming back from the Flash must be adjusted by calling
 197          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 198          *  called if the CPU clock frequency is lowered in order to improve the CPU
 199          *  performance. See CyFlash_SetWaitCycles() description for more information.
 200          *
 201          *******************************************************************************/
 202          void CyPLL_OUT_SetPQ(uint8 pDiv, uint8 qDiv, uint8 current) 
 203          {
 204   1          /* Halt CPU in debug mode if PLL is enabled */
 205   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 206   1      
 207   1          if((pDiv    >= CY_CLK_PLL_MIN_P_VALUE  ) &&
 208   1             (qDiv    <= CY_CLK_PLL_MAX_Q_VALUE  ) && (qDiv    >= CY_CLK_PLL_MIN_Q_VALUE  ) &&
 209   1             (current >= CY_CLK_PLL_MIN_CUR_VALUE) && (current <= CY_CLK_PLL_MAX_CUR_VALUE))
 210   1          {
 211   2              /* Set new values */
 212   2              CY_CLK_PLL_P_REG = pDiv;
 213   2              CY_CLK_PLL_Q_REG = ((uint8)(qDiv - 1u));
 214   2              CY_CLK_PLL_CFG1_REG = (CY_CLK_PLL_CFG1_REG & CY_CLK_PLL_CURRENT_MASK) |
 215   2                                      ((uint8)(((uint8)(current - 1u)) << CY_CLK_PLL_CURRENT_POSITION));
 216   2          }
 217   1          else
 218   1          {
 219   2              /***********************************************************************
 220   2              * Halt CPU in debug mode if:
 221   2              * - P divider is less than required
 222   2              * - Q divider is out of range
 223   2              * - pump current is out of range
 224   2              ***********************************************************************/
 225   2              CYASSERT(0u != 0u);
 226   2          }
 227   1      
 228   1      }
 229          
 230          
 231          /*******************************************************************************
 232          * Function Name: CyPLL_OUT_SetSource
 233          ********************************************************************************
 234          *
 235          * Summary:
 236          *  Sets the input clock source to the PLL. The PLL must be disabled before
 237          *  calling this function.
 238          *
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 5   

 239          * Parameters:
 240          *   source: One of the three available PLL clock sources
 241          *    CY_PLL_SOURCE_IMO  :   IMO
 242          *    CY_PLL_SOURCE_XTAL :   MHz Crystal
 243          *    CY_PLL_SOURCE_DSI  :   DSI
 244          *
 245          * Return:
 246          *  None
 247          *
 248          * Side Effects:
 249          *  If this function execution results in the CPU clock frequency increasing,
 250          *  then the number of clock cycles the cache will wait before it samples data
 251          *  coming back from the3 Flash must be adjusted by calling
 252          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 253          *  called if the CPU clock frequency is lowered in order to improve the CPU
 254          *  performance. See CyFlash_SetWaitCycles() description for more information.
 255          *
 256          *******************************************************************************/
 257          void CyPLL_OUT_SetSource(uint8 source) 
 258          {
 259   1          /* Halt CPU in debug mode if PLL is enabled */
 260   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 261   1      
 262   1          switch(source)
 263   1          {
 264   2              case CY_PLL_SOURCE_IMO:
 265   2              case CY_PLL_SOURCE_XTAL:
 266   2              case CY_PLL_SOURCE_DSI:
 267   2                  CY_LIB_CLKDIST_CR_REG = ((CY_LIB_CLKDIST_CR_REG & CY_LIB_CLKDIST_CR_PLL_SCR_MASK) | source);
 268   2              break;
 269   2      
 270   2              default:
 271   2                  CYASSERT(0u != 0u);
 272   2              break;
 273   2          }
 274   1      }
 275          
 276          
 277          /*******************************************************************************
 278          * Function Name: CyIMO_Start
 279          ********************************************************************************
 280          *
 281          * Summary:
 282          *  Enables the IMO. Optionally waits at least 6 us for it to settle.
 283          *
 284          * Parameters:
 285          *  uint8 wait:
 286          *   0: Return immediately after configuration
 287          *   1: Wait for at least 6 us for the IMO to settle.
 288          *
 289          * Return:
 290          *  None
 291          *
 292          * Side Effects:
 293          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
 294          *  Any other use of the Fast Time Wheel will be stopped during the period of
 295          *  this function and then restored. This function also uses the 100 KHz ILO.
 296          *  If not enabled, this function will enable the 100 KHz ILO for the period of
 297          *  this function.
 298          *
 299          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
 300          *  Once Per Second interrupt may be made by interrupt routines during the period
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 6   

 301          *  of this function execution. The current operation of the ILO, Central Time
 302          *  Wheel and Once Per Second interrupt are maintained during the operation of
 303          *  this function provided the reading of the Power Manager Interrupt Status
 304          *  Register is only done using the CyPmReadStatus() function.
 305          *
 306          *******************************************************************************/
 307          void CyIMO_Start(uint8 wait) 
 308          {
 309   1          uint8 pmFtwCfg2Reg;
 310   1          uint8 pmFtwCfg0Reg;
 311   1          uint8 ilo100KhzEnable;
 312   1      
 313   1      
 314   1          CY_LIB_PM_ACT_CFG0_REG  |= CY_LIB_PM_ACT_CFG0_IMO_EN;
 315   1          CY_LIB_PM_STBY_CFG0_REG |= CY_LIB_PM_STBY_CFG0_IMO_EN;
 316   1      
 317   1          if(0u != wait)
 318   1          {
 319   2              /* Need to turn on 100KHz ILO if it happens to not already be running.*/
 320   2              ilo100KhzEnable = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 321   2              pmFtwCfg0Reg = CY_LIB_PM_TW_CFG0_REG;
 322   2              pmFtwCfg2Reg = CY_LIB_PM_TW_CFG2_REG;
 323   2      
 324   2              CyPmFtwSetInterval(CY_LIB_CLK_IMO_FTW_TIMEOUT);
 325   2      
 326   2              while (0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 327   2              {
 328   3                  /* Wait for interrupt status */
 329   3              }
 330   2      
 331   2              if(0u == ilo100KhzEnable)
 332   2              {
 333   3                  CyILO_Stop100K();
 334   3              }
 335   2      
 336   2              CY_LIB_PM_TW_CFG0_REG = pmFtwCfg0Reg;
 337   2              CY_LIB_PM_TW_CFG2_REG = pmFtwCfg2Reg;
 338   2          }
 339   1      }
 340          
 341          
 342          /*******************************************************************************
 343          * Function Name: CyIMO_Stop
 344          ********************************************************************************
 345          *
 346          * Summary:
 347          *   Disables the IMO.
 348          *
 349          * Parameters:
 350          *  None
 351          *
 352          * Return:
 353          *  None
 354          *
 355          *******************************************************************************/
 356          void CyIMO_Stop(void) 
 357          {
 358   1          CY_LIB_PM_ACT_CFG0_REG  &= ((uint8) (~CY_LIB_PM_ACT_CFG0_IMO_EN));
 359   1          CY_LIB_PM_STBY_CFG0_REG &= ((uint8) (~CY_LIB_PM_STBY_CFG0_IMO_EN));
 360   1      }
 361          
 362          
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 7   

 363          /*******************************************************************************
 364          * Function Name: CyUSB_PowerOnCheck
 365          ********************************************************************************
 366          *
 367          * Summary:
 368          *  Returns the USB power status value. A private function to cy_boot.
 369          *
 370          * Parameters:
 371          *   None
 372          *
 373          * Return:
 374          *   uint8: one if the USB is enabled, 0 if not enabled.
 375          *
 376          *******************************************************************************/
 377          static uint8 CyUSB_PowerOnCheck(void)  
 378          {
 379   1          uint8 poweredOn = 0u;
 380   1      
 381   1          /* Check whether device is in Active or AltActive and if USB is powered on */
 382   1          if((((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ACTIVE ) &&
 383   1             (0u != (CY_LIB_PM_ACT_CFG5_REG & CY_ACT_USB_ENABLED     )))  ||
 384   1             (((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ALT_ACT) &&
 385   1             (0u != (CY_LIB_PM_STBY_CFG5_REG & CY_ALT_ACT_USB_ENABLED))))
 386   1          {
 387   2              poweredOn = 1u;
 388   2          }
 389   1      
 390   1          return (poweredOn);
 391   1      }
 392          
 393          
 394          /*******************************************************************************
 395          * Function Name: CyIMO_SetTrimValue
 396          ********************************************************************************
 397          *
 398          * Summary:
 399          *  Sets the IMO factory trim values.
 400          *
 401          * Parameters:
 402          *  uint8 freq - frequency for which trims must be set
 403          *
 404          * Return:
 405          *  None
 406          *
 407          *******************************************************************************/
 408          static void CyIMO_SetTrimValue(uint8 freq) 
 409          {
 410   1          uint8 usbPowerOn = CyUSB_PowerOnCheck();
 411   1      
 412   1          /* If USB is powered */
 413   1          if(usbPowerOn == 1u)
 414   1          {
 415   2              /* Unlock USB write */
 416   2              CY_LIB_USB_CR1_REG &= ((uint8)(~CY_LIB_USB_CLK_EN));
 417   2          }
 418   1          switch(freq)
 419   1          {
 420   2          case CY_IMO_FREQ_3MHZ:
 421   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_3MHZ_PTR);
 422   2              break;
 423   2      
 424   2          case CY_IMO_FREQ_6MHZ:
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 8   

 425   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_6MHZ_PTR);
 426   2              break;
 427   2      
 428   2          case CY_IMO_FREQ_12MHZ:
 429   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_12MHZ_PTR);
 430   2              break;
 431   2      
 432   2          case CY_IMO_FREQ_24MHZ:
 433   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_24MHZ_PTR);
 434   2              break;
 435   2      
 436   2          case CY_IMO_FREQ_48MHZ:
 437   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_TR1_PTR);
 438   2              break;
 439   2      
 440   2          case CY_IMO_FREQ_62MHZ:
 441   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_67MHZ_PTR);
 442   2              break;
 443   2      
 444   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_80MHZ_PTR);
                      break;
              #endif  /* (CY_PSOC5) */
 449   2      
 450   2          case CY_IMO_FREQ_USB:
 451   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_USB_PTR);
 452   2      
 453   2              /* If USB is powered */
 454   2              if(usbPowerOn == 1u)
 455   2              {
 456   3                  /* Lock USB Oscillator */
 457   3                  CY_LIB_USB_CR1_REG |= CY_LIB_USB_CLK_EN;
 458   3              }
 459   2              break;
 460   2      
 461   2          default:
 462   2                  CYASSERT(0u != 0u);
 463   2              break;
 464   2          }
 465   1      
 466   1      }
 467          
 468          
 469          /*******************************************************************************
 470          * Function Name: CyIMO_SetFreq
 471          ********************************************************************************
 472          *
 473          * Summary:
 474          *  Sets the frequency of the IMO. Changes may be made while the IMO is running.
 475          *
 476          * Parameters:
 477          *  freq: Frequency of IMO operation
 478          *       CY_IMO_FREQ_3MHZ  to set  3   MHz
 479          *       CY_IMO_FREQ_6MHZ  to set  6   MHz
 480          *       CY_IMO_FREQ_12MHZ to set 12   MHz
 481          *       CY_IMO_FREQ_24MHZ to set 24   MHz
 482          *       CY_IMO_FREQ_48MHZ to set 48   MHz
 483          *       CY_IMO_FREQ_62MHZ to set 62.6 MHz
 484          *       CY_IMO_FREQ_74MHZ to set 74.7 MHz (not applicable for PSoC 3)
 485          *       CY_IMO_FREQ_USB   to set 24   MHz (Trimmed for USB operation)
 486          *
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 9   

 487          * Return:
 488          *  None
 489          *
 490          * Side Effects:
 491          *  If this function execution results in the CPU clock frequency increasing,
 492          *  then the number of clock cycles the cache will wait before it samples data
 493          *  coming back from the Flash must be adjusted by calling
 494          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 495          *  called if the CPU clock frequency is lowered in order to improve the CPU
 496          *  performance. See CyFlash_SetWaitCycles() description for more information.
 497          *
 498          *  When the USB setting is chosen, the USB clock locking circuit is enabled.
 499          *  Otherwise this circuit is disabled. The USB block must be powered before
 500          *  selecting the USB setting.
 501          *
 502          *******************************************************************************/
 503          void CyIMO_SetFreq(uint8 freq) 
 504          {
 505   1          uint8 currentFreq;
 506   1          uint8 nextFreq;
 507   1      
 508   1          /***************************************************************************
 509   1          * If the IMO frequency is changed,the Trim values must also be set
 510   1          * accordingly.This requires reading the current frequency. If the new
 511   1          * frequency is faster, then set a new trim and then change the frequency,
 512   1          * otherwise change the frequency and then set new trim values.
 513   1          ***************************************************************************/
 514   1      
 515   1          currentFreq = CY_LIB_FASTCLK_IMO_CR_REG & ((uint8)(~CY_LIB_FASTCLK_IMO_CR_RANGE_MASK));
 516   1      
 517   1          /* Check if requested frequency is USB. */
 518   1          nextFreq = (freq == CY_IMO_FREQ_USB) ? CY_IMO_FREQ_24MHZ : freq;
 519   1      
 520   1          switch (currentFreq)
 521   1          {
 522   2          case 0u:
 523   2              currentFreq = CY_IMO_FREQ_12MHZ;
 524   2              break;
 525   2      
 526   2          case 1u:
 527   2              currentFreq = CY_IMO_FREQ_6MHZ;
 528   2              break;
 529   2      
 530   2          case 2u:
 531   2              currentFreq = CY_IMO_FREQ_24MHZ;
 532   2              break;
 533   2      
 534   2          case 3u:
 535   2              currentFreq = CY_IMO_FREQ_3MHZ;
 536   2              break;
 537   2      
 538   2          case 4u:
 539   2              currentFreq = CY_IMO_FREQ_48MHZ;
 540   2              break;
 541   2      
 542   2          case 5u:
 543   2              currentFreq = CY_IMO_FREQ_62MHZ;
 544   2              break;
 545   2      
 546   2      #if(CY_PSOC5)
                  case 6u:
                      currentFreq = CY_IMO_FREQ_74MHZ;
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 10  

                      break;
              #endif  /* (CY_PSOC5) */
 551   2      
 552   2          default:
 553   2              CYASSERT(0u != 0u);
 554   2              break;
 555   2          }
 556   1      
 557   1          if (nextFreq >= currentFreq)
 558   1          {
 559   2              /* Set new trim first */
 560   2              CyIMO_SetTrimValue(freq);
 561   2          }
 562   1      
 563   1          /* Set usbclk_on bit when using CY_IMO_FREQ_USB, if not clear it */
 564   1          switch(freq)
 565   1          {
 566   2          case CY_IMO_FREQ_3MHZ:
 567   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 568   2                  CY_LIB_IMO_3MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 569   2              break;
 570   2      
 571   2          case CY_IMO_FREQ_6MHZ:
 572   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 573   2                  CY_LIB_IMO_6MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 574   2              break;
 575   2      
 576   2          case CY_IMO_FREQ_12MHZ:
 577   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 578   2                  CY_LIB_IMO_12MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 579   2              break;
 580   2      
 581   2          case CY_IMO_FREQ_24MHZ:
 582   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 583   2                  CY_LIB_IMO_24MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 584   2              break;
 585   2      
 586   2          case CY_IMO_FREQ_48MHZ:
 587   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 588   2                  CY_LIB_IMO_48MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 589   2              break;
 590   2      
 591   2          case CY_IMO_FREQ_62MHZ:
 592   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 593   2                  CY_LIB_IMO_62MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 594   2              break;
 595   2      
 596   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
                          CY_LIB_IMO_74MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
                      break;
              #endif  /* (CY_PSOC5) */
 602   2      
 603   2          case CY_IMO_FREQ_USB:
 604   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 605   2                  CY_LIB_IMO_24MHZ_VALUE) | CY_LIB_IMO_USBCLK_ON_SET;
 606   2              break;
 607   2      
 608   2          default:
 609   2              CYASSERT(0u != 0u);
 610   2              break;
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 11  

 611   2          }
 612   1      
 613   1          /* Tu rn onIMO Doubler, if switching to CY_IMO_FREQ_USB */
 614   1          if (freq == CY_IMO_FREQ_USB)
 615   1          {
 616   2              CyIMO_EnableDoubler();
 617   2          }
 618   1          else
 619   1          {
 620   2              CyIMO_DisableDoubler();
 621   2          }
 622   1      
 623   1          if (nextFreq < currentFreq)
 624   1          {
 625   2              /* Set the trim after setting frequency */
 626   2              CyIMO_SetTrimValue(freq);
 627   2          }
 628   1      }
 629          
 630          
 631          /*******************************************************************************
 632          * Function Name: CyIMO_SetSource
 633          ********************************************************************************
 634          *
 635          * Summary:
 636          *  Sets the source of the clock output from the IMO block.
 637          *
 638          *  The output from the IMO is by default the IMO itself. Optionally the MHz
 639          *  Crystal or DSI input can be the source of the IMO output instead.
 640          *
 641          * Parameters:
 642          *   source: CY_IMO_SOURCE_DSI to set the DSI as source.
 643          *           CY_IMO_SOURCE_XTAL to set the MHz as source.
 644          *           CY_IMO_SOURCE_IMO to set the IMO itself.
 645          *
 646          * Return:
 647          *  None
 648          *
 649          * Side Effects:
 650          *  If this function execution resulted in the CPU clock frequency increasing,
 651          *  then the number of clock cycles the cache will wait before it samples data
 652          *  coming back from the Flash must be adjusted by calling
 653          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 654          *  called if the CPU clock frequency is lowered in order to improve the CPU
 655          *  performance. See CyFlash_SetWaitCycles() description for more information.
 656          *
 657          *******************************************************************************/
 658          void CyIMO_SetSource(uint8 source) 
 659          {
 660   1          switch(source)
 661   1          {
 662   2          case CY_IMO_SOURCE_DSI:
 663   2              CY_LIB_CLKDIST_CR_REG     &= ((uint8)(~CY_LIB_CLKDIST_CR_IMO2X));
 664   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 665   2              break;
 666   2      
 667   2          case CY_IMO_SOURCE_XTAL:
 668   2              CY_LIB_CLKDIST_CR_REG     |= CY_LIB_CLKDIST_CR_IMO2X;
 669   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 670   2              break;
 671   2      
 672   2          case CY_IMO_SOURCE_IMO:
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 12  

 673   2              CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_IMO));
 674   2              break;
 675   2      
 676   2          default:
 677   2              /* Incorrect source value */
 678   2              CYASSERT(0u != 0u);
 679   2              break;
 680   2          }
 681   1      }
 682          
 683          
 684          /*******************************************************************************
 685          * Function Name: CyIMO_EnableDoubler
 686          ********************************************************************************
 687          *
 688          * Summary:
 689          *  Enables the IMO doubler.  The 2x frequency clock is used to convert a 24 MHz
 690          *  input to a 48 MHz output for use by the USB block.
 691          *
 692          * Parameters:
 693          *  None
 694          *
 695          * Return:
 696          *  None
 697          *
 698          *******************************************************************************/
 699          void CyIMO_EnableDoubler(void) 
 700          {
 701   1          /* Set FASTCLK_IMO_CR_PTR regigster's 4th bit */
 702   1          CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_DOUBLER;
 703   1      }
 704          
 705          
 706          /*******************************************************************************
 707          * Function Name: CyIMO_DisableDoubler
 708          ********************************************************************************
 709          *
 710          * Summary:
 711          *   Disables the IMO doubler.
 712          *
 713          * Parameters:
 714          *  None
 715          *
 716          * Return:
 717          *  None
 718          *
 719          *******************************************************************************/
 720          void CyIMO_DisableDoubler(void) 
 721          {
 722   1          CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_DOUBLER));
 723   1      }
 724          
 725          
 726          /*******************************************************************************
 727          * Function Name: CyMasterClk_SetSource
 728          ********************************************************************************
 729          *
 730          * Summary:
 731          *  Sets the source of the master clock.
 732          *
 733          * Parameters:
 734          *   source: One of the four available Master clock sources.
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 13  

 735          *     CY_MASTER_SOURCE_IMO
 736          *     CY_MASTER_SOURCE_PLL
 737          *     CY_MASTER_SOURCE_XTAL
 738          *     CY_MASTER_SOURCE_DSI
 739          *
 740          * Return:
 741          *  None
 742          *
 743          * Side Effects:
 744          *  The current source and the new source must both be running and stable before
 745          *  calling this function.
 746          *
 747          *  If this function execution resulted in the CPU clock frequency increasing,
 748          *  then the number of clock cycles the cache will wait before it samples data
 749          *  coming back from the Flash must be adjusted by calling
 750          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 751          *  called if the CPU clock frequency is lowered in order to improve the CPU
 752          *  performance. See CyFlash_SetWaitCycles() description for more information.
 753          *
 754          *******************************************************************************/
 755          void CyMasterClk_SetSource(uint8 source) 
 756          {
 757   1          CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & MASTER_CLK_SRC_CLEAR) |
 758   1                                      (source & ((uint8)(~MASTER_CLK_SRC_CLEAR)));
 759   1      }
 760          
 761          
 762          /*******************************************************************************
 763          * Function Name: CyMasterClk_SetDivider
 764          ********************************************************************************
 765          *
 766          * Summary:
 767          *  Sets the divider value used to generate Master Clock.
 768          *
 769          * Parameters:
 770          *  uint8 divider:
 771          *   The valid range is [0-255]. The clock will be divided by this value + 1.
 772          *   For example to divide this parameter by two should be set to 1.
 773          *
 774          * Return:
 775          *  None
 776          *
 777          * Side Effects:
 778          *  If this function execution resulted in the CPU clock frequency increasing,
 779          *  then the number of clock cycles the cache will wait before it samples data
 780          *  coming back from the Flash must be adjusted by calling
 781          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 782          *  called if the CPU clock frequency is lowered in order to improve the CPU
 783          *  performance. See CyFlash_SetWaitCycles() description for more information.
 784          *
 785          *  When changing the Master or Bus clock divider value from div-by-n to div-by-1
 786          *  the first clock cycle output after the div-by-1 can be up to 4 ns shorter
 787          *  than the final/expected div-by-1 period.
 788          *
 789          *******************************************************************************/
 790          void CyMasterClk_SetDivider(uint8 divider) 
 791          {
 792   1          CY_LIB_CLKDIST_MSTR0_REG = divider;
 793   1      }
 794          
 795          
 796          /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 14  

 797          * Function Name: CyBusClk_Internal_SetDivider
 798          ********************************************************************************
 799          *
 800          * Summary:
 801          *  The function used by CyBusClk_SetDivider(). For internal use only.
 802          *
 803          * Parameters:
 804          *   divider: Valid range [0-65535].
 805          *   The clock will be divided by this value + 1.
 806          *   For example, to divide this parameter by two should be set to 1.
 807          *
 808          * Return:
 809          *  None
 810          *
 811          *******************************************************************************/
 812          static void CyBusClk_Internal_SetDivider(uint16 divider)
 813          {
 814   1          /* Mask bits to enable shadow loads  */
 815   1          CY_LIB_CLKDIST_AMASK_REG &= CY_LIB_CLKDIST_AMASK_MASK;
 816   1          CY_LIB_CLKDIST_DMASK_REG  = CY_LIB_CLKDIST_DMASK_MASK;
 817   1      
 818   1          /* Enable mask bits to enable shadow loads */
 819   1          CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_MASK;
 820   1      
 821   1          /* Update Shadow Divider Value Register with new divider */
 822   1          CY_LIB_CLKDIST_WRK_LSB_REG = LO8(divider);
 823   1          CY_LIB_CLKDIST_WRK_MSB_REG = HI8(divider);
 824   1      
 825   1      
 826   1          /***************************************************************************
 827   1          * Copy shadow value defined in Shadow Divider Value Register
 828   1          * (CY_LIB_CLKDIST_WRK_LSB_REG and CY_LIB_CLKDIST_WRK_MSB_REG) to all
 829   1          * dividers selected in Analog and Digital Clock Mask Registers
 830   1          * (CY_LIB_CLKDIST_AMASK_REG and CY_LIB_CLKDIST_DMASK_REG).
 831   1          ***************************************************************************/
 832   1          CY_LIB_CLKDIST_LD_REG |= CY_LIB_CLKDIST_LD_LOAD;
 833   1      }
 834          
 835          
 836          /*******************************************************************************
 837          * Function Name: CyBusClk_SetDivider
 838          ********************************************************************************
 839          *
 840          * Summary:
 841          *  Sets the divider value used to generate the Bus Clock.
 842          *
 843          * Parameters:
 844          *  divider: Valid range [0-65535]. The clock will be divided by this value + 1.
 845          *  For example, to divide this parameter by two should be set to 1.
 846          *
 847          * Return:
 848          *  None
 849          *
 850          * Side Effects:
 851          *  If this function execution resulted in the CPU clock frequency increasing,
 852          *  then the number of clock cycles the cache will wait before it samples data
 853          *  coming back from the Flash must be adjusted by calling
 854          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 855          *  called if the CPU clock frequency is lowered in order to improve the CPU
 856          *  performance. See CyFlash_SetWaitCycles() description for more information.
 857          *
 858          *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 15  

 859          void CyBusClk_SetDivider(uint16 divider) 
 860          {
 861   1          uint8  masterClkDiv;
 862   1          uint16 busClkDiv;
 863   1          uint8 interruptState;
 864   1      
 865   1          interruptState = CyEnterCriticalSection();
 866   1      
 867   1          /* Work around to set bus clock divider value */
 868   1          busClkDiv = (uint16)((uint16)CY_LIB_CLKDIST_BCFG_MSB_REG << 8u);
 869   1          busClkDiv |= CY_LIB_CLKDIST_BCFG_LSB_REG;
 870   1      
 871   1          if ((divider == 0u) || (busClkDiv == 0u))
 872   1          {
 873   2              /* Save away master clock divider value */
 874   2              masterClkDiv = CY_LIB_CLKDIST_MSTR0_REG;
 875   2      
 876   2              if (masterClkDiv < CY_LIB_CLKDIST_MASTERCLK_DIV)
 877   2              {
 878   3                  /* Set master clock divider to 7 */
 879   3                  CyMasterClk_SetDivider(CY_LIB_CLKDIST_MASTERCLK_DIV);
 880   3              }
 881   2      
 882   2              if (divider == 0u)
 883   2              {
 884   3                  /* Set SSS bit and divider register desired value */
 885   3                  CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_SSS;
 886   3                  CyBusClk_Internal_SetDivider(divider);
 887   3              }
 888   2              else
 889   2              {
 890   3                  CyBusClk_Internal_SetDivider(divider);
 891   3                  CY_LIB_CLKDIST_BCFG2_REG &= ((uint8)(~CY_LIB_CLKDIST_BCFG2_SSS));
 892   3              }
 893   2      
 894   2              /* Restore master clock */
 895   2              CyMasterClk_SetDivider(masterClkDiv);
 896   2          }
 897   1          else
 898   1          {
 899   2              CyBusClk_Internal_SetDivider(divider);
 900   2          }
 901   1      
 902   1          CyExitCriticalSection(interruptState);
 903   1      }
 904          
 905          
 906          #if(CY_PSOC3)
 907          
 908              /*******************************************************************************
 909              * Function Name: CyCpuClk_SetDivider
 910              ********************************************************************************
 911              *
 912              * Summary:
 913              *  Sets the divider value used to generate the CPU Clock. Only applicable for
 914              *  PSoC 3 parts.
 915              *
 916              * Parameters:
 917              *  divider: Valid range [0-15]. The clock will be divided by this value + 1.
 918              *  For example, to divide this parameter by two should be set to 1.
 919              *
 920              * Return:
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 16  

 921              *  None
 922              *
 923              * Side Effects:
 924              *  If this function execution resulted in the CPU clock frequency increasing,
 925              *  then the number of clock cycles the cache will wait before it samples data
 926              *  coming back from the Flash must be adjusted by calling
 927              *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 928              *  called if the CPU clock frequency is lowered in order to improve the CPU
 929              *  performance. See CyFlash_SetWaitCycles() description for more information.
 930              *
 931              *******************************************************************************/
 932              void CyCpuClk_SetDivider(uint8 divider) 
 933              {
 934   1                  CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & CY_LIB_CLKDIST_MSTR1_DIV_MASK) |
 935   1                                      ((uint8)(divider << CY_LIB_CLKDIST_DIV_POSITION));
 936   1          }
 937          
 938          #endif /* (CY_PSOC3) */
 939          
 940          
 941          /*******************************************************************************
 942          * Function Name: CyUsbClk_SetSource
 943          ********************************************************************************
 944          *
 945          * Summary:
 946          *  Sets the source of the USB clock.
 947          *
 948          * Parameters:
 949          *  source: One of the four available USB clock sources
 950          *    CY_LIB_USB_CLK_IMO2X     - IMO 2x
 951          *    CY_LIB_USB_CLK_IMO       - IMO
 952          *    CY_LIB_USB_CLK_PLL       - PLL
 953          *    CY_LIB_USB_CLK_DSI       - DSI
 954          *
 955          * Return:
 956          *  None
 957          *
 958          *******************************************************************************/
 959          void CyUsbClk_SetSource(uint8 source) 
 960          {
 961   1          CY_LIB_CLKDIST_UCFG_REG = (CY_LIB_CLKDIST_UCFG_REG & ((uint8)(~CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK))) |
 962   1                              (CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK & source);
 963   1      }
 964          
 965          
 966          /*******************************************************************************
 967          * Function Name: CyILO_Start1K
 968          ********************************************************************************
 969          *
 970          * Summary:
 971          *  Enables the ILO 1 KHz oscillator.
 972          *
 973          *  Note The ILO 1 KHz oscillator is always enabled by default, regardless of the
 974          *  selection in the Clock Editor. Therefore, this API is only needed if the
 975          *  oscillator was turned off manually.
 976          *
 977          * Parameters:
 978          *  None
 979          *
 980          * Return:
 981          *  None
 982          *
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 17  

 983          *******************************************************************************/
 984          void CyILO_Start1K(void) 
 985          {
 986   1          /* Set bit 1 of ILO RS */
 987   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ;
 988   1      }
 989          
 990          
 991          /*******************************************************************************
 992          * Function Name: CyILO_Stop1K
 993          ********************************************************************************
 994          *
 995          * Summary:
 996          *  Disables the ILO 1 KHz oscillator.
 997          *
 998          *  Note The ILO 1 KHz oscillator must be enabled if the Sleep or Hibernate low
 999          *  power mode APIs are expected to be used. For more information, refer to the
1000          *  Power Management section of this document.
1001          *
1002          * Parameters:
1003          *  None
1004          *
1005          * Return:
1006          *  None
1007          *
1008          * Side Effects:
1009          *  PSoC5: Stopping the ILO 1 kHz could break the active WDT functionality.
1010          *
1011          *******************************************************************************/
1012          void CyILO_Stop1K(void) 
1013          {
1014   1          /* Clear bit 1 of ILO RS */
1015   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ));
1016   1      }
1017          
1018          
1019          /*******************************************************************************
1020          * Function Name: CyILO_Start100K
1021          ********************************************************************************
1022          *
1023          * Summary:
1024          *  Enables the ILO 100 KHz oscillator.
1025          *
1026          * Parameters:
1027          *  None
1028          *
1029          * Return:
1030          *  None
1031          *
1032          *******************************************************************************/
1033          void CyILO_Start100K(void) 
1034          {
1035   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
1036   1      }
1037          
1038          
1039          /*******************************************************************************
1040          * Function Name: CyILO_Stop100K
1041          ********************************************************************************
1042          *
1043          * Summary:
1044          *  Disables the ILO 100 KHz oscillator.
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 18  

1045          *
1046          * Parameters:
1047          *  None
1048          *
1049          * Return:
1050          *  None
1051          *
1052          *******************************************************************************/
1053          void CyILO_Stop100K(void) 
1054          {
1055   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ));
1056   1      }
1057          
1058          
1059          /*******************************************************************************
1060          * Function Name: CyILO_Enable33K
1061          ********************************************************************************
1062          *
1063          * Summary:
1064          *  Enables the ILO 33 KHz divider.
1065          *
1066          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator,
1067          *  so it must also be running in order to generate the 33 KHz output.
1068          *
1069          * Parameters:
1070          *  None
1071          *
1072          * Return:
1073          *  None
1074          *
1075          *******************************************************************************/
1076          void CyILO_Enable33K(void) 
1077          {
1078   1          /* Set bit 5 of ILO RS */
1079   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ;
1080   1      }
1081          
1082          
1083          /*******************************************************************************
1084          * Function Name: CyILO_Disable33K
1085          ********************************************************************************
1086          *
1087          * Summary:
1088          *  Disables the ILO 33 KHz divider.
1089          *
1090          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator, but this
1091          *  API does not disable the 100 KHz clock.
1092          *
1093          * Parameters:
1094          *  None
1095          *
1096          * Return:
1097          *  None
1098          *
1099          *******************************************************************************/
1100          void CyILO_Disable33K(void) 
1101          {
1102   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ));
1103   1      }
1104          
1105          
1106          /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 19  

1107          * Function Name: CyILO_SetSource
1108          ********************************************************************************
1109          *
1110          * Summary:
1111          *  Sets the source of the clock output from the ILO block.
1112          *
1113          * Parameters:
1114          *  source: One of the three available ILO output sources
1115          *       Value        Define                Source
1116          *       0            CY_ILO_SOURCE_100K    ILO 100 KHz
1117          *       1            CY_ILO_SOURCE_33K     ILO 33 KHz
1118          *       2            CY_ILO_SOURCE_1K      ILO 1 KHz
1119          *
1120          * Return:
1121          *  None
1122          *
1123          *******************************************************************************/
1124          void CyILO_SetSource(uint8 source) 
1125          {
1126   1          CY_LIB_CLKDIST_CR_REG = (CY_LIB_CLKDIST_CR_REG & CY_ILO_SOURCE_BITS_CLEAR) |
1127   1                          (((uint8) (source << 2u)) & ((uint8)(~CY_ILO_SOURCE_BITS_CLEAR)));
1128   1      }
1129          
1130          
1131          /*******************************************************************************
1132          * Function Name: CyILO_SetPowerMode
1133          ********************************************************************************
1134          *
1135          * Summary:
1136          *  Sets the power mode used by the ILO during power down. Allows for lower power
1137          *  down power usage resulting in a slower startup time.
1138          *
1139          * Parameters:
1140          *  uint8 mode
1141          *   CY_ILO_FAST_START - Faster start-up, internal bias left on when powered down
1142          *   CY_ILO_SLOW_START - Slower start-up, internal bias off when powered down
1143          *
1144          * Return:
1145          *   Prevous power mode state.
1146          *
1147          *******************************************************************************/
1148          uint8 CyILO_SetPowerMode(uint8 mode) 
1149          {
1150   1          uint8 state;
1151   1      
1152   1          /* Get current state. */
1153   1          state = CY_LIB_SLOWCLK_ILO_CR0_REG;
1154   1      
1155   1          /* Set the oscillator power mode. */
1156   1          if(mode != CY_ILO_FAST_START)
1157   1          {
1158   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state | CY_ILO_CONTROL_PD_MODE);
1159   2          }
1160   1          else
1161   1          {
1162   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state & ((uint8)(~CY_ILO_CONTROL_PD_MODE)));
1163   2          }
1164   1      
1165   1          /* Return old mode. */
1166   1          return ((state & CY_ILO_CONTROL_PD_MODE) >> CY_ILO_CONTROL_PD_POSITION);
1167   1      }
1168          
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 20  

1169          
1170          /*******************************************************************************
1171          * Function Name: CyXTAL_32KHZ_Start
1172          ********************************************************************************
1173          *
1174          * Summary:
1175          *  Enables the 32 KHz Crystal Oscillator.
1176          *
1177          * Parameters:
1178          *  None
1179          *
1180          * Return:
1181          *  None
1182          *
1183          *******************************************************************************/
1184          void CyXTAL_32KHZ_Start(void) 
1185          {
1186   1          volatile uint16 i;
1187   1      
1188   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1189   1          CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_STARTUP;
1190   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1191   1                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1192   1      
1193   1          #if(CY_PSOC3)
1194   1              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_PDBEN;
1195   1          #endif  /* (CY_PSOC3) */
1196   1      
1197   1          /* Enable operation of 32K Crystal Oscillator */
1198   1          CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_EN;
1199   1      
1200   1          for (i = 1000u; i > 0u; i--)
1201   1          {
1202   2              if(0u != (CyXTAL_32KHZ_ReadStatus() & CY_XTAL32K_ANA_STAT))
1203   2              {
1204   3                  /* Ready - switch to high power mode */
1205   3                  (void) CyXTAL_32KHZ_SetPowerMode(0u);
1206   3      
1207   3                  break;
1208   3              }
1209   2              CyDelayUs(1u);
1210   2          }
1211   1      }
1212          
1213          
1214          /*******************************************************************************
1215          * Function Name: CyXTAL_32KHZ_Stop
1216          ********************************************************************************
1217          *
1218          * Summary:
1219          *  Disables the 32KHz Crystal Oscillator.
1220          *
1221          * Parameters:
1222          *  None
1223          *
1224          * Return:
1225          *  None
1226          *
1227          *******************************************************************************/
1228          void CyXTAL_32KHZ_Stop(void) 
1229          {
1230   1          CY_CLK_XTAL32_TST_REG  = CY_CLK_XTAL32_TST_DEFAULT;
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 21  

1231   1          CY_CLK_XTAL32_TR_REG   = CY_CLK_XTAL32_TR_POWERDOWN;
1232   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1233   1                                   CY_CLK_XTAL32_CFG_LP_DEFAULT;
1234   1          CY_CLK_XTAL32_CR_REG &= ((uint8)(~(CY_CLK_XTAL32_CR_EN | CY_CLK_XTAL32_CR_LPM)));
1235   1      
1236   1          #if(CY_PSOC3)
1237   1              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_PDBEN));
1238   1          #endif  /* (CY_PSOC3) */
1239   1      }
1240          
1241          
1242          /*******************************************************************************
1243          * Function Name: CyXTAL_32KHZ_ReadStatus
1244          ********************************************************************************
1245          *
1246          * Summary:
1247          *  Returns status of the 32 KHz oscillator.
1248          *
1249          * Parameters:
1250          *  None
1251          *
1252          * Return:
1253          *  Value     Define                    Source
1254          *  20        CY_XTAL32K_ANA_STAT       Analog measurement
1255          *                                       1: Stable
1256          *                                       0: Not stable
1257          *
1258          *******************************************************************************/
1259          uint8 CyXTAL_32KHZ_ReadStatus(void) 
1260          {
1261   1          return(CY_CLK_XTAL32_CR_REG & CY_XTAL32K_ANA_STAT);
1262   1      }
1263          
1264          
1265          /*******************************************************************************
1266          * Function Name: CyXTAL_32KHZ_SetPowerMode
1267          ********************************************************************************
1268          *
1269          * Summary:
1270          *  Sets the power mode for the 32 KHz oscillator used during the sleep mode.
1271          *  Allows for lower power during sleep when there are fewer sources of noise.
1272          *  During the active mode the oscillator is always run in the high power mode.
1273          *
1274          * Parameters:
1275          *  uint8 mode
1276          *       0: High power mode
1277          *       1: Low power mode during sleep
1278          *
1279          * Return:
1280          *  Previous power mode.
1281          *
1282          *******************************************************************************/
1283          uint8 CyXTAL_32KHZ_SetPowerMode(uint8 mode) 
1284          {
1285   1          uint8 state = (0u != (CY_CLK_XTAL32_CR_REG & CY_CLK_XTAL32_CR_LPM)) ? 1u : 0u;
1286   1      
1287   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1288   1      
1289   1          if(1u == mode)
1290   1          {
1291   2              /* Low power mode during Sleep */
1292   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_LOW_POWER;
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 22  

1293   2              CyDelayUs(10u);
1294   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1295   2                                      CY_CLK_XTAL32_CFG_LP_LOWPOWER;
1296   2              CyDelayUs(20u);
1297   2              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_LPM;
1298   2          }
1299   1          else
1300   1          {
1301   2              /* High power mode */
1302   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_HIGH_POWER;
1303   2              CyDelayUs(10u);
1304   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1305   2                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1306   2              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_LPM));
1307   2          }
1308   1      
1309   1          return(state);
1310   1      }
1311          
1312          
1313          /*******************************************************************************
1314          * Function Name: CyXTAL_Start
1315          ********************************************************************************
1316          *
1317          * Summary:
1318          *  Enables the megahertz crystal.
1319          *
1320          *  PSoC 3:
1321          *  Waits until the XERR bit is low (no error) for a millisecond or until the
1322          *  number of milliseconds specified by the wait parameter has expired.
1323          *
1324          * Parameters:
1325          *   wait: Valid range [0-255].
1326          *   This is the timeout value in milliseconds.
1327          *   The appropriate value is crystal specific.
1328          *
1329          * Return:
1330          *   CYRET_SUCCESS - Completed successfully
1331          *   CYRET_TIMEOUT - Timeout occurred without detecting a low value on XERR.
1332          *
1333          * Side Effects and Restrictions:
1334          *  If wait is enabled (non-zero wait). Uses the Fast Timewheel to time the wait.
1335          *  Any other use of the Fast Timewheel (FTW) will be stopped during the period
1336          *  of this function and then restored.
1337          *
1338          *  Uses the 100KHz ILO.  If not enabled, this function will enable the 100KHz
1339          *  ILO for the period of this function. No changes to the setup of the ILO,
1340          *  Fast Timewheel, Central Timewheel or Once Per Second interrupt may be made
1341          *  by interrupt routines during the period of this function.
1342          *
1343          *  The current operation of the ILO, Central Timewheel and Once Per Second
1344          *  interrupt are maintained during the operation of this function provided the
1345          *  reading of the Power Manager Interrupt Status Register is only done using the
1346          *  CyPmReadStatus() function.
1347          *
1348          *******************************************************************************/
1349          cystatus CyXTAL_Start(uint8 wait) 
1350          {
1351   1          cystatus status = CYRET_SUCCESS;
1352   1          volatile uint8  timeout = wait;
1353   1          volatile uint8 count;
1354   1          uint8 iloEnableState;
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 23  

1355   1          uint8 pmTwCfg0Tmp;
1356   1          uint8 pmTwCfg2Tmp;
1357   1      
1358   1      
1359   1          /* Enables MHz crystal oscillator circuit  */
1360   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_ENABLE;
1361   1      
1362   1      
1363   1          if(wait > 0u)
1364   1          {
1365   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
1366   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG;
1367   2              pmTwCfg0Tmp = CY_LIB_PM_TW_CFG0_REG;
1368   2              pmTwCfg2Tmp = CY_LIB_PM_TW_CFG2_REG;
1369   2      
1370   2              /* Set 250 us interval */
1371   2              CyPmFtwSetInterval(CY_CLK_XMHZ_FTW_INTERVAL);
1372   2              status = CYRET_TIMEOUT;
1373   2      
1374   2      
1375   2              for( ; timeout > 0u; timeout--)
1376   2              {
1377   3                  /* Read XERR bit to clear it */
1378   3                  (void) CY_CLK_XMHZ_CSR_REG;
1379   3      
1380   3                  /* Wait for 1 millisecond - 4 x 250 us */
1381   3                  for(count = 4u; count > 0u; count--)
1382   3                  {
1383   4                      while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
1384   4                      {
1385   5                          /* Wait for FTW interrupt event */
1386   5                      }
1387   4                  }
1388   3      
1389   3      
1390   3                  /*******************************************************************
1391   3                  * High output indicates an oscillator failure.
1392   3                  * Only can be used after a start-up interval (1 ms) is completed.
1393   3                  *******************************************************************/
1394   3                  if(0u == (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR))
1395   3                  {
1396   4                      status = CYRET_SUCCESS;
1397   4                      break;
1398   4                  }
1399   3              }
1400   2      
1401   2      
1402   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
1403   2              if(0u == (iloEnableState & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ))
1404   2              {
1405   3                  CyILO_Stop100K();
1406   3              }
1407   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0Tmp;
1408   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2Tmp;
1409   2          }
1410   1      
1411   1          return(status);
1412   1      }
1413          
1414          
1415          /*******************************************************************************
1416          * Function Name: CyXTAL_Stop
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 24  

1417          ********************************************************************************
1418          *
1419          * Summary:
1420          *  Disables the megahertz crystal oscillator.
1421          *
1422          * Parameters:
1423          *  None
1424          *
1425          * Return:
1426          *  None
1427          *
1428          *******************************************************************************/
1429          void CyXTAL_Stop(void) 
1430          {
1431   1          /* Disable oscillator. */
1432   1          FASTCLK_XMHZ_CSR &= ((uint8)(~XMHZ_CONTROL_ENABLE));
1433   1      }
1434          
1435          
1436          /*******************************************************************************
1437          * Function Name: CyXTAL_EnableErrStatus
1438          ********************************************************************************
1439          *
1440          * Summary:
1441          *  Enables the generation of the XERR status bit for the megahertz crystal.
1442          *  This function is not available for PSoC5.
1443          *
1444          * Parameters:
1445          *  None
1446          *
1447          * Return:
1448          *  None
1449          *
1450          *******************************************************************************/
1451          void CyXTAL_EnableErrStatus(void) 
1452          {
1453   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1454   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XFB));
1455   1      }
1456          
1457          
1458          /*******************************************************************************
1459          * Function Name: CyXTAL_DisableErrStatus
1460          ********************************************************************************
1461          *
1462          * Summary:
1463          *  Disables the generation of the XERR status bit for the megahertz crystal.
1464          *  This function is not available for PSoC5.
1465          *
1466          * Parameters:
1467          *  None
1468          *
1469          * Return:
1470          *  None
1471          *
1472          *******************************************************************************/
1473          void CyXTAL_DisableErrStatus(void) 
1474          {
1475   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1476   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XFB;
1477   1      }
1478          
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 25  

1479          
1480          /*******************************************************************************
1481          * Function Name: CyXTAL_ReadStatus
1482          ********************************************************************************
1483          *
1484          * Summary:
1485          *  Reads the XERR status bit for the megahertz crystal. This status bit is a
1486          *  sticky, clear on read. This function is not available for PSoC5.
1487          *
1488          * Parameters:
1489          *  None
1490          *
1491          * Return:
1492          *   Status
1493          *    0: No error
1494          *    1: Error
1495          *
1496          *******************************************************************************/
1497          uint8 CyXTAL_ReadStatus(void) 
1498          {
1499   1          /***************************************************************************
1500   1          * High output indicates an oscillator failure. Only use this after a start-up
1501   1          * interval is completed. This can be used for the status and failure recovery.
1502   1          ***************************************************************************/
1503   1          return((0u != (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR)) ? 1u : 0u);
1504   1      }
1505          
1506          
1507          /*******************************************************************************
1508          * Function Name: CyXTAL_EnableFaultRecovery
1509          ********************************************************************************
1510          *
1511          * Summary:
1512          *  Enables the fault recovery circuit which will switch to the IMO in the case
1513          *  of a fault in the megahertz crystal circuit. The crystal must be up and
1514          *  running with the XERR bit at 0, before calling this function to prevent
1515          *  an immediate fault switchover. This function is not available for PSoC5.
1516          *
1517          * Parameters:
1518          *  None
1519          *
1520          * Return:
1521          *  None
1522          *
1523          *******************************************************************************/
1524          void CyXTAL_EnableFaultRecovery(void) 
1525          {
1526   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XPROT;
1527   1      }
1528          
1529          
1530          /*******************************************************************************
1531          * Function Name: CyXTAL_DisableFaultRecovery
1532          ********************************************************************************
1533          *
1534          * Summary:
1535          *  Disables the fault recovery circuit which will switch to the IMO in the case
1536          *  of a fault in the megahertz crystal circuit. This function is not available
1537          *  for PSoC5.
1538          *
1539          * Parameters:
1540          *  None
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 26  

1541          *
1542          * Return:
1543          *  None
1544          *
1545          *******************************************************************************/
1546          void CyXTAL_DisableFaultRecovery(void) 
1547          {
1548   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XPROT));
1549   1      }
1550          
1551          
1552          /*******************************************************************************
1553          * Function Name: CyXTAL_SetStartup
1554          ********************************************************************************
1555          *
1556          * Summary:
1557          *  Sets the startup settings for the crystal. The logic model outputs a
1558          *  frequency (setting + 4) MHz when enabled.
1559          *
1560          *  This is artificial as the actual frequency is determined by an attached
1561          *  external crystal.
1562          *
1563          * Parameters:
1564          *  setting: Valid range [0-31].
1565          *   The value is dependent on the frequency and quality of the crystal being
1566          *   used. Refer to the device TRM and datasheet for more information.
1567          *
1568          * Return:
1569          *  None
1570          *
1571          *******************************************************************************/
1572          void CyXTAL_SetStartup(uint8 setting) 
1573          {
1574   1          CY_CLK_XMHZ_CFG0_REG = (CY_CLK_XMHZ_CFG0_REG & ((uint8)(~CY_CLK_XMHZ_CFG0_XCFG_MASK))) |
1575   1                                 (setting & CY_CLK_XMHZ_CFG0_XCFG_MASK);
1576   1      }
1577          
1578          
1579          
1580          /*******************************************************************************
1581          * Function Name: CyXTAL_SetFbVoltage
1582          ********************************************************************************
1583          *
1584          * Summary:
1585          *  Sets the feedback reference voltage to use for the crystal circuit.
1586          *  This function is only available for PSoC3 and PSoC 5LP.
1587          *
1588          * Parameters:
1589          *  setting: Valid range [0-15].
1590          *  Refer to the device TRM and datasheet for more information.
1591          *
1592          * Return:
1593          *  None
1594          *
1595          *******************************************************************************/
1596          void CyXTAL_SetFbVoltage(uint8 setting) 
1597          {
1598   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_FB_MASK))) |
1599   1                                  (setting & CY_CLK_XMHZ_CFG1_VREF_FB_MASK));
1600   1      }
1601          
1602          
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 27  

1603          /*******************************************************************************
1604          * Function Name: CyXTAL_SetWdVoltage
1605          ********************************************************************************
1606          *
1607          * Summary:
1608          *  Sets the reference voltage used by the watchdog to detect a failure in the
1609          *  crystal circuit. This function is only available for PSoC3 and PSoC 5LP.
1610          *
1611          * Parameters:
1612          *  setting: Valid range [0-7].
1613          *  Refer to the device TRM and datasheet for more information.
1614          *
1615          * Return:
1616          *  None
1617          *
1618          *******************************************************************************/
1619          void CyXTAL_SetWdVoltage(uint8 setting) 
1620          {
1621   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_WD_MASK))) |
1622   1                                  (((uint8)(setting << 4u)) & CY_CLK_XMHZ_CFG1_VREF_WD_MASK));
1623   1      }
1624          
1625          
1626          /*******************************************************************************
1627          * Function Name: CyHalt
1628          ********************************************************************************
1629          *
1630          * Summary:
1631          *  Halts the CPU.
1632          *
1633          * Parameters:
1634          *  uint8 reason: Value to be used during debugging.
1635          *
1636          * Return:
1637          *  None
1638          *
1639          *******************************************************************************/
1640          void CyHalt(uint8 reason) CYREENTRANT
1641          {
1642   1          if(0u != reason)
1643   1          {
1644   2              /* To remove unreferenced local variable warning */
1645   2          }
1646   1      
1647   1          #if defined (__ARMCC_VERSION)
                      __breakpoint(0x0);
                  #elif defined(__GNUC__) || defined (__ICCARM__)
                      __asm("    bkpt    1");
                  #elif defined(__C51__)
1652   1              CYDEV_HALT_CPU;
1653   1          #endif  /* (__ARMCC_VERSION) */
1654   1      }
1655          
1656          
1657          /*******************************************************************************
1658          * Function Name: CySoftwareReset
1659          ********************************************************************************
1660          *
1661          * Summary:
1662          *  Forces a device software reset.
1663          *
1664          * Parameters:
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 28  

1665          *  None
1666          *
1667          * Return:
1668          *  None
1669          *
1670          *******************************************************************************/
1671          void CySoftwareReset(void) 
1672          {
1673   1          CY_LIB_RESET_CR2_REG |= CY_LIB_RESET_CR2_RESET;
1674   1      }
1675          
1676          
1677          /*******************************************************************************
1678          * Function Name: CyDelay
1679          ********************************************************************************
1680          *
1681          * Summary:
1682          *  Blocks for milliseconds.
1683          *
1684          *  Note:
1685          *  CyDelay has been implemented with the instruction cache assumed enabled. When
1686          *  the instruction cache is disabled on PSoC5, CyDelay will be two times larger.
1687          *  For example, with instruction cache disabled CyDelay(100) would result in
1688          *  about 200 ms delay instead of 100 ms.
1689          *
1690          * Parameters:
1691          *  milliseconds: number of milliseconds to delay.
1692          *
1693          * Return:
1694          *   None
1695          *
1696          *******************************************************************************/
1697          void CyDelay(uint32 milliseconds) CYREENTRANT
1698          {
1699   1          while (milliseconds > 32768u)
1700   1          {
1701   2              /***********************************************************************
1702   2              * This loop prevents overflow.At 100MHz, milliseconds * delay_freq_khz
1703   2              * overflows at about 42 seconds.
1704   2              ***********************************************************************/
1705   2              CyDelayCycles(cydelay_32k_ms);
1706   2              milliseconds = ((uint32)(milliseconds - 32768u));
1707   2          }
1708   1      
1709   1          CyDelayCycles(milliseconds * cydelay_freq_khz);
1710   1      }
1711          
1712          
1713          #if(!CY_PSOC3)
              
                  /* For PSoC3 devices function is defined in CyBootAsmKeil.a51 file */
              
                  /*******************************************************************************
                  * Function Name: CyDelayUs
                  ********************************************************************************
                  *
                  * Summary:
                  *  Blocks for microseconds.
                  *
                  *  Note:
                  *   CyDelay has been implemented with the instruction cache assumed enabled.
                  *   When instruction cache is disabled on PSoC5, CyDelayUs will be two times
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 29  

                  *   larger. Ex: With instruction cache disabled CyDelayUs(100) would result
                  *   in about 200us delay instead of 100us.
                  *
                  * Parameters:
                  *  uint16 microseconds: number of microseconds to delay.
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  CyDelayUS has been implemented with the instruction cache assumed enabled.
                  *  When the instruction cache is disabled on PSoC 5, CyDelayUs will be two times
                  *  larger. For example, with the instruction cache disabled CyDelayUs(100) would
                  *  result in about 200 us delay instead of 100 us.
                  *
                  *  If the bus clock frequency is a small non-integer number, the actual delay
                  *  can be up to twice as long as the nominal value. The actual delay cannot be
                  *  shorter than the nominal one.
                  *******************************************************************************/
                  void CyDelayUs(uint16 microseconds) CYREENTRANT
                  {
                      CyDelayCycles((uint32)microseconds * cydelay_freq_mhz);
                  }
              
              #endif  /* (!CY_PSOC3) */
1752          
1753          
1754          /*******************************************************************************
1755          * Function Name: CyDelayFreq
1756          ********************************************************************************
1757          *
1758          * Summary:
1759          *  Sets the clock frequency for CyDelay.
1760          *
1761          * Parameters:
1762          *  freq: The frequency of the bus clock in Hertz.
1763          *
1764          * Return:
1765          *  None
1766          *
1767          *******************************************************************************/
1768          void CyDelayFreq(uint32 freq) CYREENTRANT
1769          {
1770   1          if (freq != 0u)
1771   1          {
1772   2              cydelay_freq_hz = freq;
1773   2          }
1774   1          else
1775   1          {
1776   2              cydelay_freq_hz = BCLK__BUS_CLK__HZ;
1777   2          }
1778   1      
1779   1          cydelay_freq_mhz = (uint8)((cydelay_freq_hz + 999999u) / 1000000u);
1780   1          cydelay_freq_khz = (cydelay_freq_hz + 999u) / 1000u;
1781   1          cydelay_32k_ms   = 32768u * cydelay_freq_khz;
1782   1      }
1783          
1784          
1785          /*******************************************************************************
1786          * Function Name: CyWdtStart
1787          ********************************************************************************
1788          *
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 30  

1789          * Summary:
1790          *  Enables the watchdog timer.
1791          *
1792          *  The timer is configured for the specified count interval, the central
1793          *  timewheel is cleared, the setting for the low power mode is configured and
1794          *  the watchdog timer is enabled.
1795          *
1796          *  Once enabled the watchdog cannot be disabled. The watchdog counts each time
1797          *  the Central Time Wheel (CTW) reaches the period specified. The watchdog must
1798          *  be cleared using the CyWdtClear() function before three ticks of the watchdog
1799          *  timer occur. The CTW is free running, so this will occur after between 2 and
1800          *  3 timer periods elapse.
1801          *
1802          *  PSoC5: The watchdog timer should not be used during sleep modes. Since the
1803          *  WDT cannot be disabled after it is enabled, the WDT timeout period can be
1804          *  set to be greater than the sleep wakeup period, then feed the dog on each
1805          *  wakeup from Sleep.
1806          *
1807          * Parameters:
1808          *  ticks: One of the four available timer periods. Once WDT enabled, the
1809             interval cannot be changed.
1810          *         CYWDT_2_TICKS     -     4 - 6     ms
1811          *         CYWDT_16_TICKS    -    32 - 48    ms
1812          *         CYWDT_128_TICKS   -   256 - 384   ms
1813          *         CYWDT_1024_TICKS  - 2.048 - 3.072 s
1814          *
1815          *  lpMode: Low power mode configuration. This parameter is ignored for PSoC 5.
1816          *          The WDT always acts as if CYWDT_LPMODE_NOCHANGE is passed.
1817          *
1818          *          CYWDT_LPMODE_NOCHANGE - No Change
1819          *          CYWDT_LPMODE_MAXINTER - Switch to longest timer mode during low power
1820          *                                 mode
1821          *          CYWDT_LPMODE_DISABLED - Disable WDT during low power mode
1822          *
1823          * Return:
1824          *  None
1825          *
1826          * Side Effects:
1827          *  PSoC5: The ILO 1 KHz must be enabled for proper WDT operation. Stopping the
1828          *  ILO 1 kHz could break the active WDT functionality.
1829          *
1830          *******************************************************************************/
1831          void CyWdtStart(uint8 ticks, uint8 lpMode) 
1832          {
1833   1          /* Set WDT interval */
1834   1          CY_WDT_CFG_REG = (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_INTERVAL_MASK))) | (ticks & CY_WDT_CFG_INTERVA
             -L_MASK);
1835   1      
1836   1          /* Reset CTW to ensure that first watchdog period is full */
1837   1          CY_WDT_CFG_REG |= CY_WDT_CFG_CTW_RESET;
1838   1          CY_WDT_CFG_REG &= ((uint8)(~CY_WDT_CFG_CTW_RESET));
1839   1      
1840   1          /* Setting low power mode */
1841   1          CY_WDT_CFG_REG = (((uint8)(lpMode << CY_WDT_CFG_LPMODE_SHIFT)) & CY_WDT_CFG_LPMODE_MASK) |
1842   1                             (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_LPMODE_MASK)));
1843   1      
1844   1          /* Enables watchdog reset */
1845   1          CY_WDT_CFG_REG |= CY_WDT_CFG_WDR_EN;
1846   1      }
1847          
1848          
1849          /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 31  

1850          * Function Name: CyWdtClear
1851          ********************************************************************************
1852          *
1853          * Summary:
1854          *  Clears (feeds) the watchdog timer.
1855          *
1856          * Parameters:
1857          *  None
1858          *
1859          * Return:
1860          *  None
1861          *
1862          *******************************************************************************/
1863          void CyWdtClear(void) 
1864          {
1865   1          CY_WDT_CR_REG = CY_WDT_CR_FEED;
1866   1      }
1867          
1868          
1869          
1870          /*******************************************************************************
1871          * Function Name: CyVdLvDigitEnable
1872          ********************************************************************************
1873          *
1874          * Summary:
1875          *  Sets the voltage trip level, enables the output of the digital low-voltage
1876          *  monitor, and optionally configures voltage monitor to reset device upon the
1877          *  low-voltage event instead of generating an interrupt.
1878          *
1879          *  Note The associated interrupt enable/disable state is not changed by the
1880          *  function. The Interrupt component API should be used to register the
1881          *  interrupt service routine and to enable/disable associated interrupt.
1882          *
1883          * Parameters:
1884          *  reset: Enables device reset on digital low-voltage event:
1885          *   Zero - Interrupt on digital low-voltage event
1886          *   Non-zero - Reset on digital low-voltage event
1887          *
1888          *  threshold: Sets the trip point of the digital low-voltage monitoring circuit
1889          *   in steps of approximately 250 mV in range from 1.70 V (0x00) to 5.45 V
1890          *   (0x0F). For example, the trip point is set to 1.80 V when the threshold
1891          *   parameter value is 0x04. Refer to the device TRM for the exact trip voltage
1892          *   values.
1893          *
1894          * Return:
1895          *  None
1896          *
1897          * Side Effects and Restrictions:
1898          *  The voltage resets are momentary. When a voltage reset (analog/digital
1899          *  low-voltage and analog high-voltage) occurs, the RESET_CR1 and RESET_CR3
1900          *  registers are restored to their default values. This means that the voltage
1901          *  monitor circuit is no longer enabled and the device exits reset. If the
1902          *  supply is below the trip level and firmware enables the voltage reset
1903          *  functionality, the device will reset again. This will continue as long as the
1904          *  supply is below the trip level or as long as the user enables the reset
1905          *  functionality of the voltage monitor functionality.
1906          *
1907          *  When any voltage reset occurs, the RESET_SR0 and RESET_SR2 status registers
1908          *  are cleared. This means that analog low-voltage, digital low-voltage and
1909          *  analog high-voltage status bits are not persistent across any voltage reset.
1910          *
1911          *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 32  

1912          void CyVdLvDigitEnable(uint8 reset, uint8 threshold) 
1913          {
1914   1          uint32 intRegTmp;
1915   1          uint8 interruptState;
1916   1      
1917   1          interruptState = CyEnterCriticalSection();
1918   1      
1919   1          /* Store interrupt enable state */
1920   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
1921   1      
1922   1          /* Disable VD interrupt (write 1) to protect against glitches */
1923   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
1924   1      
1925   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1926   1      
1927   1          CY_VD_LVI_TRIP_REG = (threshold & CY_VD_LVI_TRIP_LVID_MASK) |
1928   1                                  (CY_VD_LVI_TRIP_REG & ((uint8)(~CY_VD_LVI_TRIP_LVID_MASK)));
1929   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVID_EN;
1930   1      
1931   1          /* Timeout to eliminate glitches on LVI/HVI when enabling (ID # 127412) */
1932   1          CyDelayUs(1u);
1933   1      
1934   1          (void) CyVdStickyStatus(CY_VD_LVID);
1935   1      
1936   1          if(0u != reset)
1937   1          {
1938   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESD_EN;
1939   2          }
1940   1          else
1941   1          {
1942   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1943   2          }
1944   1      
1945   1          /* Clear pending interrupt */
1946   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
1947   1      
1948   1          /* Restore interrupt enable state */
1949   1          CY_INT_ENABLE_REG = intRegTmp;
1950   1      
1951   1          CyExitCriticalSection(interruptState);
1952   1      }
1953          
1954          
1955          /*******************************************************************************
1956          * Function Name: CyVdLvAnalogEnable
1957          ********************************************************************************
1958          *
1959          * Summary:
1960          *  Sets the voltage trip level, enables the output of the analog low-voltage
1961          *  monitor, and optionally configures voltage monitor to reset device upon the
1962          *  low-voltage event instead of generating an interrupt.
1963          *
1964          *  Note The associated interrupt enable/disable state is not changed by the
1965          *  function. The Interrupt component API should be used to register the
1966          *  interrupt service routine and to enable/disable associated interrupt.
1967          *
1968          * Parameters:
1969          *  reset: Enables device reset on analog low-voltage event:
1970          *  Zero - Interrupt on analog low-voltage event
1971          *  Non-zero - Reset on analog low-voltage event
1972          *
1973          *  threshold: Sets the trip point of the analog low-voltage monitoring circuit
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 33  

1974          *  in steps of approximately 250 mV in range from 1.70 V (0x00) to 5.45 V
1975          *  (0x0F). For example, the trip point is set to 1.80 V when value of the
1976          *  threshold parameter is 0x04. Please refer to the device TRM for the exact
1977          *  trip voltage values.
1978          *
1979          * Return:
1980          *  None
1981          *
1982          * Side Effects and Restrictions:
1983          *  The voltage resets are momentary. When a voltage reset (analog/digital
1984          *  low-voltage and analog high-voltage) occurs, the RESET_CR1 and RESET_CR3
1985          *  registers are restored to their default values. This means that the voltage
1986          *  monitor circuit is no longer enabled and the device exits reset. If the
1987          *  supply is below the trip level and firmware enables the voltage reset
1988          *  functionality, the device will reset again. This will continue as long as
1989          *  the supply is below the trip level or as long as the user enables the reset
1990          *  functionality of the voltage monitor functionality.
1991          *
1992          *  When any voltage reset occurs, the RESET_SR0 and RESET_SR2 status registers
1993          *  are cleared. This means that analog low-voltage, digital low-voltage and
1994          *  analog high-voltage status bits are not persistent across any voltage reset.
1995          *
1996          *******************************************************************************/
1997          void CyVdLvAnalogEnable(uint8 reset, uint8 threshold) 
1998          {
1999   1          uint32 intRegTmp;
2000   1          uint8 interruptState;
2001   1      
2002   1          interruptState = CyEnterCriticalSection();
2003   1      
2004   1          /* Store interrupt enable state */
2005   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
2006   1      
2007   1          /* Disable VD interrupt (write 1) to protect against glitches */
2008   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
2009   1      
2010   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2011   1      
2012   1          CY_VD_LVI_TRIP_REG = ((uint8)(threshold << 4u)) | (CY_VD_LVI_TRIP_REG & 0x0Fu);
2013   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVIA_EN;
2014   1      
2015   1          /* Timeout to eliminate glitches on LVI/HVI when enabling (ID # 127412) */
2016   1          CyDelayUs(1u);
2017   1      
2018   1          (void) CyVdStickyStatus(CY_VD_LVIA);
2019   1      
2020   1          if(0u != reset)
2021   1          {
2022   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESA_EN;
2023   2          }
2024   1          else
2025   1          {
2026   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2027   2          }
2028   1      
2029   1          /* Clear pending interrupt */
2030   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
2031   1      
2032   1          /* Restore interrupt enable state */
2033   1          CY_INT_ENABLE_REG = intRegTmp;
2034   1      
2035   1          CyExitCriticalSection(interruptState);
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 34  

2036   1      }
2037          
2038          
2039          /*******************************************************************************
2040          * Function Name: CyVdLvDigitDisable
2041          ********************************************************************************
2042          *
2043          * Summary:
2044          *  Disables the digital low-voltage monitor, turns off device reset upon the
2045          *  digital low-voltage event, and clears the associated persistent status bit.
2046          *
2047          *  Note The associated interrupt enable/disable state is not changed by the
2048          *  function. The pending interrupt status is not cleared. The Interrupt
2049          *  component API should be used to manipulate with the associated interrupts.
2050          *
2051          * Parameters:
2052          *  None
2053          *
2054          * Return:
2055          *  None
2056          *
2057          *******************************************************************************/
2058          void CyVdLvDigitDisable(void) 
2059          {
2060   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVID_EN));
2061   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
2062   1          (void) CyVdStickyStatus(CY_VD_LVID);
2063   1      
2064   1          while(0u != (CyVdStickyStatus(CY_VD_LVID) & CY_VD_LVID))
2065   1          {
2066   2      
2067   2          }
2068   1      }
2069          
2070          
2071          /*******************************************************************************
2072          * Function Name: CyVdLvAnalogDisable
2073          ********************************************************************************
2074          *
2075          * Summary:
2076          *  Disables the analog low-voltage monitor, turns off device reset upon the
2077          *  analog low-voltage event, and clears the associated persistent status bit.
2078          *
2079          *  Note The associated interrupt enable/disable state is not changed by the
2080          *  function. The pending interrupt status is not cleared. The Interrupt
2081          *  component API should be used to manipulate with the associated interrupts.
2082          *
2083          * Parameters:
2084          *  None
2085          *
2086          * Return:
2087          *  None
2088          *
2089          *******************************************************************************/
2090          void CyVdLvAnalogDisable(void) 
2091          {
2092   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVIA_EN));
2093   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2094   1          while(0u != (CyVdStickyStatus(CY_VD_LVIA) & CY_VD_LVIA))
2095   1          {
2096   2      
2097   2          }
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 35  

2098   1      }
2099          
2100          
2101          /*******************************************************************************
2102          * Function Name: CyVdHvAnalogEnable
2103          ********************************************************************************
2104          *
2105          * Summary:
2106          *  Enables the output of the analog high-voltage monitor and sets 5.75 V
2107          *  threshold detection for Vdda.
2108          *
2109          *  Note The associated interrupt enable/disable state is not changed by the
2110          *  function. The Interrupt component API should be used to register the
2111          *  interrupt service routine and to enable/disable associated interrupt.
2112          *
2113          * Parameters:
2114          *  None
2115          *
2116          * Return:
2117          *  None
2118          *
2119          *******************************************************************************/
2120          void CyVdHvAnalogEnable(void) 
2121          {
2122   1          uint32 intRegTmp;
2123   1          uint8 interruptState;
2124   1      
2125   1          interruptState = CyEnterCriticalSection();
2126   1      
2127   1          /* Store interrupt enable state */
2128   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
2129   1      
2130   1          /* Disable VD interrupt (write 1) to protect against glitches */
2131   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
2132   1      
2133   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2134   1      
2135   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_HVIA_EN;
2136   1      
2137   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling (ID # 127412)  */
2138   1          CyDelayUs(1u);
2139   1      
2140   1          (void) CyVdStickyStatus(CY_VD_HVIA);
2141   1      
2142   1          /* Clear pending interrupt */
2143   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
2144   1      
2145   1          /* Restore interrupt enable state */
2146   1          CY_INT_ENABLE_REG = intRegTmp;
2147   1      
2148   1          CyExitCriticalSection(interruptState);
2149   1      }
2150          
2151          
2152          /*******************************************************************************
2153          * Function Name: CyVdHvAnalogDisable
2154          ********************************************************************************
2155          *
2156          * Summary:
2157          *  Disables the analog high-voltage monitor and clears the associated persistent
2158          *  status bit.
2159          *
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 36  

2160          *  Note The associated interrupt enable/disable state is not changed by the
2161          *  function. The pending interrupt status is not cleared. The Interrupt
2162          *  component API should be used to manipulate with the associated interrupts.
2163          *
2164          * Parameters:
2165          *  None
2166          *
2167          * Return:
2168          *  None
2169          *
2170          *******************************************************************************/
2171          void CyVdHvAnalogDisable(void) 
2172          {
2173   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_HVIA_EN));
2174   1          while(0u != (CyVdStickyStatus(CY_VD_HVIA) & CY_VD_HVIA))
2175   1          {
2176   2      
2177   2          }
2178   1      }
2179          
2180          
2181          /*******************************************************************************
2182          * Function Name: CyVdStickyStatus
2183          ********************************************************************************
2184          *
2185          * Summary:
2186          *  Reads and clears the voltage detection status bits in the RESET_SR0 register.
2187          *  The bits are set to 1 by the voltage monitor circuit when the supply is
2188          *  outside the detector trip point. They stay set to 1 until they are read or
2189          *  a POR / LVI / PRES reset occurs. This function uses a shadow register, so
2190          *  only the bits passed in the parameter will be cleared in the shadow register.
2191          *
2192          * Parameters:
2193          *  mask: Bits in the RESET_SR0 shadow register to clear and return.
2194          *   Define                  Definition
2195          *   CY_VD_LVID            Persistent status of digital LVI.
2196          *   CY_VD_LVIA            Persistent status of analog LVI.
2197          *   CY_VD_HVIA            Persistent status of analog HVI.
2198          *
2199          * Return:
2200          *  Status. Same enumerated bit values as used for the mask parameter. A zero is
2201          *  returned for bits not used in the mask parameter.
2202          *
2203          * Side Effects and Restrictions:
2204          *  When an LVI reset occurs, the RESET_SR0 status registers are cleared. This
2205          *  means that the voltage detection status bits are not persistent across an LVI
2206          *  reset and cannot be used to determine a reset source.
2207          *
2208          *******************************************************************************/
2209          uint8 CyVdStickyStatus(uint8 mask) 
2210          {
2211   1          static uint8 interruptStatus;
2212   1          uint8 interruptState;
2213   1          uint8 tmpStatus;
2214   1      
2215   1          interruptState = CyEnterCriticalSection();
2216   1      
2217   1          interruptStatus |= CY_VD_PERSISTENT_STATUS_REG;
2218   1          tmpStatus = interruptStatus & (uint8)(CY_VD_LVID | CY_VD_LVIA | CY_VD_HVIA);
2219   1          interruptStatus &= ((uint8)(~mask));
2220   1      
2221   1          CyExitCriticalSection(interruptState);
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 37  

2222   1      
2223   1          return(tmpStatus);
2224   1      }
2225          
2226          
2227          /*******************************************************************************
2228          * Function Name: CyVdRealTimeStatus
2229          ********************************************************************************
2230          *
2231          * Summary:
2232          *  Reads the real-time voltage detection status bits in the RESET_SR2 register.
2233          *  The bits are set to 1 by the voltage monitor circuit when the supply is
2234          *  outside the detectors trip point, and set to 0 when the supply is inside the
2235          *  trip point.
2236          *
2237          * Parameters:
2238          *  None
2239          *
2240          * Return:
2241          *  Status of the LVID, LVIA, and HVIA bits in the RESET_SR2 register.
2242          *   Define                  Definition
2243          *   CY_VD_LVID            Real-time status of digital LVI.
2244          *   CY_VD_LVIA            Real-time status of analog LVI.
2245          *   CY_VD_HVIA            Real-time status of analog HVI.
2246          *
2247          * Side Effects and Restrictions:
2248          *  When an LVI reset occurs, the RESET_SR2 status registers are cleared. This
2249          *  means that the voltage detection status bits are not persistent across an LVI
2250          *  reset and cannot be used to determine a reset source.
2251          *
2252          *******************************************************************************/
2253          uint8 CyVdRealTimeStatus(void) 
2254          {
2255   1          uint8 interruptState;
2256   1          uint8 vdFlagsState;
2257   1      
2258   1          interruptState = CyEnterCriticalSection();
2259   1          vdFlagsState = CY_VD_RT_STATUS_REG & (CY_VD_LVID | CY_VD_LVIA | CY_VD_HVIA);
2260   1          CyExitCriticalSection(interruptState);
2261   1      
2262   1          return(vdFlagsState);
2263   1      }
2264          
2265          
2266          /*******************************************************************************
2267          * Function Name: CyDisableInts
2268          ********************************************************************************
2269          *
2270          * Summary:
2271          *  Disables the interrupt enable for each interrupt.
2272          *
2273          * Parameters:
2274          *  None
2275          *
2276          * Return:
2277          *  32 bit mask of previously enabled interrupts.
2278          *
2279          *******************************************************************************/
2280          uint32 CyDisableInts(void) 
2281          {
2282   1          uint32 intState;
2283   1          uint8 interruptState;
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 38  

2284   1      
2285   1          interruptState = CyEnterCriticalSection();
2286   1      
2287   1          #if(CY_PSOC3)
2288   1      
2289   1              /* Get the current interrupt state. */
2290   1              intState  = ((uint32) CY_GET_REG8(CY_INT_CLR_EN0_PTR));
2291   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN1_PTR)) << 8u));
2292   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN2_PTR)) << 16u));
2293   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN3_PTR)) << 24u));
2294   1      
2295   1      
2296   1              /* Disable all of the interrupts. */
2297   1              CY_SET_REG8(CY_INT_CLR_EN0_PTR, 0xFFu);
2298   1              CY_SET_REG8(CY_INT_CLR_EN1_PTR, 0xFFu);
2299   1              CY_SET_REG8(CY_INT_CLR_EN2_PTR, 0xFFu);
2300   1              CY_SET_REG8(CY_INT_CLR_EN3_PTR, 0xFFu);
2301   1      
2302   1          #else
              
                      /* Get the current interrupt state. */
                      intState = CY_GET_REG32(CY_INT_CLEAR_PTR);
              
                      /* Disable all of the interrupts. */
                      CY_SET_REG32(CY_INT_CLEAR_PTR, 0xFFFFFFFFu);
              
                  #endif /* (CY_PSOC3) */
2311   1      
2312   1          CyExitCriticalSection(interruptState);
2313   1      
2314   1          return (intState);
2315   1      }
2316          
2317          
2318          /*******************************************************************************
2319          * Function Name: CyEnableInts
2320          ********************************************************************************
2321          *
2322          * Summary:
2323          *  Enables interrupts to a given state.
2324          *
2325          * Parameters:
2326          *  uint32 mask: 32 bit mask of interrupts to enable.
2327          *
2328          * Return:
2329          *  None
2330          *
2331          *******************************************************************************/
2332          void CyEnableInts(uint32 mask) 
2333          {
2334   1      
2335   1          uint8 interruptState;
2336   1      
2337   1          interruptState = CyEnterCriticalSection();
2338   1      
2339   1          #if(CY_PSOC3)
2340   1      
2341   1              /* Set interrupts as enabled. */
2342   1              CY_SET_REG8(CY_INT_SET_EN3_PTR, ((uint8) (mask >> 24u)));
2343   1              CY_SET_REG8(CY_INT_SET_EN2_PTR, ((uint8) (mask >> 16u)));
2344   1              CY_SET_REG8(CY_INT_SET_EN1_PTR, ((uint8) (mask >> 8u )));
2345   1              CY_SET_REG8(CY_INT_SET_EN0_PTR, ((uint8) (mask )));
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 39  

2346   1      
2347   1          #else
              
                      CY_SET_REG32(CY_INT_ENABLE_PTR, mask);
              
                  #endif /* (CY_PSOC3) */
2352   1      
2353   1          CyExitCriticalSection(interruptState);
2354   1      
2355   1      }
2356          
2357          #if(CY_PSOC5)
              
                  /*******************************************************************************
                  * Function Name: CyFlushCache
                  ********************************************************************************
                  * Summary:
                  *  Call this API after a flash row erase/write operation to invalidate or flush
                  *  any of that particular flash region content already present in the cache.
                  *  After a cache flush operation, any access to that flash region after the
                  *  erase/write operation would reload the cache with the modified data from the
                  *  flash region. If the flash region update involves multiple flash row write
                  *  operations, then the flushing of the cache can be done once at the end of
                  *  the operation as long as the flash data would not be accessed in the middle
                  *  of the multiple row update process. Else, flush the cache after every flash
                  *  row write.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyFlushCache(void)
                  {
                      uint8 interruptState;
              
                      /* Save current global interrupt enable and disable it */
                      interruptState = CyEnterCriticalSection();
              
                      /* Fill instruction prefectch unit to insure data integrity */
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* All entries in cache are invalidated on next clock cycle. */
                      CY_CACHE_CONTROL_REG |= CY_CACHE_CONTROL_FLUSH;
              
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 40  

                      /* Once this is executed it's guaranteed the cache has been flushed */
                      (void) CY_CACHE_CONTROL_REG;
              
                      /* Flush the pipeline */
                      CY_SYS_ISB;
              
                      /* Restore global interrupt enable state */
                      CyExitCriticalSection(interruptState);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetSysVector
                  ********************************************************************************
                  * Summary:
                  *  Sets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *  number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEM_MANAGE_IRQN         - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  *  address: Pointer to an interrupt service routine.
                  *
                  * Return:
                  *   The old ISR vector at this location.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetSysVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[number & CY_INT_SYS_NUMBER_MASK] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetSysVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 41  

                  *
                  * Parameters:
                  *  number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEMORY_MANAGEMENT_IRQN  - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  * Return:
                  *   Address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetSysVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      return ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *  address: Pointer to an interrupt service routine
                  *
                  * Return:
                  *   Previous interrupt vector value.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetVector
                  ********************************************************************************
                  *
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 42  

                  * Summary:
                  *  Gets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *
                  * Return:
                  *  The address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      return (ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyIntSetPriority(uint8 number, uint8 priority)
                  {
                      CYASSERT(priority <= CY_INT_PRIORITY_MAX);
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
                      CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] = (priority & CY_INT_PRIORITY_MASK)<< 5;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  Priority of the interrupt. 0 - 7, 0 being the highest.
                  *
                  *******************************************************************************/
                  uint8 CyIntGetPriority(uint8 number)
                  {
                      uint8 priority;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 43  

                      priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
              
                      return (priority);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetState
                  ********************************************************************************
                  *
                  * Summary:
                  *   Gets the enable state of the specified interrupt number.
                  *
                  * Parameters:
                  *   number: Valid range [0-31].  Interrupt number.
                  *
                  * Return:
                  *   Enable status: 1 if enabled, 0 if disabled
                  *
                  *******************************************************************************/
                  uint8 CyIntGetState(uint8 number)
                  {
                      reg32 * stateReg;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Get pointer to Interrupt enable register. */
                      stateReg = CY_INT_ENABLE_PTR;
              
                      /* Get state of interrupt. */
                      return (0u != (*stateReg & (((uint32) 1u) << (0x1Fu & number)))) ? ((uint8)(1u)) : ((uint8)(0u));
                  }
              
              
              #else   /* PSoC3 */
2629          
2630              /*******************************************************************************
2631              * Function Name: IntDefaultHandler
2632              ********************************************************************************
2633              *
2634              * Summary:
2635              *  This function is called for all interrupts, other than a reset that gets
2636              *  called before the system is setup.
2637              *
2638              * Parameters:
2639              *  None
2640              *
2641              * Return:
2642              *  None
2643              *
2644              * Theory:
2645              *  Any value other than zero is acceptable.
2646              *
2647              *******************************************************************************/
2648              CY_ISR(IntDefaultHandler)
2649              {
2650   1              #ifdef CY_BOOT_INT_DEFAULT_HANDLER_EXCEPTION_ENTRY_CALLBACK
                          CyBoot_IntDefaultHandler_Exception_EntryCallback();
                      #endif /* CY_BOOT_INT_DEFAULT_HANDLER_EXCEPTION_ENTRY_CALLBACK */
2653   1      
2654   1              while(1)
2655   1              {
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 44  

2656   2                  /***********************************************************************
2657   2                  * We must not get here. If we do, a serious problem occurs, so go
2658   2                  * into an infinite loop.
2659   2                  ***********************************************************************/
2660   2              }
2661   1          }
2662          
2663          
2664              /*******************************************************************************
2665              * Function Name: IntDefaultHandler
2666              ********************************************************************************
2667              *
2668              * Summary:
2669              *  This function is called during startup to initialize interrupt address vector
2670              *  registers with the address of the IntDefaultHandler().
2671              *
2672              * Parameters:
2673              *  None
2674              *
2675              * Return:
2676              *  None
2677              *
2678              *******************************************************************************/
2679              void CyIntInitVectors(void) 
2680              {
2681   1              uint8 i;
2682   1      
2683   1              for (i = 0; i <= CY_INT_NUMBER_MAX; i++)
2684   1              {
2685   2                  CY_SET_REG16(&CY_INT_VECT_TABLE[i], (uint16) &IntDefaultHandler);
2686   2              }
2687   1          }
2688          
2689          
2690              /*******************************************************************************
2691              * Function Name: CyIntSetVector
2692              ********************************************************************************
2693              *
2694              * Summary:
2695              *  Sets the interrupt vector of the specified interrupt number.
2696              *
2697              * Parameters:
2698              *  number:  Valid range [0-31].  Interrupt number
2699              *  address: Pointer to an interrupt service routine
2700              *
2701              * Return:
2702              *  Previous interrupt vector value.
2703              *
2704              *******************************************************************************/
2705              cyisraddress CyIntSetVector(uint8 number, cyisraddress address) 
2706              {
2707   1              cyisraddress oldIsr;
2708   1      
2709   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2710   1      
2711   1              /* Save old Interrupt service routine. */
2712   1              oldIsr = (cyisraddress) \
2713   1                          CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]);
2714   1      
2715   1              /* Set new Interrupt service routine. */
2716   1              CY_SET_REG16(&CY_INT_VECT_TABLE[number], (uint16) address);
2717   1      
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 45  

2718   1              return (oldIsr);
2719   1          }
2720          
2721          
2722              /*******************************************************************************
2723              * Function Name: CyIntGetVector
2724              ********************************************************************************
2725              *
2726              * Summary:
2727              *  Gets the interrupt vector of the specified interrupt number.
2728              *
2729              * Parameters:
2730              *  number: Valid range [0-31].  Interrupt number
2731              *
2732              * Return:
2733              *  Address of the ISR in the interrupt vector table.
2734              *
2735              *******************************************************************************/
2736              cyisraddress CyIntGetVector(uint8 number) 
2737              {
2738   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2739   1      
2740   1              return ((cyisraddress) \
2741   1                      CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]));
2742   1          }
2743          
2744          
2745              /*******************************************************************************
2746              * Function Name: CyIntSetPriority
2747              ********************************************************************************
2748              *
2749              * Summary:
2750              *  Sets the Priority of the Interrupt.
2751              *
2752              * Parameters:
2753              *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
2754              *  number:   The number of the interrupt, 0 - 31.
2755              *
2756              * Return:
2757              *  None
2758              *
2759              *******************************************************************************/
2760              void CyIntSetPriority(uint8 number, uint8 priority) 
2761              {
2762   1              CYASSERT(priority <= CY_INT_PRIORITY_MAX);
2763   1      
2764   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2765   1      
2766   1              CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] =
2767   1                          (priority & CY_INT_PRIORITY_MASK) << 5;
2768   1          }
2769          
2770          
2771              /*******************************************************************************
2772              * Function Name: CyIntGetPriority
2773              ********************************************************************************
2774              *
2775              * Summary:
2776              *  Gets the Priority of the Interrupt.
2777              *
2778              * Parameters:
2779              *  number: The number of the interrupt, 0 - 31.
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 46  

2780              *
2781              * Return:
2782              *  Priority of the interrupt. 0 - 7, 0 being the highest.
2783              *
2784              *******************************************************************************/
2785              uint8 CyIntGetPriority(uint8 number) 
2786              {
2787   1              uint8 priority;
2788   1      
2789   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2790   1      
2791   1              priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
2792   1      
2793   1              return (priority);
2794   1          }
2795          
2796          
2797              /*******************************************************************************
2798              * Function Name: CyIntGetState
2799              ********************************************************************************
2800              *
2801              * Summary:
2802              *   Gets the enable state of the specified interrupt number.
2803              *
2804              * Parameters:
2805              *   number: Valid range [0-31].  Interrupt number.
2806              *
2807              * Return:
2808              *   Enable status: 1 if enabled, 0 if disabled
2809              *
2810              *******************************************************************************/
2811              uint8 CyIntGetState(uint8 number) 
2812              {
2813   1              reg8 * stateReg;
2814   1      
2815   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2816   1      
2817   1              /* Get pointer to Interrupt enable register. */
2818   1              stateReg = CY_INT_ENABLE_PTR + ((number & CY_INT_NUMBER_MASK) >> 3u);
2819   1      
2820   1              /* Get state of interrupt. */
2821   1              return ((0u != (*stateReg & ((uint8)(1u << (0x07u & number))))) ? ((uint8)(1u)) : ((uint8)(0u)));
2822   1          }
2823          
2824          #endif  /* (CY_PSOC5) */
2825          
2826          
2827          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  /*******************************************************************************
                  * Function Name: CySetScPumps
                  ********************************************************************************
                  *
                  * Summary:
                  *  If 1 is passed as a parameter:
                  *   - if any of the SC blocks are used - enable pumps for the SC blocks and
                  *     start boost clock.
                  *   - For each enabled SC block set a boost clock index and enable the boost
                  *     clock.
                  *
                  *  If non-1 value is passed as a parameter:
                  *   - If all SC blocks are not used - disable pumps for the SC blocks and
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 47  

                  *     stop the boost clock.
                  *   - For each enabled SC block clear the boost clock index and disable the
                  *     boost clock.
                  *
                  *  The global variable CyScPumpEnabled is updated to be equal to passed the
                  *  parameter.
                  *
                  * Parameters:
                  *   uint8 enable: Enable/disable SC pumps and the boost clock for the enabled
                  *                 SC block:
                  *                 1 - Enable
                  *                 0 - Disable
                  *
                  * Return:
                  *   None
                  *
                  *******************************************************************************/
                  void CySetScPumps(uint8 enable) 
                  {
                      if(1u == enable)
                      {
                          /* The SC pumps should be enabled */
                          CyScPumpEnabled = 1u;
                          /* Enable pumps if any of SC blocks are used */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAPS_MASK))
                          {
                              CY_LIB_SC_MISC_REG |= CY_LIB_SC_MISC_PUMP_FORCE;
                              CyScBoostClk_Start();
                          }
                          /* Set positive pump for each enabled SC block: set clock index and enable it */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP0_EN))
                          {
                              CY_LIB_SC0_BST_REG = (CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC0_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP1_EN))
                          {
                              CY_LIB_SC1_BST_REG = (CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC1_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP2_EN))
                          {
                              CY_LIB_SC2_BST_REG = (CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC2_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP3_EN))
                          {
                              CY_LIB_SC3_BST_REG = (CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC3_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                      }
                      else
                      {
                          /* The SC pumps should be disabled */
                          CyScPumpEnabled = 0u;
                          /* Disable pumps for all SC blocks and stop boost clock */
                          CY_LIB_SC_MISC_REG &= ((uint8)(~CY_LIB_SC_MISC_PUMP_FORCE));
                          CyScBoostClk_Stop();
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 48  

                          /* Disable boost clock and clear clock index for each SC block */
                          CY_LIB_SC0_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC0_BST_REG = CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC1_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC1_BST_REG = CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC2_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC2_BST_REG = CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC3_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC3_BST_REG = CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                      }
                  }
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
2913          
2914          
2915          #if(CY_PSOC5)
                  /*******************************************************************************
                  * Function Name: CySysTickStart
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configures the SysTick timer to generate interrupt every 1 ms by call to the
                  *  CySysTickInit() function and starts it by calling CySysTickEnable() function.
                  *  Refer to the corresponding function description for the details.
              
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStart(void)
                  {
                      if (0u == CySysTickInitVar)
                      {
                          CySysTickInit();
                          CySysTickInitVar = 1u;
                      }
              
                      CySysTickEnable();
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickInit
                  ********************************************************************************
                  *
                  * Summary:
                  *  Initializes the callback addresses with pointers to NULL, associates the
                  *  SysTick system vector with the function that is responsible for calling
                  *  registered callback functions, configures SysTick timer to generate interrupt
                  *  every 1 ms.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 49  

                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set.
                  *
                  *  The 1 ms interrupt interval is configured based on the frequency determined
                  *  by PSoC Creator at build time. If System clock frequency is changed in
                  *  runtime, the CyDelayFreq() with the appropriate parameter should be called.
                  *
                  *******************************************************************************/
                  void CySysTickInit(void)
                  {
                      uint32 i;
              
                      for (i = 0u; i<CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                      {
                          CySysTickCallbacks[i] = (void *) 0;
                      }
              
                      (void) CyIntSetSysVector(CY_INT_SYSTICK_IRQN, &CySysTickServiceCallbacks);
                      CySysTickSetClockSource(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK);
                      CySysTickSetReload(cydelay_freq_hz/1000u);
                      CySysTickClear();
                      CyIntEnable(CY_INT_SYSTICK_IRQN);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnable
                  ********************************************************************************
                  *
                  * Summary:
                  *  Enables the SysTick timer and its interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnable(void)
                  {
                      CySysTickEnableInterrupt();
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickStop
                  ********************************************************************************
                  *
                  * Summary:
                  *  Stops the system timer (SysTick).
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 50  

                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStop(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnableInterrupt
                  ********************************************************************************
                  *
                  * Summary:
                  *  Enables the SysTick interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE_INT;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickDisableInterrupt
                  ********************************************************************************
                  *
                  * Summary:
                  *  Disables the SysTick interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickDisableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE_INT));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetReload
                  ********************************************************************************
                  *
                  * Summary:
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 51  

                  *  Sets value the counter is set to on startup and after it reaches zero. This
                  *  function do not change or reset current sysTick counter value, so it should
                  *  be cleared using CySysTickClear() API.
                  *
                  * Parameters:
                  *  value: Valid range [0x0-0x00FFFFFF]. Counter reset value.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickSetReload(uint32 value)
                  {
                      CY_SYS_SYST_RVR_REG = (value & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetReload
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets value the counter is set to on startup and after it reaches zero.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Counter reset value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetReload(void)
                  {
                      return(CY_SYS_SYST_RVR_REG & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetValue
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets current SysTick counter value.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Current SysTick counter value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetValue(void)
                  {
                      return(CY_SYS_SYST_CVR_REG & CY_SYS_SYST_CVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetClockSource
                  ********************************************************************************
                  *
                  * Summary:
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 52  

                  *  Sets the clock source for the SysTick counter.
                  *
                  *  Clears SysTick count flag if it was set. If clock source is not ready this
                  *  function call will have no effect. After changing clock source to the low
                  *  frequency clock the counter and reload register values will remain unchanged
                  *  so time to the interrupt will be significantly bigger and vice versa.
                  *
                  *  The function is not available on PSoC 4000, PSoC 4100, and PSoC 42000
                  *  devices. The SysTick timer clocked by the System clock on these devices.
                  *
                  * Parameters:
                  *  clockSource: Clock source for SysTick counter
                  *         Define                     Clock Source
                  *   CY_SYS_SYST_CSR_CLK_SRC_SYSCLK     SysTick is clocked by CPU clock.
                  *   CY_SYS_SYST_CSR_CLK_SRC_LFCLK      SysTick is clocked by the low frequency
                  *                                      clock. (ILO 100 KHz for PSoC 5LP, and
                  *                                      LFCLK for PSoC 4).
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickSetClockSource(uint32 clockSource)
                  {
                      if (clockSource == CY_SYS_SYST_CSR_CLK_SRC_SYSCLK)
                      {
                          CY_SYS_SYST_CSR_REG |= (uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_CLK_SOURCE_S
             -HIFT);
                      }
                      else
                      {
                          CY_SYS_SYST_CSR_REG &= ((uint32) ~((uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_
             -CLK_SOURCE_SHIFT)));
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCountFlag
                  ********************************************************************************
                  *
                  * Summary:
                  *  The count flag is set once SysTick counter reaches zero.
                  *   The flag cleared on read.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Returns non-zero value if flag is set, otherwise zero is returned.
                  *
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set.
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetCountFlag(void)
                  {
                      return ((CY_SYS_SYST_CSR_REG >> CY_SYS_SYST_CSR_COUNTFLAG_SHIFT) & 0x01u);
                  }
              
              
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 53  

                  /*******************************************************************************
                  * Function Name: CySysTickClear
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the SysTick counter for well-defined startup.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickClear(void)
                  {
                      CY_SYS_SYST_CVR_REG = 0u;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetCallback
                  ********************************************************************************
                  *
                  * Summary:
                  *  This function allows up to five user-defined interrupt service routine
                  *  functions to be associated with the SysTick interrupt. These are specified
                  *  through the use of pointers to the function.
                  *
                  *  To set a custom callback function without the overhead of the system provided
                  *  one, use CyIntSetSysVector(CY_INT_SYSTICK_IRQN, cyisraddress <address>),
                  *  where <address> is address of the custom defined interrupt service routine.
                  *  Note: a custom callback function overrides the system defined callback
                  *  functions.
                  *
                  * Parameters:
                  *  number: The number of the callback function addresses to be set. The valid
                  *          range is from 0 to 4.
                  *
                  *  void(*CallbackFunction(void): A pointer to the function that will be
                  *                                associated with the SysTick ISR for the
                  *                                specified number.
                  *
                  * Return:
                  *  Returns the address of the previous callback function.
                  *  The NULL is returned if the specified address in not set.
                  *
                  * Side Effects:
                  *  The registered callback functions will be executed in the interrupt.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickSetCallback(uint32 number, cySysTickCallback function)
                  {
                      cySysTickCallback retVal;
              
                      retVal = CySysTickCallbacks[number];
                      CySysTickCallbacks[number] = function;
                      return (retVal);
                  }
              
              
                  /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 54  

                  * Function Name: CySysTickGetCallback
                  ********************************************************************************
                  *
                  * Summary:
                  *  The function get the specified callback pointer.
                  *
                  * Parameters:
                  *  number: The number of callback function address to get. The valid
                  *          range is from 0 to 4.
                  *
                  * Return:
                  *  Returns the address of the specified callback function.
                  *  The NULL is returned if the specified address in not initialized.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickGetCallback(uint32 number)
                  {
                      return ((cySysTickCallback) CySysTickCallbacks[number]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickServiceCallbacks
                  ********************************************************************************
                  *
                  * Summary:
                  *  System Tick timer interrupt routine
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  static void CySysTickServiceCallbacks(void)
                  {
                      uint32 i;
              
                      /* Verify that tick timer flag was set */
                      if (1u == CySysTickGetCountFlag())
                      {
                          for (i=0u; i < CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                          {
                              if (CySysTickCallbacks[i] != (void *) 0)
                              {
                                  (void)(CySysTickCallbacks[i])();
                              }
                          }
                      }
                  }
              #endif /* (CY_PSOC5) */
3322          
3323          
3324          /*******************************************************************************
3325          * Function Name: CyGetUniqueId
3326          ********************************************************************************
3327          *
3328          * Summary:
3329          *  Returns the 64-bit unique ID of the device. The uniqueness of the number is
3330          *  guaranteed for 10 years due to the die lot number having a cycle life of 10
3331          *  years and even after 10 years, the probability of getting two identical
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 55  

3332          *  numbers is very small.
3333          *
3334          * Parameters:
3335          *  uniqueId: The pointer to a two element 32-bit unsigned integer array. Returns
3336          *  the 64-bit unique ID of the device by loading them into the integer array
3337          *  pointed to by uniqueId.
3338          *
3339          * Return:
3340          *  None
3341          *
3342          *******************************************************************************/
3343          void CyGetUniqueId(uint32* uniqueId)
3344          {
3345   1      #if(CY_PSOC4)
                  uniqueId[0u]  =  (uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT0  );
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT1  ) <<  8u);
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT2  ) << 16u);
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_WAFER ) << 24u);
              
                  uniqueId[1u]  =  (uint32)(* (reg8 *) CYREG_SFLASH_DIE_X     );
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_Y     ) <<  8u);
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_SORT  ) << 16u);
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_MINOR ) << 24u);
              #else
3356   1          uniqueId[0u]  =  (uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_LOT_LSB   ));
3357   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_LOT_MSB   )) <<  8
             -u);
3358   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_MLOGIC_REV_ID                )) << 16
             -u);
3359   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_WAFER_NUM )) << 24
             -u);
3360   1      
3361   1          uniqueId[1u]  =  (uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_X_LOC     ));
3362   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_Y_LOC     )) <<  8
             -u);
3363   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_WRK_WK    )) << 16
             -u);
3364   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_FAB_YR    )) << 24
             -u);
3365   1      #endif  /* (CY_PSOC4) */
3366   1      }
3367          
3368          /* [] END OF FILE */
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 56  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _CyPLL_OUT_Start (BEGIN)
                                           ; SOURCE LINE # 100
0000 900000      R     MOV     DPTR,#wait
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 101
                                           ; SOURCE LINE # 102
0005 E4                CLR     A
0006 A3                INC     DPTR
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 110
0008 904220            MOV     DPTR,#04220H
000B E0                MOVX    A,@DPTR
000C 4401              ORL     A,#01H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 112
000F 900000      R     MOV     DPTR,#wait
0012 E0                MOVX    A,@DPTR
0013 6059              JZ      ?C0001
                                           ; SOURCE LINE # 113
                                           ; SOURCE LINE # 115
0015 904300            MOV     DPTR,#04300H
0018 E0                MOVX    A,@DPTR
0019 5404              ANL     A,#04H
001B 900000      R     MOV     DPTR,#iloEnableState
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 116
001F 904380            MOV     DPTR,#04380H
0022 E0                MOVX    A,@DPTR
0023 900000      R     MOV     DPTR,#pmTwCfg0State
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 117
0027 904382            MOV     DPTR,#04382H
002A E0                MOVX    A,@DPTR
002B 900000      R     MOV     DPTR,#pmTwCfg2State
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 119
002F 7F18              MOV     R7,#018H
0031 120000      E     LCALL   _CyPmFtwSetInterval
                                           ; SOURCE LINE # 121
0034 900000      R     MOV     DPTR,#status
0037 7410              MOV     A,#010H
0039 F0                MOVX    @DPTR,A
003A         ?C0002:
                                           ; SOURCE LINE # 123
003A 7F01              MOV     R7,#01H
003C 120000      E     LCALL   _CyPmReadStatus
003F EF                MOV     A,R7
0040 20E012            JB      ACC.0,?C0003
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 126
0043 904225            MOV     DPTR,#04225H
0046 E0                MOVX    A,@DPTR
0047 5401              ANL     A,#01H
0049 60EF              JZ      ?C0002
                                           ; SOURCE LINE # 127
                                           ; SOURCE LINE # 128
004B E0                MOVX    A,@DPTR
004C 5401              ANL     A,#01H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 57  

004E 60EA              JZ      ?C0002
                                           ; SOURCE LINE # 129
                                           ; SOURCE LINE # 130
0050 E4                CLR     A
0051 900000      R     MOV     DPTR,#status
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 131
                                           ; SOURCE LINE # 132
                                           ; SOURCE LINE # 133
                                           ; SOURCE LINE # 134
0055         ?C0003:
                                           ; SOURCE LINE # 137
0055 900000      R     MOV     DPTR,#iloEnableState
0058 E0                MOVX    A,@DPTR
0059 7003              JNZ     ?C0006
                                           ; SOURCE LINE # 138
                                           ; SOURCE LINE # 139
005B 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 140
005E         ?C0006:
                                           ; SOURCE LINE # 142
005E 900000      R     MOV     DPTR,#pmTwCfg0State
0061 E0                MOVX    A,@DPTR
0062 904380            MOV     DPTR,#04380H
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 143
0066 900000      R     MOV     DPTR,#pmTwCfg2State
0069 E0                MOVX    A,@DPTR
006A 904382            MOV     DPTR,#04382H
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 144
006E         ?C0001:
                                           ; SOURCE LINE # 146
006E 900000      R     MOV     DPTR,#status
0071 E0                MOVX    A,@DPTR
0072 FF                MOV     R7,A
                                           ; SOURCE LINE # 147
0073         ?C0007:
0073 22                RET     
             ; FUNCTION _CyPLL_OUT_Start (END)

             ; FUNCTION CyPLL_OUT_Stop (BEGIN)
                                           ; SOURCE LINE # 164
                                           ; SOURCE LINE # 165
                                           ; SOURCE LINE # 166
0000 904220            MOV     DPTR,#04220H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 167
0007 22                RET     
             ; FUNCTION CyPLL_OUT_Stop (END)

             ; FUNCTION _CyPLL_OUT_SetPQ (BEGIN)
                                           ; SOURCE LINE # 202
0000 900000      R     MOV     DPTR,#pDiv
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 58  

0009 EB                MOV     A,R3
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 203
                                           ; SOURCE LINE # 205
000B 904220            MOV     DPTR,#04220H
000E E0                MOVX    A,@DPTR
000F 5401              ANL     A,#01H
0011 7003              JNZ     ?C0010
0013 D3                SETB    C
0014 8001              SJMP    ?C0011
0016         ?C0010:
0016 C3                CLR     C
0017         ?C0011:
0017 4005              JC      ?C0009
0019 7F00              MOV     R7,#00H
001B 120000      R     LCALL   _?CyHalt
001E         ?C0009:
                                           ; SOURCE LINE # 207
001E 900000      R     MOV     DPTR,#pDiv
0021 E0                MOVX    A,@DPTR
0022 C3                CLR     C
0023 9408              SUBB    A,#08H
0025 403D              JC      ?C0012
0027 A3                INC     DPTR
0028 E0                MOVX    A,@DPTR
0029 D3                SETB    C
002A 9410              SUBB    A,#010H
002C 5036              JNC     ?C0012
002E E0                MOVX    A,@DPTR
002F C3                CLR     C
0030 9401              SUBB    A,#01H
0032 4030              JC      ?C0012
0034 A3                INC     DPTR
0035 E0                MOVX    A,@DPTR
0036 9401              SUBB    A,#01H
0038 402A              JC      ?C0012
003A E0                MOVX    A,@DPTR
003B D3                SETB    C
003C 9407              SUBB    A,#07H
003E 5024              JNC     ?C0012
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 212
0040 900000      R     MOV     DPTR,#pDiv
0043 E0                MOVX    A,@DPTR
0044 904222            MOV     DPTR,#04222H
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 213
0048 900000      R     MOV     DPTR,#qDiv
004B E0                MOVX    A,@DPTR
004C 14                DEC     A
004D 904223            MOV     DPTR,#04223H
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 215
0051 900000      R     MOV     DPTR,#current
0054 E0                MOVX    A,@DPTR
0055 14                DEC     A
0056 FF                MOV     R7,A
0057 C4                SWAP    A
0058 54F0              ANL     A,#0F0H
005A FF                MOV     R7,A
005B 904221            MOV     DPTR,#04221H
005E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 59  

005F 548F              ANL     A,#08FH
0061 4F                ORL     A,R7
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 216
0063 22                RET     
0064         ?C0012:
                                           ; SOURCE LINE # 218
                                           ; SOURCE LINE # 225
0064 7F00              MOV     R7,#00H
0066 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 226
                                           ; SOURCE LINE # 228
0069         ?C0015:
0069 22                RET     
             ; FUNCTION _CyPLL_OUT_SetPQ (END)

             ; FUNCTION _CyPLL_OUT_SetSource (BEGIN)
                                           ; SOURCE LINE # 257
0000 900000      R     MOV     DPTR,#source
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 258
                                           ; SOURCE LINE # 260
0005 904220            MOV     DPTR,#04220H
0008 E0                MOVX    A,@DPTR
0009 5401              ANL     A,#01H
000B 7003              JNZ     ?C0017
000D D3                SETB    C
000E 8001              SJMP    ?C0018
0010         ?C0017:
0010 C3                CLR     C
0011         ?C0018:
0011 4005              JC      ?C0016
0013 7F00              MOV     R7,#00H
0015 120000      R     LCALL   _?CyHalt
0018         ?C0016:
                                           ; SOURCE LINE # 262
0018 900000      R     MOV     DPTR,#source
001B E0                MOVX    A,@DPTR
001C 120000      E     LCALL   ?C?CCASE
001F 0000        R     DW      ?C0022
0021 00                DB      00H
0022 0000        R     DW      ?C0022
0024 01                DB      01H
0025 0000        R     DW      ?C0022
0027 02                DB      02H
0028 0000              DW      00H
002A 0000        R     DW      ?C0023
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 266
002C         ?C0022:
                                           ; SOURCE LINE # 267
002C 904000            MOV     DPTR,#04000H
002F E0                MOVX    A,@DPTR
0030 54FC              ANL     A,#0FCH
0032 FF                MOV     R7,A
0033 900000      R     MOV     DPTR,#source
0036 E0                MOVX    A,@DPTR
0037 4F                ORL     A,R7
0038 904000            MOV     DPTR,#04000H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 60  

003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 268
003C 22                RET     
                                           ; SOURCE LINE # 270
003D         ?C0023:
                                           ; SOURCE LINE # 271
003D 7F00              MOV     R7,#00H
003F 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 272
                                           ; SOURCE LINE # 273
                                           ; SOURCE LINE # 274
0042         ?C0025:
0042 22                RET     
             ; FUNCTION _CyPLL_OUT_SetSource (END)

             ; FUNCTION _CyIMO_Start (BEGIN)
                                           ; SOURCE LINE # 307
0000 900000      R     MOV     DPTR,#wait
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 308
                                           ; SOURCE LINE # 314
0005 9043A0            MOV     DPTR,#043A0H
0008 E0                MOVX    A,@DPTR
0009 4410              ORL     A,#010H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 315
000C 9043B0            MOV     DPTR,#043B0H
000F E0                MOVX    A,@DPTR
0010 4410              ORL     A,#010H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 317
0013 900000      R     MOV     DPTR,#wait
0016 E0                MOVX    A,@DPTR
0017 6041              JZ      ?C0030
                                           ; SOURCE LINE # 318
                                           ; SOURCE LINE # 320
0019 904300            MOV     DPTR,#04300H
001C E0                MOVX    A,@DPTR
001D 5404              ANL     A,#04H
001F 900000      R     MOV     DPTR,#ilo100KhzEnable
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 321
0023 904380            MOV     DPTR,#04380H
0026 E0                MOVX    A,@DPTR
0027 900000      R     MOV     DPTR,#pmFtwCfg0Reg
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 322
002B 904382            MOV     DPTR,#04382H
002E E0                MOVX    A,@DPTR
002F 900000      R     MOV     DPTR,#pmFtwCfg2Reg
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 324
0033 E4                CLR     A
0034 FF                MOV     R7,A
0035 120000      E     LCALL   _CyPmFtwSetInterval
0038         ?C0027:
                                           ; SOURCE LINE # 326
0038 7F01              MOV     R7,#01H
003A 120000      E     LCALL   _CyPmReadStatus
003D EF                MOV     A,R7
003E 30E0F7            JNB     ACC.0,?C0027
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 61  

                                           ; SOURCE LINE # 327
                                           ; SOURCE LINE # 329
0041         ?C0028:
                                           ; SOURCE LINE # 331
0041 900000      R     MOV     DPTR,#ilo100KhzEnable
0044 E0                MOVX    A,@DPTR
0045 7003              JNZ     ?C0029
                                           ; SOURCE LINE # 332
                                           ; SOURCE LINE # 333
0047 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 334
004A         ?C0029:
                                           ; SOURCE LINE # 336
004A 900000      R     MOV     DPTR,#pmFtwCfg0Reg
004D E0                MOVX    A,@DPTR
004E 904380            MOV     DPTR,#04380H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 337
0052 900000      R     MOV     DPTR,#pmFtwCfg2Reg
0055 E0                MOVX    A,@DPTR
0056 904382            MOV     DPTR,#04382H
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 338
                                           ; SOURCE LINE # 339
005A         ?C0030:
005A 22                RET     
             ; FUNCTION _CyIMO_Start (END)

             ; FUNCTION CyIMO_Stop (BEGIN)
                                           ; SOURCE LINE # 356
                                           ; SOURCE LINE # 357
                                           ; SOURCE LINE # 358
0000 9043A0            MOV     DPTR,#043A0H
0003 E0                MOVX    A,@DPTR
0004 54EF              ANL     A,#0EFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 359
0007 9043B0            MOV     DPTR,#043B0H
000A E0                MOVX    A,@DPTR
000B 54EF              ANL     A,#0EFH
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 360
000E 22                RET     
             ; FUNCTION CyIMO_Stop (END)

             ; FUNCTION CyUSB_PowerOnCheck (BEGIN)
                                           ; SOURCE LINE # 377
                                           ; SOURCE LINE # 378
                                           ; SOURCE LINE # 379
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#poweredOn
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 385
0005 904393            MOV     DPTR,#04393H
0008 E0                MOVX    A,@DPTR
0009 5407              ANL     A,#07H
000B 7008              JNZ     ?C0034
000D 9043A5            MOV     DPTR,#043A5H
0010 E0                MOVX    A,@DPTR
0011 5401              ANL     A,#01H
0013 7012              JNZ     ?C0033
0015         ?C0034:
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 62  

0015 904393            MOV     DPTR,#04393H
0018 E0                MOVX    A,@DPTR
0019 5407              ANL     A,#07H
001B 6401              XRL     A,#01H
001D 700E              JNZ     ?C0032
001F 9043B5            MOV     DPTR,#043B5H
0022 E0                MOVX    A,@DPTR
0023 5401              ANL     A,#01H
0025 6006              JZ      ?C0032
0027         ?C0033:
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
0027 900000      R     MOV     DPTR,#poweredOn
002A 7401              MOV     A,#01H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 388
002D         ?C0032:
                                           ; SOURCE LINE # 390
002D 900000      R     MOV     DPTR,#poweredOn
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
                                           ; SOURCE LINE # 391
0032         ?C0035:
0032 22                RET     
             ; FUNCTION CyUSB_PowerOnCheck (END)

             ; FUNCTION _CyIMO_SetTrimValue (BEGIN)
                                           ; SOURCE LINE # 408
0000 900000      R     MOV     DPTR,#freq
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 409
                                           ; SOURCE LINE # 410
0005 120000      R     LCALL   CyUSB_PowerOnCheck
0008 900000      R     MOV     DPTR,#usbPowerOn
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 413
000D E0                MOVX    A,@DPTR
000E B40107            CJNE    A,#01H,?C0036
                                           ; SOURCE LINE # 414
                                           ; SOURCE LINE # 416
0011 906009            MOV     DPTR,#06009H
0014 E0                MOVX    A,@DPTR
0015 54FD              ANL     A,#0FDH
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 417
0018         ?C0036:
                                           ; SOURCE LINE # 418
0018 900000      R     MOV     DPTR,#freq
001B E0                MOVX    A,@DPTR
001C 120000      E     LCALL   ?C?CCASE
001F 0000        R     DW      ?C0038
0021 00                DB      00H
0022 0000        R     DW      ?C0039
0024 01                DB      01H
0025 0000        R     DW      ?C0040
0027 02                DB      02H
0028 0000        R     DW      ?C0041
002A 03                DB      03H
002B 0000        R     DW      ?C0042
002D 04                DB      04H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 63  

002E 0000        R     DW      ?C0043
0030 05                DB      05H
0031 0000        R     DW      ?C0044
0033 08                DB      08H
0034 0000              DW      00H
0036 0000        R     DW      ?C0046
                                           ; SOURCE LINE # 419
                                           ; SOURCE LINE # 420
0038         ?C0038:
                                           ; SOURCE LINE # 421
0038 7B0C              MOV     R3,#0CH
003A 7A01              MOV     R2,#01H
003C 7908              MOV     R1,#08H
003E 120000      E     LCALL   _cyread8
0041 9046A1            MOV     DPTR,#046A1H
0044 EF                MOV     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 422
0046 22                RET     
                                           ; SOURCE LINE # 424
0047         ?C0039:
                                           ; SOURCE LINE # 425
0047 7B0C              MOV     R3,#0CH
0049 7A01              MOV     R2,#01H
004B 7909              MOV     R1,#09H
004D 120000      E     LCALL   _cyread8
0050 9046A1            MOV     DPTR,#046A1H
0053 EF                MOV     A,R7
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 426
0055 22                RET     
                                           ; SOURCE LINE # 428
0056         ?C0040:
                                           ; SOURCE LINE # 429
0056 7B0C              MOV     R3,#0CH
0058 7A01              MOV     R2,#01H
005A 790A              MOV     R1,#0AH
005C 120000      E     LCALL   _cyread8
005F 9046A1            MOV     DPTR,#046A1H
0062 EF                MOV     A,R7
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 430
0064 22                RET     
                                           ; SOURCE LINE # 432
0065         ?C0041:
                                           ; SOURCE LINE # 433
0065 7B0C              MOV     R3,#0CH
0067 7A01              MOV     R2,#01H
0069 790B              MOV     R1,#0BH
006B 120000      E     LCALL   _cyread8
006E 9046A1            MOV     DPTR,#046A1H
0071 EF                MOV     A,R7
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 434
0073 22                RET     
                                           ; SOURCE LINE # 436
0074         ?C0042:
                                           ; SOURCE LINE # 437
0074 7B0C              MOV     R3,#0CH
0076 7A01              MOV     R2,#01H
0078 7989              MOV     R1,#089H
007A 120000      E     LCALL   _cyread8
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 64  

007D 9046A1            MOV     DPTR,#046A1H
0080 EF                MOV     A,R7
0081 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 438
0082 22                RET     
                                           ; SOURCE LINE # 440
0083         ?C0043:
                                           ; SOURCE LINE # 441
0083 7B0C              MOV     R3,#0CH
0085 7A01              MOV     R2,#01H
0087 790C              MOV     R1,#0CH
0089 120000      E     LCALL   _cyread8
008C 9046A1            MOV     DPTR,#046A1H
008F EF                MOV     A,R7
0090 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 442
0091 22                RET     
                                           ; SOURCE LINE # 450
0092         ?C0044:
                                           ; SOURCE LINE # 451
0092 7B0C              MOV     R3,#0CH
0094 7A01              MOV     R2,#01H
0096 790F              MOV     R1,#0FH
0098 120000      E     LCALL   _cyread8
009B 9046A1            MOV     DPTR,#046A1H
009E EF                MOV     A,R7
009F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 454
00A0 900000      R     MOV     DPTR,#usbPowerOn
00A3 E0                MOVX    A,@DPTR
00A4 B4010D            CJNE    A,#01H,?C0048
                                           ; SOURCE LINE # 455
                                           ; SOURCE LINE # 457
00A7 906009            MOV     DPTR,#06009H
00AA E0                MOVX    A,@DPTR
00AB 4402              ORL     A,#02H
00AD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 458
                                           ; SOURCE LINE # 459
00AE 22                RET     
                                           ; SOURCE LINE # 461
00AF         ?C0046:
                                           ; SOURCE LINE # 462
00AF 7F00              MOV     R7,#00H
00B1 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 463
                                           ; SOURCE LINE # 464
                                           ; SOURCE LINE # 466
00B4         ?C0048:
00B4 22                RET     
             ; FUNCTION _CyIMO_SetTrimValue (END)

             ; FUNCTION _CyIMO_SetFreq (BEGIN)
                                           ; SOURCE LINE # 503
0000 900000      R     MOV     DPTR,#freq
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 504
                                           ; SOURCE LINE # 515
0005 904200            MOV     DPTR,#04200H
0008 E0                MOVX    A,@DPTR
0009 5407              ANL     A,#07H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 65  

000B 900000      R     MOV     DPTR,#currentFreq
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 518
000F 900000      R     MOV     DPTR,#freq
0012 E0                MOVX    A,@DPTR
0013 B40804            CJNE    A,#08H,?C0049
0016 7F03              MOV     R7,#03H
0018 8005              SJMP    ?C0050
001A         ?C0049:
001A 900000      R     MOV     DPTR,#freq
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F         ?C0050:
001F 900000      R     MOV     DPTR,#nextFreq
0022 EF                MOV     A,R7
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 520
0024 900000      R     MOV     DPTR,#currentFreq
0027 E0                MOVX    A,@DPTR
0028 120000      E     LCALL   ?C?CCASE
002B 0000        R     DW      ?C0052
002D 00                DB      00H
002E 0000        R     DW      ?C0053
0030 01                DB      01H
0031 0000        R     DW      ?C0054
0033 02                DB      02H
0034 0000        R     DW      ?C0055
0036 03                DB      03H
0037 0000        R     DW      ?C0056
0039 04                DB      04H
003A 0000        R     DW      ?C0057
003C 05                DB      05H
003D 0000              DW      00H
003F 0000        R     DW      ?C0058
                                           ; SOURCE LINE # 521
                                           ; SOURCE LINE # 522
0041         ?C0052:
                                           ; SOURCE LINE # 523
0041 900000      R     MOV     DPTR,#currentFreq
0044 7402              MOV     A,#02H
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 524
0047 802C              SJMP    ?C0051
                                           ; SOURCE LINE # 526
0049         ?C0053:
                                           ; SOURCE LINE # 527
0049 900000      R     MOV     DPTR,#currentFreq
004C 7401              MOV     A,#01H
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 528
004F 8024              SJMP    ?C0051
                                           ; SOURCE LINE # 530
0051         ?C0054:
                                           ; SOURCE LINE # 531
0051 900000      R     MOV     DPTR,#currentFreq
0054 7403              MOV     A,#03H
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 532
0057 801C              SJMP    ?C0051
                                           ; SOURCE LINE # 534
0059         ?C0055:
                                           ; SOURCE LINE # 535
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 66  

0059 E4                CLR     A
005A 900000      R     MOV     DPTR,#currentFreq
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 536
005E 8015              SJMP    ?C0051
                                           ; SOURCE LINE # 538
0060         ?C0056:
                                           ; SOURCE LINE # 539
0060 900000      R     MOV     DPTR,#currentFreq
0063 7404              MOV     A,#04H
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 540
0066 800D              SJMP    ?C0051
                                           ; SOURCE LINE # 542
0068         ?C0057:
                                           ; SOURCE LINE # 543
0068 900000      R     MOV     DPTR,#currentFreq
006B 7405              MOV     A,#05H
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 544
006E 8005              SJMP    ?C0051
                                           ; SOURCE LINE # 552
0070         ?C0058:
                                           ; SOURCE LINE # 553
0070 7F00              MOV     R7,#00H
0072 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 554
                                           ; SOURCE LINE # 555
0075         ?C0051:
                                           ; SOURCE LINE # 557
0075 900000      R     MOV     DPTR,#currentFreq
0078 E0                MOVX    A,@DPTR
0079 FF                MOV     R7,A
007A A3                INC     DPTR
007B E0                MOVX    A,@DPTR
007C C3                CLR     C
007D 9F                SUBB    A,R7
007E 4008              JC      ?C0060
                                           ; SOURCE LINE # 558
                                           ; SOURCE LINE # 560
0080 900000      R     MOV     DPTR,#freq
0083 E0                MOVX    A,@DPTR
0084 FF                MOV     R7,A
0085 120000      R     LCALL   _CyIMO_SetTrimValue
                                           ; SOURCE LINE # 561
0088         ?C0060:
                                           ; SOURCE LINE # 564
0088 900000      R     MOV     DPTR,#freq
008B E0                MOVX    A,@DPTR
008C 120000      E     LCALL   ?C?CCASE
008F 0000        R     DW      ?C0062
0091 00                DB      00H
0092 0000        R     DW      ?C0063
0094 01                DB      01H
0095 0000        R     DW      ?C0064
0097 02                DB      02H
0098 0000        R     DW      ?C0065
009A 03                DB      03H
009B 0000        R     DW      ?C0066
009D 04                DB      04H
009E 0000        R     DW      ?C0067
00A0 05                DB      05H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 67  

00A1 0000        R     DW      ?C0068
00A3 08                DB      08H
00A4 0000              DW      00H
00A6 0000        R     DW      ?C0069
                                           ; SOURCE LINE # 565
                                           ; SOURCE LINE # 566
00A8         ?C0062:
                                           ; SOURCE LINE # 568
00A8 904200            MOV     DPTR,#04200H
00AB E0                MOVX    A,@DPTR
00AC 54F8              ANL     A,#0F8H
00AE 4403              ORL     A,#03H
00B0 54BF              ANL     A,#0BFH
00B2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 569
00B3 804D              SJMP    ?C0061
                                           ; SOURCE LINE # 571
00B5         ?C0063:
                                           ; SOURCE LINE # 573
00B5 904200            MOV     DPTR,#04200H
00B8 E0                MOVX    A,@DPTR
00B9 54F8              ANL     A,#0F8H
00BB 4401              ORL     A,#01H
00BD 54BF              ANL     A,#0BFH
00BF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 574
00C0 8040              SJMP    ?C0061
                                           ; SOURCE LINE # 576
00C2         ?C0064:
                                           ; SOURCE LINE # 578
00C2 904200            MOV     DPTR,#04200H
00C5 E0                MOVX    A,@DPTR
00C6 54B8              ANL     A,#0B8H
00C8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 579
00C9 8037              SJMP    ?C0061
                                           ; SOURCE LINE # 581
00CB         ?C0065:
                                           ; SOURCE LINE # 583
00CB 904200            MOV     DPTR,#04200H
00CE E0                MOVX    A,@DPTR
00CF 54F8              ANL     A,#0F8H
00D1 4402              ORL     A,#02H
00D3 54BF              ANL     A,#0BFH
00D5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 584
00D6 802A              SJMP    ?C0061
                                           ; SOURCE LINE # 586
00D8         ?C0066:
                                           ; SOURCE LINE # 588
00D8 904200            MOV     DPTR,#04200H
00DB E0                MOVX    A,@DPTR
00DC 54F8              ANL     A,#0F8H
00DE 4404              ORL     A,#04H
00E0 54BF              ANL     A,#0BFH
00E2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 589
00E3 801D              SJMP    ?C0061
                                           ; SOURCE LINE # 591
00E5         ?C0067:
                                           ; SOURCE LINE # 593
00E5 904200            MOV     DPTR,#04200H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 68  

00E8 E0                MOVX    A,@DPTR
00E9 54F8              ANL     A,#0F8H
00EB 4405              ORL     A,#05H
00ED 54BF              ANL     A,#0BFH
00EF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 594
00F0 8010              SJMP    ?C0061
                                           ; SOURCE LINE # 603
00F2         ?C0068:
                                           ; SOURCE LINE # 604
00F2 904200            MOV     DPTR,#04200H
00F5 E0                MOVX    A,@DPTR
00F6 54F8              ANL     A,#0F8H
00F8 4442              ORL     A,#042H
00FA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 606
00FB 8005              SJMP    ?C0061
                                           ; SOURCE LINE # 608
00FD         ?C0069:
                                           ; SOURCE LINE # 609
00FD 7F00              MOV     R7,#00H
00FF 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 610
                                           ; SOURCE LINE # 611
0102         ?C0061:
                                           ; SOURCE LINE # 614
0102 900000      R     MOV     DPTR,#freq
0105 E0                MOVX    A,@DPTR
0106 B40805            CJNE    A,#08H,?C0071
                                           ; SOURCE LINE # 615
                                           ; SOURCE LINE # 616
0109 120000      R     LCALL   CyIMO_EnableDoubler
                                           ; SOURCE LINE # 617
010C 8003              SJMP    ?C0072
010E         ?C0071:
                                           ; SOURCE LINE # 619
                                           ; SOURCE LINE # 620
010E 120000      R     LCALL   CyIMO_DisableDoubler
                                           ; SOURCE LINE # 621
0111         ?C0072:
                                           ; SOURCE LINE # 623
0111 900000      R     MOV     DPTR,#currentFreq
0114 E0                MOVX    A,@DPTR
0115 FF                MOV     R7,A
0116 A3                INC     DPTR
0117 E0                MOVX    A,@DPTR
0118 C3                CLR     C
0119 9F                SUBB    A,R7
011A 5008              JNC     ?C0074
                                           ; SOURCE LINE # 624
                                           ; SOURCE LINE # 626
011C 900000      R     MOV     DPTR,#freq
011F E0                MOVX    A,@DPTR
0120 FF                MOV     R7,A
0121 120000      R     LCALL   _CyIMO_SetTrimValue
                                           ; SOURCE LINE # 627
                                           ; SOURCE LINE # 628
0124         ?C0074:
0124 22                RET     
             ; FUNCTION _CyIMO_SetFreq (END)

             ; FUNCTION _CyIMO_SetSource (BEGIN)
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 69  

                                           ; SOURCE LINE # 658
0000 900000      R     MOV     DPTR,#source
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 660
0005 E0                MOVX    A,@DPTR
0006 120000      E     LCALL   ?C?CCASE
0009 0000        R     DW      ?C0078
000B 00                DB      00H
000C 0000        R     DW      ?C0077
000E 01                DB      01H
000F 0000        R     DW      ?C0076
0011 02                DB      02H
0012 0000              DW      00H
0014 0000        R     DW      ?C0079
                                           ; SOURCE LINE # 661
                                           ; SOURCE LINE # 662
0016         ?C0076:
                                           ; SOURCE LINE # 663
0016 904000            MOV     DPTR,#04000H
0019 E0                MOVX    A,@DPTR
001A 54BF              ANL     A,#0BFH
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 664
001D 904200            MOV     DPTR,#04200H
0020 E0                MOVX    A,@DPTR
0021 4420              ORL     A,#020H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 665
0024 22                RET     
                                           ; SOURCE LINE # 667
0025         ?C0077:
                                           ; SOURCE LINE # 668
0025 904000            MOV     DPTR,#04000H
0028 E0                MOVX    A,@DPTR
0029 4440              ORL     A,#040H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 669
002C 904200            MOV     DPTR,#04200H
002F E0                MOVX    A,@DPTR
0030 4420              ORL     A,#020H
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 670
0033 22                RET     
                                           ; SOURCE LINE # 672
0034         ?C0078:
                                           ; SOURCE LINE # 673
0034 904200            MOV     DPTR,#04200H
0037 E0                MOVX    A,@DPTR
0038 54DF              ANL     A,#0DFH
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 674
003B 22                RET     
                                           ; SOURCE LINE # 676
003C         ?C0079:
                                           ; SOURCE LINE # 678
003C 7F00              MOV     R7,#00H
003E 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 679
                                           ; SOURCE LINE # 680
                                           ; SOURCE LINE # 681
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 70  

0041         ?C0081:
0041 22                RET     
             ; FUNCTION _CyIMO_SetSource (END)

             ; FUNCTION CyIMO_EnableDoubler (BEGIN)
                                           ; SOURCE LINE # 699
                                           ; SOURCE LINE # 700
                                           ; SOURCE LINE # 702
0000 904200            MOV     DPTR,#04200H
0003 E0                MOVX    A,@DPTR
0004 4410              ORL     A,#010H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 703
0007 22                RET     
             ; FUNCTION CyIMO_EnableDoubler (END)

             ; FUNCTION CyIMO_DisableDoubler (BEGIN)
                                           ; SOURCE LINE # 720
                                           ; SOURCE LINE # 721
                                           ; SOURCE LINE # 722
0000 904200            MOV     DPTR,#04200H
0003 E0                MOVX    A,@DPTR
0004 54EF              ANL     A,#0EFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 723
0007 22                RET     
             ; FUNCTION CyIMO_DisableDoubler (END)

             ; FUNCTION _CyMasterClk_SetSource (BEGIN)
                                           ; SOURCE LINE # 755
0000 900000      R     MOV     DPTR,#source
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 756
                                           ; SOURCE LINE # 758
0005 E0                MOVX    A,@DPTR
0006 5403              ANL     A,#03H
0008 FF                MOV     R7,A
0009 904005            MOV     DPTR,#04005H
000C E0                MOVX    A,@DPTR
000D 54FC              ANL     A,#0FCH
000F 4F                ORL     A,R7
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 759
0011 22                RET     
             ; FUNCTION _CyMasterClk_SetSource (END)

             ; FUNCTION _CyMasterClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 790
0000 900000      R     MOV     DPTR,#divider
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 791
                                           ; SOURCE LINE # 792
0005 E0                MOVX    A,@DPTR
0006 904004            MOV     DPTR,#04004H
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 793
000A 22                RET     
             ; FUNCTION _CyMasterClk_SetDivider (END)

             ; FUNCTION _CyBusClk_Internal_SetDivider (BEGIN)
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 71  

                                           ; SOURCE LINE # 812
0000 900000      R     MOV     DPTR,#divider
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 813
                                           ; SOURCE LINE # 815
0008 904014            MOV     DPTR,#04014H
000B E0                MOVX    A,@DPTR
000C 54F0              ANL     A,#0F0H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 816
000F 904010            MOV     DPTR,#04010H
0012 E4                CLR     A
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 819
0014 904008            MOV     DPTR,#04008H
0017 E0                MOVX    A,@DPTR
0018 4480              ORL     A,#080H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 822
001B 900000      R     MOV     DPTR,#divider
001E E0                MOVX    A,@DPTR
001F A3                INC     DPTR
0020 E0                MOVX    A,@DPTR
0021 904002            MOV     DPTR,#04002H
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 823
0025 900000      R     MOV     DPTR,#divider
0028 E0                MOVX    A,@DPTR
0029 FE                MOV     R6,A
002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C EE                MOV     A,R6
002D 904003            MOV     DPTR,#04003H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 832
0031 904001            MOV     DPTR,#04001H
0034 E0                MOVX    A,@DPTR
0035 4401              ORL     A,#01H
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 833
0038 22                RET     
             ; FUNCTION _CyBusClk_Internal_SetDivider (END)

             ; FUNCTION _CyBusClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 859
0000 900000      R     MOV     DPTR,#divider
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 860
                                           ; SOURCE LINE # 865
0008 120000      E     LCALL   CyEnterCriticalSection
000B 900000      R     MOV     DPTR,#interruptState
000E EF                MOV     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 868
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 72  

0010 904007            MOV     DPTR,#04007H
0013 E0                MOVX    A,@DPTR
0014 900000      R     MOV     DPTR,#busClkDiv
0017 F0                MOVX    @DPTR,A
0018 A3                INC     DPTR
0019 E4                CLR     A
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 869
001B 900000      R     MOV     DPTR,#busClkDiv
001E E0                MOVX    A,@DPTR
001F FE                MOV     R6,A
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 904006            MOV     DPTR,#04006H
0026 E0                MOVX    A,@DPTR
0027 FD                MOV     R5,A
0028 EE                MOV     A,R6
0029 EF                MOV     A,R7
002A 4D                ORL     A,R5
002B FF                MOV     R7,A
002C 900000      R     MOV     DPTR,#busClkDiv
002F EE                MOV     A,R6
0030 F0                MOVX    @DPTR,A
0031 A3                INC     DPTR
0032 EF                MOV     A,R7
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 871
0034 900000      R     MOV     DPTR,#divider
0037 E0                MOVX    A,@DPTR
0038 FE                MOV     R6,A
0039 A3                INC     DPTR
003A E0                MOVX    A,@DPTR
003B 4E                ORL     A,R6
003C 600A              JZ      ?C0088
003E 900000      R     MOV     DPTR,#busClkDiv
0041 E0                MOVX    A,@DPTR
0042 FE                MOV     R6,A
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 4E                ORL     A,R6
0046 704D              JNZ     ?C0087
0048         ?C0088:
                                           ; SOURCE LINE # 872
                                           ; SOURCE LINE # 874
0048 904004            MOV     DPTR,#04004H
004B E0                MOVX    A,@DPTR
004C 900000      R     MOV     DPTR,#masterClkDiv
004F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 876
0050 E0                MOVX    A,@DPTR
0051 C3                CLR     C
0052 9407              SUBB    A,#07H
0054 5005              JNC     ?C0089
                                           ; SOURCE LINE # 877
                                           ; SOURCE LINE # 879
0056 7F07              MOV     R7,#07H
0058 120000      R     LCALL   _CyMasterClk_SetDivider
                                           ; SOURCE LINE # 880
005B         ?C0089:
                                           ; SOURCE LINE # 882
005B 900000      R     MOV     DPTR,#divider
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 73  

005E E0                MOVX    A,@DPTR
005F FE                MOV     R6,A
0060 A3                INC     DPTR
0061 E0                MOVX    A,@DPTR
0062 4E                ORL     A,R6
0063 7014              JNZ     ?C0090
                                           ; SOURCE LINE # 883
                                           ; SOURCE LINE # 885
0065 904008            MOV     DPTR,#04008H
0068 E0                MOVX    A,@DPTR
0069 4440              ORL     A,#040H
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 886
006C 900000      R     MOV     DPTR,#divider
006F E0                MOVX    A,@DPTR
0070 FE                MOV     R6,A
0071 A3                INC     DPTR
0072 E0                MOVX    A,@DPTR
0073 FF                MOV     R7,A
0074 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 887
0077 8012              SJMP    ?C0091
0079         ?C0090:
                                           ; SOURCE LINE # 889
                                           ; SOURCE LINE # 890
0079 900000      R     MOV     DPTR,#divider
007C E0                MOVX    A,@DPTR
007D FE                MOV     R6,A
007E A3                INC     DPTR
007F E0                MOVX    A,@DPTR
0080 FF                MOV     R7,A
0081 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 891
0084 904008            MOV     DPTR,#04008H
0087 E0                MOVX    A,@DPTR
0088 54BF              ANL     A,#0BFH
008A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 892
008B         ?C0091:
                                           ; SOURCE LINE # 895
008B 900000      R     MOV     DPTR,#masterClkDiv
008E E0                MOVX    A,@DPTR
008F FF                MOV     R7,A
0090 120000      R     LCALL   _CyMasterClk_SetDivider
                                           ; SOURCE LINE # 896
0093 800B              SJMP    ?C0092
0095         ?C0087:
                                           ; SOURCE LINE # 898
                                           ; SOURCE LINE # 899
0095 900000      R     MOV     DPTR,#divider
0098 E0                MOVX    A,@DPTR
0099 FE                MOV     R6,A
009A A3                INC     DPTR
009B E0                MOVX    A,@DPTR
009C FF                MOV     R7,A
009D 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 900
00A0         ?C0092:
                                           ; SOURCE LINE # 902
00A0 900000      R     MOV     DPTR,#interruptState
00A3 E0                MOVX    A,@DPTR
00A4 FF                MOV     R7,A
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 74  

00A5 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 903
00A8 22                RET     
             ; FUNCTION _CyBusClk_SetDivider (END)

             ; FUNCTION _CyCpuClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 932
0000 900000      R     MOV     DPTR,#divider
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 933
                                           ; SOURCE LINE # 935
0005 E0                MOVX    A,@DPTR
0006 FF                MOV     R7,A
0007 C4                SWAP    A
0008 54F0              ANL     A,#0F0H
000A FF                MOV     R7,A
000B 904005            MOV     DPTR,#04005H
000E E0                MOVX    A,@DPTR
000F 540F              ANL     A,#0FH
0011 4F                ORL     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 936
0013 22                RET     
             ; FUNCTION _CyCpuClk_SetDivider (END)

             ; FUNCTION _CyUsbClk_SetSource (BEGIN)
                                           ; SOURCE LINE # 959
0000 900000      R     MOV     DPTR,#source
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 960
                                           ; SOURCE LINE # 961
0005 E0                MOVX    A,@DPTR
0006 5403              ANL     A,#03H
0008 FF                MOV     R7,A
0009 904009            MOV     DPTR,#04009H
000C E0                MOVX    A,@DPTR
000D 54FC              ANL     A,#0FCH
000F 4F                ORL     A,R7
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 963
0011 22                RET     
             ; FUNCTION _CyUsbClk_SetSource (END)

             ; FUNCTION CyILO_Start1K (BEGIN)
                                           ; SOURCE LINE # 984
                                           ; SOURCE LINE # 985
                                           ; SOURCE LINE # 987
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4402              ORL     A,#02H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 988
0007 22                RET     
             ; FUNCTION CyILO_Start1K (END)

             ; FUNCTION CyILO_Stop1K (BEGIN)
                                           ; SOURCE LINE # 1012
                                           ; SOURCE LINE # 1013
                                           ; SOURCE LINE # 1015
0000 904300            MOV     DPTR,#04300H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 75  

0003 E0                MOVX    A,@DPTR
0004 54FD              ANL     A,#0FDH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1016
0007 22                RET     
             ; FUNCTION CyILO_Stop1K (END)

             ; FUNCTION CyILO_Start100K (BEGIN)
                                           ; SOURCE LINE # 1033
                                           ; SOURCE LINE # 1034
                                           ; SOURCE LINE # 1035
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1036
0007 22                RET     
             ; FUNCTION CyILO_Start100K (END)

             ; FUNCTION CyILO_Stop100K (BEGIN)
                                           ; SOURCE LINE # 1053
                                           ; SOURCE LINE # 1054
                                           ; SOURCE LINE # 1055
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1056
0007 22                RET     
             ; FUNCTION CyILO_Stop100K (END)

             ; FUNCTION CyILO_Enable33K (BEGIN)
                                           ; SOURCE LINE # 1076
                                           ; SOURCE LINE # 1077
                                           ; SOURCE LINE # 1079
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4420              ORL     A,#020H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1080
0007 22                RET     
             ; FUNCTION CyILO_Enable33K (END)

             ; FUNCTION CyILO_Disable33K (BEGIN)
                                           ; SOURCE LINE # 1100
                                           ; SOURCE LINE # 1101
                                           ; SOURCE LINE # 1102
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54DF              ANL     A,#0DFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1103
0007 22                RET     
             ; FUNCTION CyILO_Disable33K (END)

             ; FUNCTION _CyILO_SetSource (BEGIN)
                                           ; SOURCE LINE # 1124
0000 900000      R     MOV     DPTR,#source
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1125
                                           ; SOURCE LINE # 1127
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 76  

0005 E0                MOVX    A,@DPTR
0006 FF                MOV     R7,A
0007 25E0              ADD     A,ACC
0009 25E0              ADD     A,ACC
000B 540C              ANL     A,#0CH
000D FF                MOV     R7,A
000E 904000            MOV     DPTR,#04000H
0011 E0                MOVX    A,@DPTR
0012 54F3              ANL     A,#0F3H
0014 4F                ORL     A,R7
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1128
0016 22                RET     
             ; FUNCTION _CyILO_SetSource (END)

             ; FUNCTION _CyILO_SetPowerMode (BEGIN)
                                           ; SOURCE LINE # 1148
0000 900000      R     MOV     DPTR,#mode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1149
                                           ; SOURCE LINE # 1153
0005 904300            MOV     DPTR,#04300H
0008 E0                MOVX    A,@DPTR
0009 900000      R     MOV     DPTR,#state
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1156
000D 900000      R     MOV     DPTR,#mode
0010 E0                MOVX    A,@DPTR
0011 600A              JZ      ?C0103
                                           ; SOURCE LINE # 1157
                                           ; SOURCE LINE # 1158
0013 A3                INC     DPTR
0014 E0                MOVX    A,@DPTR
0015 4410              ORL     A,#010H
0017 904300            MOV     DPTR,#04300H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1159
001B 800A              SJMP    ?C0104
001D         ?C0103:
                                           ; SOURCE LINE # 1161
                                           ; SOURCE LINE # 1162
001D 900000      R     MOV     DPTR,#state
0020 E0                MOVX    A,@DPTR
0021 54EF              ANL     A,#0EFH
0023 904300            MOV     DPTR,#04300H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1163
0027         ?C0104:
                                           ; SOURCE LINE # 1166
0027 900000      R     MOV     DPTR,#state
002A E0                MOVX    A,@DPTR
002B 5410              ANL     A,#010H
002D FF                MOV     R7,A
002E E4                CLR     A
002F C4                SWAP    A
0030 F8                MOV     R0,A
0031 54F0              ANL     A,#0F0H
0033 C8                XCH     A,R0
0034 68                XRL     A,R0
0035 EF                MOV     A,R7
0036 C4                SWAP    A
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 77  

0037 540F              ANL     A,#0FH
0039 48                ORL     A,R0
003A FF                MOV     R7,A
                                           ; SOURCE LINE # 1167
003B         ?C0105:
003B 22                RET     
             ; FUNCTION _CyILO_SetPowerMode (END)

             ; FUNCTION CyXTAL_32KHZ_Start (BEGIN)
                                           ; SOURCE LINE # 1184
                                           ; SOURCE LINE # 1185
                                           ; SOURCE LINE # 1188
0000 90430A            MOV     DPTR,#0430AH
0003 74F3              MOV     A,#0F3H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1189
0006 904698            MOV     DPTR,#04698H
0009 7403              MOV     A,#03H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1190
000C 904309            MOV     DPTR,#04309H
000F E0                MOVX    A,@DPTR
0010 54F3              ANL     A,#0F3H
0012 4404              ORL     A,#04H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1194
0015 904308            MOV     DPTR,#04308H
0018 E0                MOVX    A,@DPTR
0019 4404              ORL     A,#04H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1198
001C E0                MOVX    A,@DPTR
001D 4401              ORL     A,#01H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1200
0020 900000      R     MOV     DPTR,#i
0023 7403              MOV     A,#03H
0025 F0                MOVX    @DPTR,A
0026 A3                INC     DPTR
0027 74E8              MOV     A,#0E8H
0029 F0                MOVX    @DPTR,A
002A         ?C0106:
002A 900000      R     MOV     DPTR,#i
002D E0                MOVX    A,@DPTR
002E FE                MOV     R6,A
002F A3                INC     DPTR
0030 E0                MOVX    A,@DPTR
0031 D3                SETB    C
0032 9400              SUBB    A,#00H
0034 EE                MOV     A,R6
0035 9400              SUBB    A,#00H
0037 4024              JC      ?C0110
                                           ; SOURCE LINE # 1201
                                           ; SOURCE LINE # 1202
0039 120000      R     LCALL   CyXTAL_32KHZ_ReadStatus
003C EF                MOV     A,R7
003D 30E506            JNB     ACC.5,?C0109
                                           ; SOURCE LINE # 1203
                                           ; SOURCE LINE # 1205
0040 E4                CLR     A
0041 FF                MOV     R7,A
0042 120000      R     LCALL   _CyXTAL_32KHZ_SetPowerMode
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 78  

                                           ; SOURCE LINE # 1207
0045 22                RET     
                                           ; SOURCE LINE # 1208
0046         ?C0109:
                                           ; SOURCE LINE # 1209
0046 7F01              MOV     R7,#01H
0048 7E00              MOV     R6,#00H
004A 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1210
004D 900000      R     MOV     DPTR,#i+01H
0050 E0                MOVX    A,@DPTR
0051 24FF              ADD     A,#0FFH
0053 F0                MOVX    @DPTR,A
0054 900000      R     MOV     DPTR,#i
0057 E0                MOVX    A,@DPTR
0058 34FF              ADDC    A,#0FFH
005A F0                MOVX    @DPTR,A
005B 80CD              SJMP    ?C0106
                                           ; SOURCE LINE # 1211
005D         ?C0110:
005D 22                RET     
             ; FUNCTION CyXTAL_32KHZ_Start (END)

             ; FUNCTION CyXTAL_32KHZ_Stop (BEGIN)
                                           ; SOURCE LINE # 1228
                                           ; SOURCE LINE # 1229
                                           ; SOURCE LINE # 1230
0000 90430A            MOV     DPTR,#0430AH
0003 74F3              MOV     A,#0F3H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1231
0006 904698            MOV     DPTR,#04698H
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1232
000B 904309            MOV     DPTR,#04309H
000E E0                MOVX    A,@DPTR
000F 54F3              ANL     A,#0F3H
0011 4404              ORL     A,#04H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1234
0014 904308            MOV     DPTR,#04308H
0017 E0                MOVX    A,@DPTR
0018 54FC              ANL     A,#0FCH
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1237
001B E0                MOVX    A,@DPTR
001C 54FB              ANL     A,#0FBH
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1239
001F 22                RET     
             ; FUNCTION CyXTAL_32KHZ_Stop (END)

             ; FUNCTION CyXTAL_32KHZ_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1259
                                           ; SOURCE LINE # 1260
                                           ; SOURCE LINE # 1261
0000 904308            MOV     DPTR,#04308H
0003 E0                MOVX    A,@DPTR
0004 5420              ANL     A,#020H
0006 FF                MOV     R7,A
                                           ; SOURCE LINE # 1262
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 79  

0007         ?C0112:
0007 22                RET     
             ; FUNCTION CyXTAL_32KHZ_ReadStatus (END)

             ; FUNCTION _CyXTAL_32KHZ_SetPowerMode (BEGIN)
                                           ; SOURCE LINE # 1283
0000 900000      R     MOV     DPTR,#mode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1284
                                           ; SOURCE LINE # 1285
0005 904308            MOV     DPTR,#04308H
0008 E0                MOVX    A,@DPTR
0009 5402              ANL     A,#02H
000B 6004              JZ      ?C0113
000D 7F01              MOV     R7,#01H
000F 8002              SJMP    ?C0114
0011         ?C0113:
0011 7F00              MOV     R7,#00H
0013         ?C0114:
0013 900000      R     MOV     DPTR,#state
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1287
0018 90430A            MOV     DPTR,#0430AH
001B 74F3              MOV     A,#0F3H
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1289
001E 900000      R     MOV     DPTR,#mode
0021 E0                MOVX    A,@DPTR
0022 6401              XRL     A,#01H
0024 7025              JNZ     ?C0115
                                           ; SOURCE LINE # 1290
                                           ; SOURCE LINE # 1292
0026 904698            MOV     DPTR,#04698H
0029 04                INC     A
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1293
002B 7F0A              MOV     R7,#0AH
002D 7E00              MOV     R6,#00H
002F 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1294
0032 904309            MOV     DPTR,#04309H
0035 E0                MOVX    A,@DPTR
0036 54F3              ANL     A,#0F3H
0038 4408              ORL     A,#08H
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1296
003B 7F14              MOV     R7,#014H
003D 7E00              MOV     R6,#00H
003F 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1297
0042 904308            MOV     DPTR,#04308H
0045 E0                MOVX    A,@DPTR
0046 4402              ORL     A,#02H
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1298
0049 801D              SJMP    ?C0116
004B         ?C0115:
                                           ; SOURCE LINE # 1300
                                           ; SOURCE LINE # 1302
004B 904698            MOV     DPTR,#04698H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 80  

004E 7406              MOV     A,#06H
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1303
0051 7F0A              MOV     R7,#0AH
0053 7E00              MOV     R6,#00H
0055 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1304
0058 904309            MOV     DPTR,#04309H
005B E0                MOVX    A,@DPTR
005C 54F3              ANL     A,#0F3H
005E 4404              ORL     A,#04H
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1306
0061 904308            MOV     DPTR,#04308H
0064 E0                MOVX    A,@DPTR
0065 54FD              ANL     A,#0FDH
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1307
0068         ?C0116:
                                           ; SOURCE LINE # 1309
0068 900000      R     MOV     DPTR,#state
006B E0                MOVX    A,@DPTR
006C FF                MOV     R7,A
                                           ; SOURCE LINE # 1310
006D         ?C0117:
006D 22                RET     
             ; FUNCTION _CyXTAL_32KHZ_SetPowerMode (END)

             ; FUNCTION _CyXTAL_Start (BEGIN)
                                           ; SOURCE LINE # 1349
0000 900000      R     MOV     DPTR,#wait
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1350
                                           ; SOURCE LINE # 1351
0005 E4                CLR     A
0006 A3                INC     DPTR
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1352
0008 900000      R     MOV     DPTR,#wait
000B E0                MOVX    A,@DPTR
000C 900000      R     MOV     DPTR,#timeout
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1360
0010 904210            MOV     DPTR,#04210H
0013 E0                MOVX    A,@DPTR
0014 4401              ORL     A,#01H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1363
0017 900000      R     MOV     DPTR,#wait
001A E0                MOVX    A,@DPTR
001B D3                SETB    C
001C 9400              SUBB    A,#00H
001E 5003              JNC     $ + 5H
0020 020000      R     LJMP    ?C0118
                                           ; SOURCE LINE # 1364
                                           ; SOURCE LINE # 1366
0023 904300            MOV     DPTR,#04300H
0026 E0                MOVX    A,@DPTR
0027 900000      R     MOV     DPTR,#iloEnableState
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1367
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 81  

002B 904380            MOV     DPTR,#04380H
002E E0                MOVX    A,@DPTR
002F 900000      R     MOV     DPTR,#pmTwCfg0Tmp
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1368
0033 904382            MOV     DPTR,#04382H
0036 E0                MOVX    A,@DPTR
0037 900000      R     MOV     DPTR,#pmTwCfg2Tmp
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1371
003B 7F18              MOV     R7,#018H
003D 120000      E     LCALL   _CyPmFtwSetInterval
                                           ; SOURCE LINE # 1372
0040 900000      R     MOV     DPTR,#status
0043 7410              MOV     A,#010H
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1375
0046         ?C0119:
0046 900000      R     MOV     DPTR,#timeout
0049 E0                MOVX    A,@DPTR
004A D3                SETB    C
004B 9400              SUBB    A,#00H
004D 403B              JC      ?C0120
                                           ; SOURCE LINE # 1376
                                           ; SOURCE LINE # 1378
004F 904210            MOV     DPTR,#04210H
0052 E0                MOVX    A,@DPTR
0053 FF                MOV     R7,A
                                           ; SOURCE LINE # 1381
0054 900000      R     MOV     DPTR,#count
0057 7404              MOV     A,#04H
0059 F0                MOVX    @DPTR,A
005A         ?C0122:
005A 900000      R     MOV     DPTR,#count
005D E0                MOVX    A,@DPTR
005E D3                SETB    C
005F 9400              SUBB    A,#00H
0061 4011              JC      ?C0123
                                           ; SOURCE LINE # 1382
0063         ?C0125:
                                           ; SOURCE LINE # 1383
0063 7F01              MOV     R7,#01H
0065 120000      E     LCALL   _CyPmReadStatus
0068 EF                MOV     A,R7
0069 30E0F7            JNB     ACC.0,?C0125
                                           ; SOURCE LINE # 1384
                                           ; SOURCE LINE # 1386
006C         ?C0126:
                                           ; SOURCE LINE # 1387
006C         ?C0124:
006C 900000      R     MOV     DPTR,#count
006F E0                MOVX    A,@DPTR
0070 14                DEC     A
0071 F0                MOVX    @DPTR,A
0072 80E6              SJMP    ?C0122
0074         ?C0123:
                                           ; SOURCE LINE # 1394
0074 904210            MOV     DPTR,#04210H
0077 E0                MOVX    A,@DPTR
0078 5480              ANL     A,#080H
007A 7006              JNZ     ?C0121
                                           ; SOURCE LINE # 1395
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 82  

                                           ; SOURCE LINE # 1396
007C 900000      R     MOV     DPTR,#status
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1397
0080 8008              SJMP    ?C0120
                                           ; SOURCE LINE # 1398
                                           ; SOURCE LINE # 1399
0082         ?C0121:
0082 900000      R     MOV     DPTR,#timeout
0085 E0                MOVX    A,@DPTR
0086 14                DEC     A
0087 F0                MOVX    @DPTR,A
0088 80BC              SJMP    ?C0119
008A         ?C0120:
                                           ; SOURCE LINE # 1403
008A 900000      R     MOV     DPTR,#iloEnableState
008D E0                MOVX    A,@DPTR
008E 5404              ANL     A,#04H
0090 7003              JNZ     ?C0128
                                           ; SOURCE LINE # 1404
                                           ; SOURCE LINE # 1405
0092 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 1406
0095         ?C0128:
                                           ; SOURCE LINE # 1407
0095 900000      R     MOV     DPTR,#pmTwCfg0Tmp
0098 E0                MOVX    A,@DPTR
0099 904380            MOV     DPTR,#04380H
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1408
009D 900000      R     MOV     DPTR,#pmTwCfg2Tmp
00A0 E0                MOVX    A,@DPTR
00A1 904382            MOV     DPTR,#04382H
00A4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1409
00A5         ?C0118:
                                           ; SOURCE LINE # 1411
00A5 900000      R     MOV     DPTR,#status
00A8 E0                MOVX    A,@DPTR
00A9 FF                MOV     R7,A
                                           ; SOURCE LINE # 1412
00AA         ?C0129:
00AA 22                RET     
             ; FUNCTION _CyXTAL_Start (END)

             ; FUNCTION CyXTAL_Stop (BEGIN)
                                           ; SOURCE LINE # 1429
                                           ; SOURCE LINE # 1430
                                           ; SOURCE LINE # 1432
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1433
0007 22                RET     
             ; FUNCTION CyXTAL_Stop (END)

             ; FUNCTION CyXTAL_EnableErrStatus (BEGIN)
                                           ; SOURCE LINE # 1451
                                           ; SOURCE LINE # 1452
                                           ; SOURCE LINE # 1454
0000 904210            MOV     DPTR,#04210H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 83  

0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1455
0007 22                RET     
             ; FUNCTION CyXTAL_EnableErrStatus (END)

             ; FUNCTION CyXTAL_DisableErrStatus (BEGIN)
                                           ; SOURCE LINE # 1473
                                           ; SOURCE LINE # 1474
                                           ; SOURCE LINE # 1476
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1477
0007 22                RET     
             ; FUNCTION CyXTAL_DisableErrStatus (END)

             ; FUNCTION CyXTAL_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1497
                                           ; SOURCE LINE # 1498
                                           ; SOURCE LINE # 1503
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 5480              ANL     A,#080H
0006 6004              JZ      ?C0133
0008 7F01              MOV     R7,#01H
000A 8002              SJMP    ?C0134
000C         ?C0133:
000C 7F00              MOV     R7,#00H
000E         ?C0134:
                                           ; SOURCE LINE # 1504
000E         ?C0135:
000E 22                RET     
             ; FUNCTION CyXTAL_ReadStatus (END)

             ; FUNCTION CyXTAL_EnableFaultRecovery (BEGIN)
                                           ; SOURCE LINE # 1524
                                           ; SOURCE LINE # 1525
                                           ; SOURCE LINE # 1526
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 4440              ORL     A,#040H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1527
0007 22                RET     
             ; FUNCTION CyXTAL_EnableFaultRecovery (END)

             ; FUNCTION CyXTAL_DisableFaultRecovery (BEGIN)
                                           ; SOURCE LINE # 1546
                                           ; SOURCE LINE # 1547
                                           ; SOURCE LINE # 1548
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54BF              ANL     A,#0BFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1549
0007 22                RET     
             ; FUNCTION CyXTAL_DisableFaultRecovery (END)

             ; FUNCTION _CyXTAL_SetStartup (BEGIN)
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 84  

                                           ; SOURCE LINE # 1572
0000 900000      R     MOV     DPTR,#setting
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1573
                                           ; SOURCE LINE # 1574
0005 E0                MOVX    A,@DPTR
0006 541F              ANL     A,#01FH
0008 FF                MOV     R7,A
0009 904212            MOV     DPTR,#04212H
000C E0                MOVX    A,@DPTR
000D 54E0              ANL     A,#0E0H
000F 4F                ORL     A,R7
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1576
0011 22                RET     
             ; FUNCTION _CyXTAL_SetStartup (END)

             ; FUNCTION _CyXTAL_SetFbVoltage (BEGIN)
                                           ; SOURCE LINE # 1596
0000 900000      R     MOV     DPTR,#setting
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1597
                                           ; SOURCE LINE # 1598
0005 E0                MOVX    A,@DPTR
0006 540F              ANL     A,#0FH
0008 FF                MOV     R7,A
0009 904213            MOV     DPTR,#04213H
000C E0                MOVX    A,@DPTR
000D 54F0              ANL     A,#0F0H
000F 4F                ORL     A,R7
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1600
0011 22                RET     
             ; FUNCTION _CyXTAL_SetFbVoltage (END)

             ; FUNCTION _CyXTAL_SetWdVoltage (BEGIN)
                                           ; SOURCE LINE # 1619
0000 900000      R     MOV     DPTR,#setting
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1620
                                           ; SOURCE LINE # 1622
0005 E0                MOVX    A,@DPTR
0006 FF                MOV     R7,A
0007 C4                SWAP    A
0008 54F0              ANL     A,#0F0H
000A 5470              ANL     A,#070H
000C FF                MOV     R7,A
000D 904213            MOV     DPTR,#04213H
0010 E0                MOVX    A,@DPTR
0011 548F              ANL     A,#08FH
0013 4F                ORL     A,R7
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1623
0015 22                RET     
             ; FUNCTION _CyXTAL_SetWdVoltage (END)

             ; FUNCTION _?CyHalt (BEGIN)
                                           ; SOURCE LINE # 1640
0000 90FFFF            MOV     DPTR,#0FFFFH
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 85  

0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1642
                                           ; SOURCE LINE # 1643
                                           ; SOURCE LINE # 1645
0008         ?C0141:
                                           ; SOURCE LINE # 1652
0008 9046EA            MOV     DPTR,#046EAH
000B 7401              MOV     A,#01H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1654
000E 900001            MOV     DPTR,#01H
0011 120000      E     LCALL   ?C?ADDXBP
0014 22                RET     
             ; FUNCTION _?CyHalt (END)

             ; FUNCTION CySoftwareReset (BEGIN)
                                           ; SOURCE LINE # 1671
                                           ; SOURCE LINE # 1672
                                           ; SOURCE LINE # 1673
0000 9046F6            MOV     DPTR,#046F6H
0003 E0                MOVX    A,@DPTR
0004 4401              ORL     A,#01H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1674
0007 22                RET     
             ; FUNCTION CySoftwareReset (END)

             ; FUNCTION _?CyDelay (BEGIN)
                                           ; SOURCE LINE # 1697
0000 90FFFC            MOV     DPTR,#0FFFCH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?LSTXDATA
0009         ?C0144:
                                           ; SOURCE LINE # 1699
0009 850083      E     MOV     DPH,?C_XBP
000C 850082      E     MOV     DPL,?C_XBP+01H
000F E0                MOVX    A,@DPTR
0010 A3                INC     DPTR
0011 E0                MOVX    A,@DPTR
0012 A3                INC     DPTR
0013 E0                MOVX    A,@DPTR
0014 FE                MOV     R6,A
0015 A3                INC     DPTR
0016 E0                MOVX    A,@DPTR
0017 D3                SETB    C
0018 9400              SUBB    A,#00H
001A EE                MOV     A,R6
001B 9480              SUBB    A,#080H
001D 403D              JC      ?C0145
                                           ; SOURCE LINE # 1700
                                           ; SOURCE LINE # 1705
001F 900000      R     MOV     DPTR,#cydelay_32k_ms
0022 E0                MOVX    A,@DPTR
0023 FC                MOV     R4,A
0024 A3                INC     DPTR
0025 E0                MOVX    A,@DPTR
0026 FD                MOV     R5,A
0027 A3                INC     DPTR
0028 E0                MOVX    A,@DPTR
0029 FE                MOV     R6,A
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 86  

002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
002D 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 1706
0030 850083      E     MOV     DPH,?C_XBP
0033 850082      E     MOV     DPL,?C_XBP+01H
0036 C083              PUSH    DPH
0038 C082              PUSH    DPL
003A E0                MOVX    A,@DPTR
003B FC                MOV     R4,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FD                MOV     R5,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FE                MOV     R6,A
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 2400              ADD     A,#00H
0046 FF                MOV     R7,A
0047 EE                MOV     A,R6
0048 3480              ADDC    A,#080H
004A FE                MOV     R6,A
004B ED                MOV     A,R5
004C 34FF              ADDC    A,#0FFH
004E FD                MOV     R5,A
004F EC                MOV     A,R4
0050 34FF              ADDC    A,#0FFH
0052 FC                MOV     R4,A
0053 D082              POP     DPL
0055 D083              POP     DPH
0057 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1707
005A 80AD              SJMP    ?C0144
005C         ?C0145:
                                           ; SOURCE LINE # 1709
005C 900000      R     MOV     DPTR,#cydelay_freq_khz
005F E0                MOVX    A,@DPTR
0060 FC                MOV     R4,A
0061 A3                INC     DPTR
0062 E0                MOVX    A,@DPTR
0063 FD                MOV     R5,A
0064 A3                INC     DPTR
0065 E0                MOVX    A,@DPTR
0066 FE                MOV     R6,A
0067 A3                INC     DPTR
0068 E0                MOVX    A,@DPTR
0069 FF                MOV     R7,A
006A 850083      E     MOV     DPH,?C_XBP
006D 850082      E     MOV     DPL,?C_XBP+01H
0070 E0                MOVX    A,@DPTR
0071 F8                MOV     R0,A
0072 A3                INC     DPTR
0073 E0                MOVX    A,@DPTR
0074 F9                MOV     R1,A
0075 A3                INC     DPTR
0076 E0                MOVX    A,@DPTR
0077 FA                MOV     R2,A
0078 A3                INC     DPTR
0079 E0                MOVX    A,@DPTR
007A FB                MOV     R3,A
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 87  

007B 120000      E     LCALL   ?C?LMUL
007E 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 1710
0081 900004            MOV     DPTR,#04H
0084 120000      E     LCALL   ?C?ADDXBP
0087 22                RET     
             ; FUNCTION _?CyDelay (END)

             ; FUNCTION _?CyDelayFreq (BEGIN)
                                           ; SOURCE LINE # 1768
0000 90FFFC            MOV     DPTR,#0FFFCH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1770
0009 850083      E     MOV     DPH,?C_XBP
000C 850082      E     MOV     DPL,?C_XBP+01H
000F E0                MOVX    A,@DPTR
0010 A3                INC     DPTR
0011 E0                MOVX    A,@DPTR
0012 A3                INC     DPTR
0013 E0                MOVX    A,@DPTR
0014 FE                MOV     R6,A
0015 A3                INC     DPTR
0016 E0                MOVX    A,@DPTR
0017 4E                ORL     A,R6
0018 6019              JZ      ?C0147
                                           ; SOURCE LINE # 1771
                                           ; SOURCE LINE # 1772
001A 850083      E     MOV     DPH,?C_XBP
001D 850082      E     MOV     DPL,?C_XBP+01H
0020 E0                MOVX    A,@DPTR
0021 FC                MOV     R4,A
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024 FD                MOV     R5,A
0025 A3                INC     DPTR
0026 E0                MOVX    A,@DPTR
0027 FE                MOV     R6,A
0028 A3                INC     DPTR
0029 E0                MOVX    A,@DPTR
002A FF                MOV     R7,A
002B 900000      R     MOV     DPTR,#cydelay_freq_hz
002E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1773
0031 800E              SJMP    ?C0148
0033         ?C0147:
                                           ; SOURCE LINE # 1775
                                           ; SOURCE LINE # 1776
0033 7F00              MOV     R7,#00H
0035 7E36              MOV     R6,#036H
0037 7D6E              MOV     R5,#06EH
0039 7C01              MOV     R4,#01H
003B 900000      R     MOV     DPTR,#cydelay_freq_hz
003E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1777
0041         ?C0148:
                                           ; SOURCE LINE # 1779
0041 900000      R     MOV     DPTR,#cydelay_freq_hz
0044 E0                MOVX    A,@DPTR
0045 FC                MOV     R4,A
0046 A3                INC     DPTR
0047 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 88  

0048 FD                MOV     R5,A
0049 A3                INC     DPTR
004A E0                MOVX    A,@DPTR
004B FE                MOV     R6,A
004C A3                INC     DPTR
004D E0                MOVX    A,@DPTR
004E 243F              ADD     A,#03FH
0050 FF                MOV     R7,A
0051 EE                MOV     A,R6
0052 3442              ADDC    A,#042H
0054 FE                MOV     R6,A
0055 ED                MOV     A,R5
0056 340F              ADDC    A,#0FH
0058 FD                MOV     R5,A
0059 E4                CLR     A
005A 3C                ADDC    A,R4
005B FC                MOV     R4,A
005C 7B40              MOV     R3,#040H
005E 7A42              MOV     R2,#042H
0060 790F              MOV     R1,#0FH
0062 7800              MOV     R0,#00H
0064 120000      E     LCALL   ?C?ULDIV
0067 900000      R     MOV     DPTR,#cydelay_freq_mhz
006A EF                MOV     A,R7
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1780
006C A3                INC     DPTR
006D E0                MOVX    A,@DPTR
006E FC                MOV     R4,A
006F A3                INC     DPTR
0070 E0                MOVX    A,@DPTR
0071 FD                MOV     R5,A
0072 A3                INC     DPTR
0073 E0                MOVX    A,@DPTR
0074 FE                MOV     R6,A
0075 A3                INC     DPTR
0076 E0                MOVX    A,@DPTR
0077 24E7              ADD     A,#0E7H
0079 FF                MOV     R7,A
007A EE                MOV     A,R6
007B 3403              ADDC    A,#03H
007D FE                MOV     R6,A
007E E4                CLR     A
007F 3D                ADDC    A,R5
0080 FD                MOV     R5,A
0081 E4                CLR     A
0082 3C                ADDC    A,R4
0083 FC                MOV     R4,A
0084 E4                CLR     A
0085 7BE8              MOV     R3,#0E8H
0087 7A03              MOV     R2,#03H
0089 F9                MOV     R1,A
008A F8                MOV     R0,A
008B 120000      E     LCALL   ?C?ULDIV
008E 900000      R     MOV     DPTR,#cydelay_freq_khz
0091 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1781
0094 E4                CLR     A
0095 FF                MOV     R7,A
0096 7E80              MOV     R6,#080H
0098 FD                MOV     R5,A
0099 FC                MOV     R4,A
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 89  

009A 900000      R     MOV     DPTR,#cydelay_freq_khz
009D E0                MOVX    A,@DPTR
009E F8                MOV     R0,A
009F A3                INC     DPTR
00A0 E0                MOVX    A,@DPTR
00A1 F9                MOV     R1,A
00A2 A3                INC     DPTR
00A3 E0                MOVX    A,@DPTR
00A4 FA                MOV     R2,A
00A5 A3                INC     DPTR
00A6 E0                MOVX    A,@DPTR
00A7 FB                MOV     R3,A
00A8 120000      E     LCALL   ?C?LMUL
00AB 900000      R     MOV     DPTR,#cydelay_32k_ms
00AE 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1782
00B1 900004            MOV     DPTR,#04H
00B4 120000      E     LCALL   ?C?ADDXBP
00B7 22                RET     
             ; FUNCTION _?CyDelayFreq (END)

             ; FUNCTION _CyWdtStart (BEGIN)
                                           ; SOURCE LINE # 1831
0000 900000      R     MOV     DPTR,#ticks
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1832
                                           ; SOURCE LINE # 1834
0008 900000      R     MOV     DPTR,#ticks
000B E0                MOVX    A,@DPTR
000C 5403              ANL     A,#03H
000E FF                MOV     R7,A
000F 904383            MOV     DPTR,#04383H
0012 E0                MOVX    A,@DPTR
0013 54FC              ANL     A,#0FCH
0015 4F                ORL     A,R7
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1837
0017 E0                MOVX    A,@DPTR
0018 4480              ORL     A,#080H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1838
001B E0                MOVX    A,@DPTR
001C 547F              ANL     A,#07FH
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1842
001F 900000      R     MOV     DPTR,#lpMode
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 C4                SWAP    A
0025 33                RLC     A
0026 54E0              ANL     A,#0E0H
0028 5460              ANL     A,#060H
002A FF                MOV     R7,A
002B 904383            MOV     DPTR,#04383H
002E E0                MOVX    A,@DPTR
002F 549F              ANL     A,#09FH
0031 4F                ORL     A,R7
0032 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 90  

                                           ; SOURCE LINE # 1845
0033 E0                MOVX    A,@DPTR
0034 4410              ORL     A,#010H
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1846
0037 22                RET     
             ; FUNCTION _CyWdtStart (END)

             ; FUNCTION CyWdtClear (BEGIN)
                                           ; SOURCE LINE # 1863
                                           ; SOURCE LINE # 1864
                                           ; SOURCE LINE # 1865
0000 904384            MOV     DPTR,#04384H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1866
0006 22                RET     
             ; FUNCTION CyWdtClear (END)

             ; FUNCTION _CyVdLvDigitEnable (BEGIN)
                                           ; SOURCE LINE # 1912
0000 900000      R     MOV     DPTR,#reset
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1913
                                           ; SOURCE LINE # 1917
0008 120000      E     LCALL   CyEnterCriticalSection
000B 900000      R     MOV     DPTR,#interruptState
000E EF                MOV     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1920
0010 9044C0            MOV     DPTR,#044C0H
0013 E0                MOVX    A,@DPTR
0014 5401              ANL     A,#01H
0016 FF                MOV     R7,A
0017 E4                CLR     A
0018 FC                MOV     R4,A
0019 FD                MOV     R5,A
001A FE                MOV     R6,A
001B 900000      R     MOV     DPTR,#intRegTmp
001E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1923
0021 9044C8            MOV     DPTR,#044C8H
0024 7401              MOV     A,#01H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1925
0027 9046F7            MOV     DPTR,#046F7H
002A E0                MOVX    A,@DPTR
002B 54BF              ANL     A,#0BFH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1928
002E 9046F4            MOV     DPTR,#046F4H
0031 E0                MOVX    A,@DPTR
0032 54F0              ANL     A,#0F0H
0034 FF                MOV     R7,A
0035 900000      R     MOV     DPTR,#threshold
0038 E0                MOVX    A,@DPTR
0039 540F              ANL     A,#0FH
003B 4F                ORL     A,R7
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 91  

003C 9046F4            MOV     DPTR,#046F4H
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1929
0040 A3                INC     DPTR
0041 E0                MOVX    A,@DPTR
0042 4401              ORL     A,#01H
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1932
0045 7F01              MOV     R7,#01H
0047 7E00              MOV     R6,#00H
0049 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1934
004C 7F01              MOV     R7,#01H
004E 120000      R     LCALL   _CyVdStickyStatus
                                           ; SOURCE LINE # 1936
0051 900000      R     MOV     DPTR,#reset
0054 E0                MOVX    A,@DPTR
0055 6009              JZ      ?C0152
                                           ; SOURCE LINE # 1937
                                           ; SOURCE LINE # 1938
0057 9046F7            MOV     DPTR,#046F7H
005A E0                MOVX    A,@DPTR
005B 4440              ORL     A,#040H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1939
005E 8007              SJMP    ?C0153
0060         ?C0152:
                                           ; SOURCE LINE # 1941
                                           ; SOURCE LINE # 1942
0060 9046F7            MOV     DPTR,#046F7H
0063 E0                MOVX    A,@DPTR
0064 54BF              ANL     A,#0BFH
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1943
0067         ?C0153:
                                           ; SOURCE LINE # 1946
0067 9044D8            MOV     DPTR,#044D8H
006A 7401              MOV     A,#01H
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1949
006D 900000      R     MOV     DPTR,#intRegTmp
0070 E0                MOVX    A,@DPTR
0071 A3                INC     DPTR
0072 E0                MOVX    A,@DPTR
0073 A3                INC     DPTR
0074 E0                MOVX    A,@DPTR
0075 A3                INC     DPTR
0076 E0                MOVX    A,@DPTR
0077 9044C0            MOV     DPTR,#044C0H
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1951
007B 900000      R     MOV     DPTR,#interruptState
007E E0                MOVX    A,@DPTR
007F FF                MOV     R7,A
0080 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1952
0083 22                RET     
             ; FUNCTION _CyVdLvDigitEnable (END)

             ; FUNCTION _CyVdLvAnalogEnable (BEGIN)
                                           ; SOURCE LINE # 1997
0000 900000      R     MOV     DPTR,#reset
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 92  

0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1998
                                           ; SOURCE LINE # 2002
0008 120000      E     LCALL   CyEnterCriticalSection
000B 900000      R     MOV     DPTR,#interruptState
000E EF                MOV     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2005
0010 9044C0            MOV     DPTR,#044C0H
0013 E0                MOVX    A,@DPTR
0014 5401              ANL     A,#01H
0016 FF                MOV     R7,A
0017 E4                CLR     A
0018 FC                MOV     R4,A
0019 FD                MOV     R5,A
001A FE                MOV     R6,A
001B 900000      R     MOV     DPTR,#intRegTmp
001E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2008
0021 9044C8            MOV     DPTR,#044C8H
0024 7401              MOV     A,#01H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2010
0027 9046F7            MOV     DPTR,#046F7H
002A E0                MOVX    A,@DPTR
002B 547F              ANL     A,#07FH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2012
002E 900000      R     MOV     DPTR,#threshold
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 C4                SWAP    A
0034 54F0              ANL     A,#0F0H
0036 FF                MOV     R7,A
0037 9046F4            MOV     DPTR,#046F4H
003A E0                MOVX    A,@DPTR
003B 540F              ANL     A,#0FH
003D 4F                ORL     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2013
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 4402              ORL     A,#02H
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2016
0044 7F01              MOV     R7,#01H
0046 7E00              MOV     R6,#00H
0048 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 2018
004B 7F02              MOV     R7,#02H
004D 120000      R     LCALL   _CyVdStickyStatus
                                           ; SOURCE LINE # 2020
0050 900000      R     MOV     DPTR,#reset
0053 E0                MOVX    A,@DPTR
0054 6009              JZ      ?C0155
                                           ; SOURCE LINE # 2021
                                           ; SOURCE LINE # 2022
0056 9046F7            MOV     DPTR,#046F7H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 93  

0059 E0                MOVX    A,@DPTR
005A 4480              ORL     A,#080H
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2023
005D 8007              SJMP    ?C0156
005F         ?C0155:
                                           ; SOURCE LINE # 2025
                                           ; SOURCE LINE # 2026
005F 9046F7            MOV     DPTR,#046F7H
0062 E0                MOVX    A,@DPTR
0063 547F              ANL     A,#07FH
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2027
0066         ?C0156:
                                           ; SOURCE LINE # 2030
0066 9044D8            MOV     DPTR,#044D8H
0069 7401              MOV     A,#01H
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2033
006C 900000      R     MOV     DPTR,#intRegTmp
006F E0                MOVX    A,@DPTR
0070 A3                INC     DPTR
0071 E0                MOVX    A,@DPTR
0072 A3                INC     DPTR
0073 E0                MOVX    A,@DPTR
0074 A3                INC     DPTR
0075 E0                MOVX    A,@DPTR
0076 9044C0            MOV     DPTR,#044C0H
0079 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2035
007A 900000      R     MOV     DPTR,#interruptState
007D E0                MOVX    A,@DPTR
007E FF                MOV     R7,A
007F 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2036
0082 22                RET     
             ; FUNCTION _CyVdLvAnalogEnable (END)

             ; FUNCTION CyVdLvDigitDisable (BEGIN)
                                           ; SOURCE LINE # 2058
                                           ; SOURCE LINE # 2059
                                           ; SOURCE LINE # 2060
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2061
0007 9046F7            MOV     DPTR,#046F7H
000A E0                MOVX    A,@DPTR
000B 54BF              ANL     A,#0BFH
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2062
000E 7F01              MOV     R7,#01H
0010 120000      R     LCALL   _CyVdStickyStatus
0013         ?C0158:
                                           ; SOURCE LINE # 2064
0013 7F01              MOV     R7,#01H
0015 120000      R     LCALL   _CyVdStickyStatus
0018 EF                MOV     A,R7
0019 20E0F7            JB      ACC.0,?C0158
                                           ; SOURCE LINE # 2065
                                           ; SOURCE LINE # 2067
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 94  

001C         ?C0159:
                                           ; SOURCE LINE # 2068
001C         ?C0160:
001C 22                RET     
             ; FUNCTION CyVdLvDigitDisable (END)

             ; FUNCTION CyVdLvAnalogDisable (BEGIN)
                                           ; SOURCE LINE # 2090
                                           ; SOURCE LINE # 2091
                                           ; SOURCE LINE # 2092
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FD              ANL     A,#0FDH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2093
0007 9046F7            MOV     DPTR,#046F7H
000A E0                MOVX    A,@DPTR
000B 547F              ANL     A,#07FH
000D F0                MOVX    @DPTR,A
000E         ?C0161:
                                           ; SOURCE LINE # 2094
000E 7F02              MOV     R7,#02H
0010 120000      R     LCALL   _CyVdStickyStatus
0013 EF                MOV     A,R7
0014 20E1F7            JB      ACC.1,?C0161
                                           ; SOURCE LINE # 2095
                                           ; SOURCE LINE # 2097
0017         ?C0162:
                                           ; SOURCE LINE # 2098
0017         ?C0163:
0017 22                RET     
             ; FUNCTION CyVdLvAnalogDisable (END)

             ; FUNCTION CyVdHvAnalogEnable (BEGIN)
                                           ; SOURCE LINE # 2120
                                           ; SOURCE LINE # 2121
                                           ; SOURCE LINE # 2125
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#interruptState
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2128
0008 9044C0            MOV     DPTR,#044C0H
000B E0                MOVX    A,@DPTR
000C 5401              ANL     A,#01H
000E FF                MOV     R7,A
000F E4                CLR     A
0010 FC                MOV     R4,A
0011 FD                MOV     R5,A
0012 FE                MOV     R6,A
0013 900000      R     MOV     DPTR,#intRegTmp
0016 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2131
0019 9044C8            MOV     DPTR,#044C8H
001C 7401              MOV     A,#01H
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2133
001F 9046F7            MOV     DPTR,#046F7H
0022 E0                MOVX    A,@DPTR
0023 547F              ANL     A,#07FH
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2135
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 95  

0026 9046F5            MOV     DPTR,#046F5H
0029 E0                MOVX    A,@DPTR
002A 4404              ORL     A,#04H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2138
002D 7F01              MOV     R7,#01H
002F 7E00              MOV     R6,#00H
0031 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 2140
0034 7F04              MOV     R7,#04H
0036 120000      R     LCALL   _CyVdStickyStatus
                                           ; SOURCE LINE # 2143
0039 9044D8            MOV     DPTR,#044D8H
003C 7401              MOV     A,#01H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2146
003F 900000      R     MOV     DPTR,#intRegTmp
0042 E0                MOVX    A,@DPTR
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 A3                INC     DPTR
0046 E0                MOVX    A,@DPTR
0047 A3                INC     DPTR
0048 E0                MOVX    A,@DPTR
0049 9044C0            MOV     DPTR,#044C0H
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2148
004D 900000      R     MOV     DPTR,#interruptState
0050 E0                MOVX    A,@DPTR
0051 FF                MOV     R7,A
0052 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2149
0055 22                RET     
             ; FUNCTION CyVdHvAnalogEnable (END)

             ; FUNCTION CyVdHvAnalogDisable (BEGIN)
                                           ; SOURCE LINE # 2171
                                           ; SOURCE LINE # 2172
                                           ; SOURCE LINE # 2173
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
0007         ?C0165:
                                           ; SOURCE LINE # 2174
0007 7F04              MOV     R7,#04H
0009 120000      R     LCALL   _CyVdStickyStatus
000C EF                MOV     A,R7
000D 20E2F7            JB      ACC.2,?C0165
                                           ; SOURCE LINE # 2175
                                           ; SOURCE LINE # 2177
0010         ?C0166:
                                           ; SOURCE LINE # 2178
0010         ?C0167:
0010 22                RET     
             ; FUNCTION CyVdHvAnalogDisable (END)

             ; FUNCTION _CyVdStickyStatus (BEGIN)
                                           ; SOURCE LINE # 2209
0000 900000      R     MOV     DPTR,#mask
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 96  

                                           ; SOURCE LINE # 2210
                                           ; SOURCE LINE # 2215
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#interruptState
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2217
000D 900000      R     MOV     DPTR,#interruptStatus
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 9046FA            MOV     DPTR,#046FAH
0015 E0                MOVX    A,@DPTR
0016 FE                MOV     R6,A
0017 EF                MOV     A,R7
0018 4E                ORL     A,R6
0019 900000      R     MOV     DPTR,#interruptStatus
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2218
001D E0                MOVX    A,@DPTR
001E 5407              ANL     A,#07H
0020 900000      R     MOV     DPTR,#tmpStatus
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2219
0024 900000      R     MOV     DPTR,#interruptStatus
0027 E0                MOVX    A,@DPTR
0028 FF                MOV     R7,A
0029 900000      R     MOV     DPTR,#mask
002C E0                MOVX    A,@DPTR
002D F4                CPL     A
002E FE                MOV     R6,A
002F EF                MOV     A,R7
0030 5E                ANL     A,R6
0031 900000      R     MOV     DPTR,#interruptStatus
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2221
0035 900000      R     MOV     DPTR,#interruptState
0038 E0                MOVX    A,@DPTR
0039 FF                MOV     R7,A
003A 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2223
003D 900000      R     MOV     DPTR,#tmpStatus
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
                                           ; SOURCE LINE # 2224
0042         ?C0168:
0042 22                RET     
             ; FUNCTION _CyVdStickyStatus (END)

             ; FUNCTION CyVdRealTimeStatus (BEGIN)
                                           ; SOURCE LINE # 2253
                                           ; SOURCE LINE # 2254
                                           ; SOURCE LINE # 2258
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#interruptState
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2259
0008 9046FC            MOV     DPTR,#046FCH
000B E0                MOVX    A,@DPTR
000C 5407              ANL     A,#07H
000E 900000      R     MOV     DPTR,#vdFlagsState
0011 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 97  

                                           ; SOURCE LINE # 2260
0012 900000      R     MOV     DPTR,#interruptState
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2262
001A 900000      R     MOV     DPTR,#vdFlagsState
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
                                           ; SOURCE LINE # 2263
001F         ?C0169:
001F 22                RET     
             ; FUNCTION CyVdRealTimeStatus (END)

             ; FUNCTION CyDisableInts (BEGIN)
                                           ; SOURCE LINE # 2280
                                           ; SOURCE LINE # 2281
                                           ; SOURCE LINE # 2285
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#interruptState
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2290
0008 9044C8            MOV     DPTR,#044C8H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D E4                CLR     A
000E FC                MOV     R4,A
000F FD                MOV     R5,A
0010 FE                MOV     R6,A
0011 900000      R     MOV     DPTR,#intState
0014 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2291
0017 900000      R     MOV     DPTR,#intState
001A E0                MOVX    A,@DPTR
001B FC                MOV     R4,A
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E FD                MOV     R5,A
001F A3                INC     DPTR
0020 E0                MOVX    A,@DPTR
0021 FE                MOV     R6,A
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024 FF                MOV     R7,A
0025 C004              PUSH    AR4
0027 C005              PUSH    AR5
0029 C006              PUSH    AR6
002B C007              PUSH    AR7
002D 9044C9            MOV     DPTR,#044C9H
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 E4                CLR     A
0033 FC                MOV     R4,A
0034 FD                MOV     R5,A
0035 FE                MOV     R6,A
0036 7808              MOV     R0,#08H
0038 120000      E     LCALL   ?C?LSHL
003B A804              MOV     R0,AR4
003D A905              MOV     R1,AR5
003F AA06              MOV     R2,AR6
0041 AB07              MOV     R3,AR7
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 98  

0043 D007              POP     AR7
0045 D006              POP     AR6
0047 D005              POP     AR5
0049 D004              POP     AR4
004B EF                MOV     A,R7
004C 4B                ORL     A,R3
004D FF                MOV     R7,A
004E EE                MOV     A,R6
004F 4A                ORL     A,R2
0050 FE                MOV     R6,A
0051 ED                MOV     A,R5
0052 49                ORL     A,R1
0053 FD                MOV     R5,A
0054 EC                MOV     A,R4
0055 48                ORL     A,R0
0056 FC                MOV     R4,A
0057 900000      R     MOV     DPTR,#intState
005A 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2292
005D 900000      R     MOV     DPTR,#intState
0060 E0                MOVX    A,@DPTR
0061 FC                MOV     R4,A
0062 A3                INC     DPTR
0063 E0                MOVX    A,@DPTR
0064 FD                MOV     R5,A
0065 A3                INC     DPTR
0066 E0                MOVX    A,@DPTR
0067 FE                MOV     R6,A
0068 A3                INC     DPTR
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B C004              PUSH    AR4
006D C005              PUSH    AR5
006F C006              PUSH    AR6
0071 C007              PUSH    AR7
0073 9044CA            MOV     DPTR,#044CAH
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 E4                CLR     A
0079 FC                MOV     R4,A
007A FD                MOV     R5,A
007B FE                MOV     R6,A
007C 7810              MOV     R0,#010H
007E 120000      E     LCALL   ?C?LSHL
0081 A804              MOV     R0,AR4
0083 A905              MOV     R1,AR5
0085 AA06              MOV     R2,AR6
0087 AB07              MOV     R3,AR7
0089 D007              POP     AR7
008B D006              POP     AR6
008D D005              POP     AR5
008F D004              POP     AR4
0091 EF                MOV     A,R7
0092 4B                ORL     A,R3
0093 FF                MOV     R7,A
0094 EE                MOV     A,R6
0095 4A                ORL     A,R2
0096 FE                MOV     R6,A
0097 ED                MOV     A,R5
0098 49                ORL     A,R1
0099 FD                MOV     R5,A
009A EC                MOV     A,R4
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 99  

009B 48                ORL     A,R0
009C FC                MOV     R4,A
009D 900000      R     MOV     DPTR,#intState
00A0 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2293
00A3 900000      R     MOV     DPTR,#intState
00A6 E0                MOVX    A,@DPTR
00A7 FC                MOV     R4,A
00A8 A3                INC     DPTR
00A9 E0                MOVX    A,@DPTR
00AA FD                MOV     R5,A
00AB A3                INC     DPTR
00AC E0                MOVX    A,@DPTR
00AD FE                MOV     R6,A
00AE A3                INC     DPTR
00AF E0                MOVX    A,@DPTR
00B0 FF                MOV     R7,A
00B1 C004              PUSH    AR4
00B3 C005              PUSH    AR5
00B5 C006              PUSH    AR6
00B7 C007              PUSH    AR7
00B9 9044CB            MOV     DPTR,#044CBH
00BC E0                MOVX    A,@DPTR
00BD FF                MOV     R7,A
00BE E4                CLR     A
00BF FC                MOV     R4,A
00C0 FD                MOV     R5,A
00C1 FE                MOV     R6,A
00C2 7818              MOV     R0,#018H
00C4 120000      E     LCALL   ?C?LSHL
00C7 A804              MOV     R0,AR4
00C9 A905              MOV     R1,AR5
00CB AA06              MOV     R2,AR6
00CD AB07              MOV     R3,AR7
00CF D007              POP     AR7
00D1 D006              POP     AR6
00D3 D005              POP     AR5
00D5 D004              POP     AR4
00D7 EF                MOV     A,R7
00D8 4B                ORL     A,R3
00D9 FF                MOV     R7,A
00DA EE                MOV     A,R6
00DB 4A                ORL     A,R2
00DC FE                MOV     R6,A
00DD ED                MOV     A,R5
00DE 49                ORL     A,R1
00DF FD                MOV     R5,A
00E0 EC                MOV     A,R4
00E1 48                ORL     A,R0
00E2 FC                MOV     R4,A
00E3 900000      R     MOV     DPTR,#intState
00E6 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2297
00E9 9044C8            MOV     DPTR,#044C8H
00EC 74FF              MOV     A,#0FFH
00EE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2298
00EF A3                INC     DPTR
00F0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2299
00F1 A3                INC     DPTR
00F2 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 100 

                                           ; SOURCE LINE # 2300
00F3 A3                INC     DPTR
00F4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2312
00F5 900000      R     MOV     DPTR,#interruptState
00F8 E0                MOVX    A,@DPTR
00F9 FF                MOV     R7,A
00FA 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2314
00FD 900000      R     MOV     DPTR,#intState
0100 E0                MOVX    A,@DPTR
0101 FC                MOV     R4,A
0102 A3                INC     DPTR
0103 E0                MOVX    A,@DPTR
0104 FD                MOV     R5,A
0105 A3                INC     DPTR
0106 E0                MOVX    A,@DPTR
0107 FE                MOV     R6,A
0108 A3                INC     DPTR
0109 E0                MOVX    A,@DPTR
010A FF                MOV     R7,A
                                           ; SOURCE LINE # 2315
010B         ?C0170:
010B 22                RET     
             ; FUNCTION CyDisableInts (END)

             ; FUNCTION _CyEnableInts (BEGIN)
                                           ; SOURCE LINE # 2332
0000 900000      R     MOV     DPTR,#mask
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2333
                                           ; SOURCE LINE # 2337
0006 120000      E     LCALL   CyEnterCriticalSection
0009 900000      R     MOV     DPTR,#interruptState
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2342
000E 900000      R     MOV     DPTR,#mask
0011 E0                MOVX    A,@DPTR
0012 FC                MOV     R4,A
0013 A3                INC     DPTR
0014 E0                MOVX    A,@DPTR
0015 FD                MOV     R5,A
0016 A3                INC     DPTR
0017 E0                MOVX    A,@DPTR
0018 FE                MOV     R6,A
0019 A3                INC     DPTR
001A E0                MOVX    A,@DPTR
001B FF                MOV     R7,A
001C 7818              MOV     R0,#018H
001E 120000      E     LCALL   ?C?ULSHR
0021 9044C3            MOV     DPTR,#044C3H
0024 EF                MOV     A,R7
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2343
0026 900000      R     MOV     DPTR,#mask
0029 E0                MOVX    A,@DPTR
002A FC                MOV     R4,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FD                MOV     R5,A
002E A3                INC     DPTR
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 101 

002F E0                MOVX    A,@DPTR
0030 FE                MOV     R6,A
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 7810              MOV     R0,#010H
0036 120000      E     LCALL   ?C?ULSHR
0039 9044C2            MOV     DPTR,#044C2H
003C EF                MOV     A,R7
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2344
003E 900000      R     MOV     DPTR,#mask
0041 E0                MOVX    A,@DPTR
0042 FC                MOV     R4,A
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 FD                MOV     R5,A
0046 A3                INC     DPTR
0047 E0                MOVX    A,@DPTR
0048 FE                MOV     R6,A
0049 A3                INC     DPTR
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C 7808              MOV     R0,#08H
004E 120000      E     LCALL   ?C?ULSHR
0051 9044C1            MOV     DPTR,#044C1H
0054 EF                MOV     A,R7
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2345
0056 900000      R     MOV     DPTR,#mask
0059 E0                MOVX    A,@DPTR
005A A3                INC     DPTR
005B E0                MOVX    A,@DPTR
005C A3                INC     DPTR
005D E0                MOVX    A,@DPTR
005E A3                INC     DPTR
005F E0                MOVX    A,@DPTR
0060 9044C0            MOV     DPTR,#044C0H
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2353
0064 900000      R     MOV     DPTR,#interruptState
0067 E0                MOVX    A,@DPTR
0068 FF                MOV     R7,A
0069 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2355
006C 22                RET     
             ; FUNCTION _CyEnableInts (END)

             ; FUNCTION IntDefaultHandler (BEGIN)
                                           ; SOURCE LINE # 2648
0000         ?C0172:
                                           ; SOURCE LINE # 2654
                                           ; SOURCE LINE # 2655
                                           ; SOURCE LINE # 2660
0000 80FE              SJMP    ?C0172
0002 32                RETI    
             ; FUNCTION IntDefaultHandler (END)

             ; FUNCTION CyIntInitVectors (BEGIN)
                                           ; SOURCE LINE # 2679
                                           ; SOURCE LINE # 2680
                                           ; SOURCE LINE # 2683
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 102 

0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#i
0004 F0                MOVX    @DPTR,A
0005         ?C0175:
0005 900000      R     MOV     DPTR,#i
0008 E0                MOVX    A,@DPTR
0009 D3                SETB    C
000A 941F              SUBB    A,#01FH
000C 5020              JNC     ?C0178
                                           ; SOURCE LINE # 2684
                                           ; SOURCE LINE # 2685
000E E0                MOVX    A,@DPTR
000F 75F002            MOV     B,#02H
0012 A4                MUL     AB
0013 2400              ADD     A,#00H
0015 FF                MOV     R7,A
0016 E5F0              MOV     A,B
0018 3444              ADDC    A,#044H
001A FA                MOV     R2,A
001B A907              MOV     R1,AR7
001D 7B01              MOV     R3,#01H
001F 7C00        R     MOV     R4,#HIGH IntDefaultHandler
0021 7D00        R     MOV     R5,#LOW IntDefaultHandler
0023 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 2686
0026 900000      R     MOV     DPTR,#i
0029 E0                MOVX    A,@DPTR
002A 04                INC     A
002B F0                MOVX    @DPTR,A
002C 80D7              SJMP    ?C0175
                                           ; SOURCE LINE # 2687
002E         ?C0178:
002E 22                RET     
             ; FUNCTION CyIntInitVectors (END)

             ; FUNCTION _CyIntSetVector (BEGIN)
                                           ; SOURCE LINE # 2705
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EC                MOV     A,R4
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2706
                                           ; SOURCE LINE # 2707
                                           ; SOURCE LINE # 2709
000B 900000      R     MOV     DPTR,#number
000E E0                MOVX    A,@DPTR
000F D3                SETB    C
0010 941F              SUBB    A,#01FH
0012 5002              JNC     ?C0180
0014 8001              SJMP    ?C0181
0016         ?C0180:
0016 C3                CLR     C
0017         ?C0181:
0017 4005              JC      ?C0179
0019 7F00              MOV     R7,#00H
001B 120000      R     LCALL   _?CyHalt
001E         ?C0179:
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 103 

                                           ; SOURCE LINE # 2712
001E 900000      R     MOV     DPTR,#number
0021 E0                MOVX    A,@DPTR
0022 541F              ANL     A,#01FH
0024 25E0              ADD     A,ACC
0026 FF                MOV     R7,A
0027 E4                CLR     A
0028 33                RLC     A
0029 FE                MOV     R6,A
002A E4                CLR     A
002B 2F                ADD     A,R7
002C FF                MOV     R7,A
002D EE                MOV     A,R6
002E 3444              ADDC    A,#044H
0030 FA                MOV     R2,A
0031 A907              MOV     R1,AR7
0033 7B01              MOV     R3,#01H
0035 120000      E     LCALL   _cyread16_nodpx
0038 900000      R     MOV     DPTR,#oldIsr
003B EE                MOV     A,R6
003C F0                MOVX    @DPTR,A
003D A3                INC     DPTR
003E EF                MOV     A,R7
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2716
0040 900000      R     MOV     DPTR,#number
0043 E0                MOVX    A,@DPTR
0044 75F002            MOV     B,#02H
0047 A4                MUL     AB
0048 2400              ADD     A,#00H
004A FF                MOV     R7,A
004B E5F0              MOV     A,B
004D 3444              ADDC    A,#044H
004F FA                MOV     R2,A
0050 A907              MOV     R1,AR7
0052 7B01              MOV     R3,#01H
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FE                MOV     R6,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 FF                MOV     R7,A
005A FD                MOV     R5,A
005B AC06              MOV     R4,AR6
005D 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 2718
0060 900000      R     MOV     DPTR,#oldIsr
0063 E0                MOVX    A,@DPTR
0064 FE                MOV     R6,A
0065 A3                INC     DPTR
0066 E0                MOVX    A,@DPTR
0067 FF                MOV     R7,A
                                           ; SOURCE LINE # 2719
0068         ?C0182:
0068 22                RET     
             ; FUNCTION _CyIntSetVector (END)

             ; FUNCTION _CyIntGetVector (BEGIN)
                                           ; SOURCE LINE # 2736
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 104 

                                           ; SOURCE LINE # 2737
                                           ; SOURCE LINE # 2738
0005 E0                MOVX    A,@DPTR
0006 D3                SETB    C
0007 941F              SUBB    A,#01FH
0009 5002              JNC     ?C0184
000B 8001              SJMP    ?C0185
000D         ?C0184:
000D C3                CLR     C
000E         ?C0185:
000E 4005              JC      ?C0183
0010 7F00              MOV     R7,#00H
0012 120000      R     LCALL   _?CyHalt
0015         ?C0183:
                                           ; SOURCE LINE # 2740
0015 900000      R     MOV     DPTR,#number
0018 E0                MOVX    A,@DPTR
0019 541F              ANL     A,#01FH
001B 25E0              ADD     A,ACC
001D FF                MOV     R7,A
001E E4                CLR     A
001F 33                RLC     A
0020 FE                MOV     R6,A
0021 E4                CLR     A
0022 2F                ADD     A,R7
0023 FF                MOV     R7,A
0024 EE                MOV     A,R6
0025 3444              ADDC    A,#044H
0027 FA                MOV     R2,A
0028 A907              MOV     R1,AR7
002A 7B01              MOV     R3,#01H
002C 120000      E     LCALL   _cyread16_nodpx
                                           ; SOURCE LINE # 2742
002F         ?C0186:
002F 22                RET     
             ; FUNCTION _CyIntGetVector (END)

             ; FUNCTION _CyIntSetPriority (BEGIN)
                                           ; SOURCE LINE # 2760
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2761
                                           ; SOURCE LINE # 2762
0008 E0                MOVX    A,@DPTR
0009 D3                SETB    C
000A 9407              SUBB    A,#07H
000C 5002              JNC     ?C0188
000E 8001              SJMP    ?C0189
0010         ?C0188:
0010 C3                CLR     C
0011         ?C0189:
0011 4005              JC      ?C0187
0013 7F00              MOV     R7,#00H
0015 120000      R     LCALL   _?CyHalt
0018         ?C0187:
                                           ; SOURCE LINE # 2764
0018 900000      R     MOV     DPTR,#number
001B E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 105 

001C D3                SETB    C
001D 941F              SUBB    A,#01FH
001F 5002              JNC     ?C0191
0021 8001              SJMP    ?C0192
0023         ?C0191:
0023 C3                CLR     C
0024         ?C0192:
0024 4005              JC      ?C0190
0026 7F00              MOV     R7,#00H
0028 120000      R     LCALL   _?CyHalt
002B         ?C0190:
                                           ; SOURCE LINE # 2766
002B 900000      R     MOV     DPTR,#priority
002E E0                MOVX    A,@DPTR
002F 5407              ANL     A,#07H
0031 75F020            MOV     B,#020H
0034 A4                MUL     AB
0035 FF                MOV     R7,A
0036 900000      R     MOV     DPTR,#number
0039 E0                MOVX    A,@DPTR
003A 541F              ANL     A,#01FH
003C 2480              ADD     A,#080H
003E F582              MOV     DPL,A
0040 E4                CLR     A
0041 3444              ADDC    A,#044H
0043 F583              MOV     DPH,A
0045 EF                MOV     A,R7
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2768
0047 22                RET     
             ; FUNCTION _CyIntSetPriority (END)

             ; FUNCTION _CyIntGetPriority (BEGIN)
                                           ; SOURCE LINE # 2785
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2786
                                           ; SOURCE LINE # 2787
                                           ; SOURCE LINE # 2789
0005 E0                MOVX    A,@DPTR
0006 D3                SETB    C
0007 941F              SUBB    A,#01FH
0009 5002              JNC     ?C0195
000B 8001              SJMP    ?C0196
000D         ?C0195:
000D C3                CLR     C
000E         ?C0196:
000E 4005              JC      ?C0194
0010 7F00              MOV     R7,#00H
0012 120000      R     LCALL   _?CyHalt
0015         ?C0194:
                                           ; SOURCE LINE # 2791
0015 900000      R     MOV     DPTR,#number
0018 E0                MOVX    A,@DPTR
0019 541F              ANL     A,#01FH
001B 2480              ADD     A,#080H
001D F582              MOV     DPL,A
001F E4                CLR     A
0020 3444              ADDC    A,#044H
0022 F583              MOV     DPH,A
0024 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 106 

0025 FF                MOV     R7,A
0026 C4                SWAP    A
0027 13                RRC     A
0028 5407              ANL     A,#07H
002A 900000      R     MOV     DPTR,#priority
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2793
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
                                           ; SOURCE LINE # 2794
0030         ?C0197:
0030 22                RET     
             ; FUNCTION _CyIntGetPriority (END)

             ; FUNCTION _CyIntGetState (BEGIN)
                                           ; SOURCE LINE # 2811
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2812
                                           ; SOURCE LINE # 2813
                                           ; SOURCE LINE # 2815
0005 E0                MOVX    A,@DPTR
0006 D3                SETB    C
0007 941F              SUBB    A,#01FH
0009 5002              JNC     ?C0199
000B 8001              SJMP    ?C0200
000D         ?C0199:
000D C3                CLR     C
000E         ?C0200:
000E 4005              JC      ?C0198
0010 7F00              MOV     R7,#00H
0012 120000      R     LCALL   _?CyHalt
0015         ?C0198:
                                           ; SOURCE LINE # 2818
0015 900000      R     MOV     DPTR,#number
0018 E0                MOVX    A,@DPTR
0019 541F              ANL     A,#01FH
001B 7E00              MOV     R6,#00H
001D 7803              MOV     R0,#03H
001F         ?C0205:
001F CE                XCH     A,R6
0020 C3                CLR     C
0021 13                RRC     A
0022 CE                XCH     A,R6
0023 13                RRC     A
0024 D8F9              DJNZ    R0,?C0205
0026 24C0              ADD     A,#0C0H
0028 FF                MOV     R7,A
0029 EE                MOV     A,R6
002A 3444              ADDC    A,#044H
002C 900000      R     MOV     DPTR,#stateReg
002F F0                MOVX    @DPTR,A
0030 A3                INC     DPTR
0031 EF                MOV     A,R7
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2821
0033 900000      R     MOV     DPTR,#number
0036 E0                MOVX    A,@DPTR
0037 5407              ANL     A,#07H
0039 FF                MOV     R7,A
003A 7401              MOV     A,#01H
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 107 

003C A807              MOV     R0,AR7
003E 08                INC     R0
003F 8002              SJMP    ?C0207
0041         ?C0206:
0041 C3                CLR     C
0042 33                RLC     A
0043         ?C0207:
0043 D8FC              DJNZ    R0,?C0206
0045 FF                MOV     R7,A
0046 900000      R     MOV     DPTR,#stateReg
0049 E0                MOVX    A,@DPTR
004A FC                MOV     R4,A
004B A3                INC     DPTR
004C E0                MOVX    A,@DPTR
004D F582              MOV     DPL,A
004F 8C83              MOV     DPH,R4
0051 E0                MOVX    A,@DPTR
0052 5F                ANL     A,R7
0053 6004              JZ      ?C0201
0055 7F01              MOV     R7,#01H
0057 8002              SJMP    ?C0202
0059         ?C0201:
0059 7F00              MOV     R7,#00H
005B         ?C0202:
                                           ; SOURCE LINE # 2822
005B         ?C0203:
005B 22                RET     
             ; FUNCTION _CyIntGetState (END)

             ; FUNCTION _CyGetUniqueId (BEGIN)
                                           ; SOURCE LINE # 3343
0000 900000      R     MOV     DPTR,#uniqueId
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EA                MOV     A,R2
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3344
                                           ; SOURCE LINE # 3356
000B 7B0C              MOV     R3,#0CH
000D 7A01              MOV     R2,#01H
000F 7903              MOV     R1,#03H
0011 120000      E     LCALL   _cyread8
0014 E4                CLR     A
0015 FC                MOV     R4,A
0016 FD                MOV     R5,A
0017 FE                MOV     R6,A
0018 900000      R     MOV     DPTR,#uniqueId
001B E0                MOVX    A,@DPTR
001C FB                MOV     R3,A
001D A3                INC     DPTR
001E E0                MOVX    A,@DPTR
001F FA                MOV     R2,A
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022 F9                MOV     R1,A
0023 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3357
0026 900000      R     MOV     DPTR,#uniqueId
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 108 

0029 E0                MOVX    A,@DPTR
002A FB                MOV     R3,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FA                MOV     R2,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 F9                MOV     R1,A
0031 C003              PUSH    AR3
0033 C002              PUSH    AR2
0035 C001              PUSH    AR1
0037 120000      E     LCALL   ?C?LLDPTR
003A C004              PUSH    AR4
003C C005              PUSH    AR5
003E C006              PUSH    AR6
0040 C007              PUSH    AR7
0042 7B0C              MOV     R3,#0CH
0044 7A01              MOV     R2,#01H
0046 7904              MOV     R1,#04H
0048 120000      E     LCALL   _cyread8
004B E4                CLR     A
004C FC                MOV     R4,A
004D FD                MOV     R5,A
004E FE                MOV     R6,A
004F 7808              MOV     R0,#08H
0051 120000      E     LCALL   ?C?LSHL
0054 A804              MOV     R0,AR4
0056 A905              MOV     R1,AR5
0058 AA06              MOV     R2,AR6
005A AB07              MOV     R3,AR7
005C D007              POP     AR7
005E D006              POP     AR6
0060 D005              POP     AR5
0062 D004              POP     AR4
0064 EF                MOV     A,R7
0065 4B                ORL     A,R3
0066 FF                MOV     R7,A
0067 EE                MOV     A,R6
0068 4A                ORL     A,R2
0069 FE                MOV     R6,A
006A ED                MOV     A,R5
006B 49                ORL     A,R1
006C FD                MOV     R5,A
006D EC                MOV     A,R4
006E 48                ORL     A,R0
006F FC                MOV     R4,A
0070 D001              POP     AR1
0072 D002              POP     AR2
0074 D003              POP     AR3
0076 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3358
0079 900000      R     MOV     DPTR,#uniqueId
007C E0                MOVX    A,@DPTR
007D FB                MOV     R3,A
007E A3                INC     DPTR
007F E0                MOVX    A,@DPTR
0080 FA                MOV     R2,A
0081 A3                INC     DPTR
0082 E0                MOVX    A,@DPTR
0083 F9                MOV     R1,A
0084 C003              PUSH    AR3
0086 C002              PUSH    AR2
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 109 

0088 C001              PUSH    AR1
008A 120000      E     LCALL   ?C?LLDPTR
008D C004              PUSH    AR4
008F C005              PUSH    AR5
0091 C006              PUSH    AR6
0093 C007              PUSH    AR7
0095 7B00              MOV     R3,#00H
0097 7A46              MOV     R2,#046H
0099 79EC              MOV     R1,#0ECH
009B 120000      E     LCALL   _cyread8
009E E4                CLR     A
009F FC                MOV     R4,A
00A0 FD                MOV     R5,A
00A1 FE                MOV     R6,A
00A2 7810              MOV     R0,#010H
00A4 120000      E     LCALL   ?C?LSHL
00A7 A804              MOV     R0,AR4
00A9 A905              MOV     R1,AR5
00AB AA06              MOV     R2,AR6
00AD AB07              MOV     R3,AR7
00AF D007              POP     AR7
00B1 D006              POP     AR6
00B3 D005              POP     AR5
00B5 D004              POP     AR4
00B7 EF                MOV     A,R7
00B8 4B                ORL     A,R3
00B9 FF                MOV     R7,A
00BA EE                MOV     A,R6
00BB 4A                ORL     A,R2
00BC FE                MOV     R6,A
00BD ED                MOV     A,R5
00BE 49                ORL     A,R1
00BF FD                MOV     R5,A
00C0 EC                MOV     A,R4
00C1 48                ORL     A,R0
00C2 FC                MOV     R4,A
00C3 D001              POP     AR1
00C5 D002              POP     AR2
00C7 D003              POP     AR3
00C9 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3359
00CC 900000      R     MOV     DPTR,#uniqueId
00CF E0                MOVX    A,@DPTR
00D0 FB                MOV     R3,A
00D1 A3                INC     DPTR
00D2 E0                MOVX    A,@DPTR
00D3 FA                MOV     R2,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 F9                MOV     R1,A
00D7 C003              PUSH    AR3
00D9 C002              PUSH    AR2
00DB C001              PUSH    AR1
00DD 120000      E     LCALL   ?C?LLDPTR
00E0 C004              PUSH    AR4
00E2 C005              PUSH    AR5
00E4 C006              PUSH    AR6
00E6 C007              PUSH    AR7
00E8 7B0C              MOV     R3,#0CH
00EA 7A01              MOV     R2,#01H
00EC 7902              MOV     R1,#02H
00EE 120000      E     LCALL   _cyread8
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 110 

00F1 E4                CLR     A
00F2 FC                MOV     R4,A
00F3 FD                MOV     R5,A
00F4 FE                MOV     R6,A
00F5 7818              MOV     R0,#018H
00F7 120000      E     LCALL   ?C?LSHL
00FA A804              MOV     R0,AR4
00FC A905              MOV     R1,AR5
00FE AA06              MOV     R2,AR6
0100 AB07              MOV     R3,AR7
0102 D007              POP     AR7
0104 D006              POP     AR6
0106 D005              POP     AR5
0108 D004              POP     AR4
010A EF                MOV     A,R7
010B 4B                ORL     A,R3
010C FF                MOV     R7,A
010D EE                MOV     A,R6
010E 4A                ORL     A,R2
010F FE                MOV     R6,A
0110 ED                MOV     A,R5
0111 49                ORL     A,R1
0112 FD                MOV     R5,A
0113 EC                MOV     A,R4
0114 48                ORL     A,R0
0115 FC                MOV     R4,A
0116 D001              POP     AR1
0118 D002              POP     AR2
011A D003              POP     AR3
011C 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3361
011F 7B0C              MOV     R3,#0CH
0121 7A01              MOV     R2,#01H
0123 7901              MOV     R1,#01H
0125 120000      E     LCALL   _cyread8
0128 E4                CLR     A
0129 FC                MOV     R4,A
012A FD                MOV     R5,A
012B FE                MOV     R6,A
012C 900000      R     MOV     DPTR,#uniqueId
012F E0                MOVX    A,@DPTR
0130 FB                MOV     R3,A
0131 A3                INC     DPTR
0132 E0                MOVX    A,@DPTR
0133 FA                MOV     R2,A
0134 A3                INC     DPTR
0135 E0                MOVX    A,@DPTR
0136 2404              ADD     A,#04H
0138 F9                MOV     R1,A
0139 E4                CLR     A
013A 3A                ADDC    A,R2
013B FA                MOV     R2,A
013C 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3362
013F 900000      R     MOV     DPTR,#uniqueId
0142 E0                MOVX    A,@DPTR
0143 FB                MOV     R3,A
0144 A3                INC     DPTR
0145 E0                MOVX    A,@DPTR
0146 FA                MOV     R2,A
0147 A3                INC     DPTR
0148 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 111 

0149 2404              ADD     A,#04H
014B F9                MOV     R1,A
014C E4                CLR     A
014D 3A                ADDC    A,R2
014E FA                MOV     R2,A
014F C003              PUSH    AR3
0151 C002              PUSH    AR2
0153 C001              PUSH    AR1
0155 120000      E     LCALL   ?C?LLDPTR
0158 C004              PUSH    AR4
015A C005              PUSH    AR5
015C C006              PUSH    AR6
015E C007              PUSH    AR7
0160 7B0C              MOV     R3,#0CH
0162 7A01              MOV     R2,#01H
0164 7900              MOV     R1,#00H
0166 120000      E     LCALL   _cyread8
0169 E4                CLR     A
016A FC                MOV     R4,A
016B FD                MOV     R5,A
016C FE                MOV     R6,A
016D 7808              MOV     R0,#08H
016F 120000      E     LCALL   ?C?LSHL
0172 A804              MOV     R0,AR4
0174 A905              MOV     R1,AR5
0176 AA06              MOV     R2,AR6
0178 AB07              MOV     R3,AR7
017A D007              POP     AR7
017C D006              POP     AR6
017E D005              POP     AR5
0180 D004              POP     AR4
0182 EF                MOV     A,R7
0183 4B                ORL     A,R3
0184 FF                MOV     R7,A
0185 EE                MOV     A,R6
0186 4A                ORL     A,R2
0187 FE                MOV     R6,A
0188 ED                MOV     A,R5
0189 49                ORL     A,R1
018A FD                MOV     R5,A
018B EC                MOV     A,R4
018C 48                ORL     A,R0
018D FC                MOV     R4,A
018E D001              POP     AR1
0190 D002              POP     AR2
0192 D003              POP     AR3
0194 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3363
0197 900000      R     MOV     DPTR,#uniqueId
019A E0                MOVX    A,@DPTR
019B FB                MOV     R3,A
019C A3                INC     DPTR
019D E0                MOVX    A,@DPTR
019E FA                MOV     R2,A
019F A3                INC     DPTR
01A0 E0                MOVX    A,@DPTR
01A1 2404              ADD     A,#04H
01A3 F9                MOV     R1,A
01A4 E4                CLR     A
01A5 3A                ADDC    A,R2
01A6 FA                MOV     R2,A
01A7 C003              PUSH    AR3
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 112 

01A9 C002              PUSH    AR2
01AB C001              PUSH    AR1
01AD 120000      E     LCALL   ?C?LLDPTR
01B0 C004              PUSH    AR4
01B2 C005              PUSH    AR5
01B4 C006              PUSH    AR6
01B6 C007              PUSH    AR7
01B8 7B0C              MOV     R3,#0CH
01BA 7A01              MOV     R2,#01H
01BC 7905              MOV     R1,#05H
01BE 120000      E     LCALL   _cyread8
01C1 E4                CLR     A
01C2 FC                MOV     R4,A
01C3 FD                MOV     R5,A
01C4 FE                MOV     R6,A
01C5 7810              MOV     R0,#010H
01C7 120000      E     LCALL   ?C?LSHL
01CA A804              MOV     R0,AR4
01CC A905              MOV     R1,AR5
01CE AA06              MOV     R2,AR6
01D0 AB07              MOV     R3,AR7
01D2 D007              POP     AR7
01D4 D006              POP     AR6
01D6 D005              POP     AR5
01D8 D004              POP     AR4
01DA EF                MOV     A,R7
01DB 4B                ORL     A,R3
01DC FF                MOV     R7,A
01DD EE                MOV     A,R6
01DE 4A                ORL     A,R2
01DF FE                MOV     R6,A
01E0 ED                MOV     A,R5
01E1 49                ORL     A,R1
01E2 FD                MOV     R5,A
01E3 EC                MOV     A,R4
01E4 48                ORL     A,R0
01E5 FC                MOV     R4,A
01E6 D001              POP     AR1
01E8 D002              POP     AR2
01EA D003              POP     AR3
01EC 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3364
01EF 900000      R     MOV     DPTR,#uniqueId
01F2 E0                MOVX    A,@DPTR
01F3 FB                MOV     R3,A
01F4 A3                INC     DPTR
01F5 E0                MOVX    A,@DPTR
01F6 FA                MOV     R2,A
01F7 A3                INC     DPTR
01F8 E0                MOVX    A,@DPTR
01F9 2404              ADD     A,#04H
01FB F9                MOV     R1,A
01FC E4                CLR     A
01FD 3A                ADDC    A,R2
01FE FA                MOV     R2,A
01FF C003              PUSH    AR3
0201 C002              PUSH    AR2
0203 C001              PUSH    AR1
0205 120000      E     LCALL   ?C?LLDPTR
0208 C004              PUSH    AR4
020A C005              PUSH    AR5
020C C006              PUSH    AR6
C51 COMPILER V9.51   CYLIB                                                                 10/31/2016 12:08:35 PAGE 113 

020E C007              PUSH    AR7
0210 7B0C              MOV     R3,#0CH
0212 7A01              MOV     R2,#01H
0214 7906              MOV     R1,#06H
0216 120000      E     LCALL   _cyread8
0219 E4                CLR     A
021A FC                MOV     R4,A
021B FD                MOV     R5,A
021C FE                MOV     R6,A
021D 7818              MOV     R0,#018H
021F 120000      E     LCALL   ?C?LSHL
0222 A804              MOV     R0,AR4
0224 A905              MOV     R1,AR5
0226 AA06              MOV     R2,AR6
0228 AB07              MOV     R3,AR7
022A D007              POP     AR7
022C D006              POP     AR6
022E D005              POP     AR5
0230 D004              POP     AR4
0232 EF                MOV     A,R7
0233 4B                ORL     A,R3
0234 FF                MOV     R7,A
0235 EE                MOV     A,R6
0236 4A                ORL     A,R2
0237 FE                MOV     R6,A
0238 ED                MOV     A,R5
0239 49                ORL     A,R1
023A FD                MOV     R5,A
023B EC                MOV     A,R4
023C 48                ORL     A,R0
023D FC                MOV     R4,A
023E D001              POP     AR1
0240 D002              POP     AR2
0242 D003              POP     AR3
0244 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 3366
0247 22                RET     
             ; FUNCTION _CyGetUniqueId (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4269    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     15     102
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
